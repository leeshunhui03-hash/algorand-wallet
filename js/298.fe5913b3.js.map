{"version":3,"file":"js/298.fe5913b3.js","mappings":"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","sources":["webpack://wallet/./src/scripts/interface/CAsset.ts","webpack://wallet/./node_modules/biatec-scheduler/dist/index.mjs","webpack://wallet/./src/scripts/encoding/base642base64url.ts","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/util.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/logging.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/config.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/config.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/transaction/perform-atomic-transaction-composer-simulate.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/debugging/simulate-and-persist-response.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/transaction/transaction.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/app.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/app.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/indexer-lookup.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/app-deploy.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/debugging.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/debugging/debugging.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/transfer/transfer-algos.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/logic-error.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/app-client.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/asset.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/app-client.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/dispenser-client.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/urlTokenBaseHTTPClient.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/algo-http-client-with-retry.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/client-manager.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/amount.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/amount.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/composer.mjs","webpack://wallet/./node_modules/@algorandfoundation/algokit-utils/types/account-manager.mjs"],"sourcesContent":["import IAsset from \"./IAsset\";\n\nclass CAsset implements IAsset {\n  \"asset-id\": number = 0;\n  amount: number = 0;\n  name: string = \"\";\n  decimals: number = 0;\n  \"unit-name\": string = \"\";\n  type: string = \"\";\n  label: string = \"\";\n}\n\nexport default CAsset;\n","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/scripts/scheduler/getBoxReferenceApp.ts\nimport algosdk from \"algosdk\";\nvar getBoxReferenceApp = (appPoolId, taskAppId) => {\n  return {\n    appIndex: appPoolId,\n    name: new Uint8Array(Buffer.concat([Buffer.from(\"t\", \"ascii\"), algosdk.bigIntToBytes(taskAppId, 8)]))\n  };\n};\nvar getBoxReferenceApp_default = getBoxReferenceApp;\n\n// src/scripts/scheduler/getBoxReferenceUser.ts\nvar getBoxReferenceUser = (appPoolId, userAddress) => {\n  return {\n    appIndex: appPoolId,\n    name: new Uint8Array(Buffer.concat([Buffer.from(\"u\", \"ascii\"), Buffer.from(userAddress.publicKey)]))\n  };\n};\nvar getBoxReferenceUser_default = getBoxReferenceUser;\n\n// src/scripts/scheduler/getPoolManagerApp.ts\nvar getPoolManagerApp = (env) => {\n  switch (env) {\n    case \"mainnet-v1.0\":\n      return 1765620242;\n    case \"testnet-v1.0\":\n      return 643872805;\n    case \"voitest-v1\":\n      return 40433700;\n    case \"sandnet-v1\":\n    default:\n      return 1114;\n  }\n};\nvar getPoolManagerApp_default = getPoolManagerApp;\n\n// src/scripts/scheduler/parseBoxData.ts\nimport algosdk2 from \"algosdk\";\nvar parseBoxData = (input) => {\n  if (input.length !== 24) {\n    throw new Error(`Box has wrong length: ${input.length} ${Buffer.from(input).toString(\"hex\")}`);\n  }\n  const ret = {\n    funds: Number(algosdk2.decodeUint64(input.subarray(0, 8), \"safe\")),\n    app: Number(algosdk2.decodeUint64(input.subarray(8, 16), \"safe\")),\n    fee: Number(algosdk2.decodeUint64(input.subarray(16, 24), \"safe\"))\n  };\n  return ret;\n};\nvar parseBoxData_default = parseBoxData;\n\n// contracts/clients/BiatecTaskManagerClient.ts\nimport * as algokit from \"@algorandfoundation/algokit-utils\";\nimport { AtomicTransactionComposer, modelsv2 } from \"algosdk\";\nvar APP_SPEC = {\n  \"hints\": {\n    \"createApplication()void\": {\n      \"call_config\": {\n        \"no_op\": \"CREATE\"\n      }\n    },\n    \"updateApplication(string)void\": {\n      \"call_config\": {\n        \"update_application\": \"CALL\"\n      }\n    },\n    \"bootstrap(pay,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"registerTask(pay,(uint64,uint64,uint64))void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"unregisterTask(uint64,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"executeTask(appl)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"fundTask(uint64,txn)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"changeTaskFee(uint64,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"unfundTask(uint64,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"payment(address,uint64,address,string)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"assetTransfer(address,uint64,uint64,address,string)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"sendOfflineKeyRegistration()void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    }\n  },\n  \"bare_call_config\": {\n    \"no_op\": \"NEVER\",\n    \"opt_in\": \"NEVER\",\n    \"close_out\": \"NEVER\",\n    \"update_application\": \"NEVER\",\n    \"delete_application\": \"NEVER\"\n  },\n  \"schema\": {\n    \"local\": {\n      \"declared\": {},\n      \"reserved\": {}\n    },\n    \"global\": {\n      \"declared\": {\n        \"feeAssetId\": {\n          \"type\": \"uint64\",\n          \"key\": \"fa\"\n        },\n        \"depositedFunds\": {\n          \"type\": \"uint64\",\n          \"key\": \"d\"\n        },\n        \"version\": {\n          \"type\": \"bytes\",\n          \"key\": \"scver\"\n        }\n      },\n      \"reserved\": {}\n    }\n  },\n  \"state\": {\n    \"global\": {\n      \"num_byte_slices\": 1,\n      \"num_uints\": 2\n    },\n    \"local\": {\n      \"num_byte_slices\": 0,\n      \"num_uints\": 0\n    }\n  },\n  \"source\": {\n    \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjkwLjMKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpjYWxsX1VwZGF0ZUFwcGxpY2F0aW9uICpOT1RfSU1QTEVNRU5URUQgKmNyZWF0ZV9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRAoKKk5PVF9JTVBMRU1FTlRFRDoKCWVycgoKLy8gY3JlYXRlQXBwbGljYXRpb24oKXZvaWQKKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCS8vIGV4ZWN1dGUgY3JlYXRlQXBwbGljYXRpb24oKXZvaWQKCWNhbGxzdWIgY3JlYXRlQXBwbGljYXRpb24KCWludCAxCglyZXR1cm4KCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKCk6IHZvaWQKLy8KLy8gSW5pdGlhbCBzZXR1cApjcmVhdGVBcHBsaWNhdGlvbjoKCXByb3RvIDAgMAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjM4CgkvLyB0aGlzLnZlcnNpb24udmFsdWUgPSAnQklBVEVDLUNST04tUE9PTC0wMS0wMS0wMScKCWJ5dGUgMHg3MzYzNzY2NTcyIC8vICJzY3ZlciIKCWJ5dGUgMHgwMDE5NDI0OTQxNTQ0NTQzMmQ0MzUyNGY0ZTJkNTA0ZjRmNGMyZDMwMzEyZDMwMzEyZDMwMzEKCWFwcF9nbG9iYWxfcHV0CglyZXRzdWIKCi8vIHVwZGF0ZUFwcGxpY2F0aW9uKHN0cmluZyl2b2lkCiphYmlfcm91dGVfdXBkYXRlQXBwbGljYXRpb246CgkvLyB2ZXJzaW9uOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSB1cGRhdGVBcHBsaWNhdGlvbihzdHJpbmcpdm9pZAoJY2FsbHN1YiB1cGRhdGVBcHBsaWNhdGlvbgoJaW50IDEKCXJldHVybgoKLy8gdXBkYXRlQXBwbGljYXRpb24odmVyc2lvbjogc3RyaW5nKTogdm9pZAovLwovLyBDcmVhdG9yIGNhbiB1cGRhdGUgYXBwbGljYXRpb24KLy8gQHBhcmFtIHZlcnNpb24gQXBwIHZlcnNpb24KdXBkYXRlQXBwbGljYXRpb246Cglwcm90byAxIDAKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czo0NgoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjQ3CgkvLyB0aGlzLnZlcnNpb24udmFsdWUgPSB2ZXJzaW9uCglieXRlIDB4NzM2Mzc2NjU3MiAvLyAic2N2ZXIiCglmcmFtZV9kaWcgLTEgLy8gdmVyc2lvbjogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gYm9vdHN0cmFwKHBheSx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX2Jvb3RzdHJhcDoKCS8vIGZlZUFzc2V0SWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIHR4QmFzZURlcG9zaXQ6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgcGF5Cgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBib290c3RyYXAocGF5LHVpbnQ2NCl2b2lkCgljYWxsc3ViIGJvb3RzdHJhcAoJaW50IDEKCXJldHVybgoKLy8gYm9vdHN0cmFwKHR4QmFzZURlcG9zaXQ6IFBheVR4biwgZmVlQXNzZXRJZDogQXNzZXRJRCk6IHZvaWQKLy8KLy8gQm9vdHN0cmFwIHRoZSBjb250cmFjdCB0byBvcHRpbiB0byB0aGUgZmVlIGFzc2V0IGFuZCBzZXR1cCBiYXNpYyB2YXJpYWJsZXMKLy8KLy8gQHBhcmFtIHR4QmFzZURlcG9zaXQgRGVwb3NpdCBNQlIKLy8gQHBhcmFtIGZlZUFzc2V0SWQgIEZlZSBhc3NldCBpZApib290c3RyYXA6Cglwcm90byAyIDAKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czo1NwoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjU5CgkvLyB2ZXJpZnlQYXlUeG4odHhCYXNlRGVwb3NpdCwgewoJLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICBhbW91bnQ6IHsgZ3JlYXRlclRoYW5FcXVhbFRvOiAwIH0sCgkvLyAgICAgfSkKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIHR4QmFzZURlcG9zaXQ6IFBheVR4bgoJZ3R4bnMgUmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIHR4QmFzZURlcG9zaXQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglpbnQgMAoJPj0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjY0CgkvLyB0aGlzLmZlZUFzc2V0SWQudmFsdWUgPSBmZWVBc3NldElkLmlkCglieXRlIDB4NjY2MSAvLyAiZmEiCglmcmFtZV9kaWcgLTIgLy8gZmVlQXNzZXRJZDogQXNzZXRJRAoJYXBwX2dsb2JhbF9wdXQKCgkvLyAqaWYwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6NzcKCS8vIHRoaXMuZmVlQXNzZXRJZC52YWx1ZSA+IDAKCWJ5dGUgMHg2NjYxIC8vICJmYSIKCWFwcF9nbG9iYWxfZ2V0CglpbnQgMAoJPgoJYnogKmlmMF9lbmQKCgkvLyAqaWYwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjc4CgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IGdsb2JhbHMuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKCS8vICAgICAgICAgYXNzZXRBbW91bnQ6IDAsCgkvLyAgICAgICAgIHhmZXJBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KHRoaXMuZmVlQXNzZXRJZC52YWx1ZSksCgkvLyAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGF4ZmVyCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6NzkKCS8vIGFzc2V0UmVjZWl2ZXI6IGdsb2JhbHMuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjgwCgkvLyBhc3NldEFtb3VudDogMAoJaW50IDAKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czo4MQoJLy8geGZlckFzc2V0OiBBc3NldElELmZyb21VaW50NjQodGhpcy5mZWVBc3NldElkLnZhbHVlKQoJYnl0ZSAweDY2NjEgLy8gImZhIgoJYXBwX2dsb2JhbF9nZXQKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKKmlmMF9lbmQ6CglyZXRzdWIKCi8vIHJlZ2lzdGVyVGFzayhwYXksKHVpbnQ2NCx1aW50NjQsdWludDY0KSl2b2lkCiphYmlfcm91dGVfcmVnaXN0ZXJUYXNrOgoJLy8gdGFzazogKHVpbnQ2NCx1aW50NjQsdWludDY0KQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAyNAoJPT0KCWFzc2VydAoKCS8vIHJlZ2lzdHJhdGlvbkZlZURlcG9zaXQ6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgcGF5Cgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSByZWdpc3RlclRhc2socGF5LCh1aW50NjQsdWludDY0LHVpbnQ2NCkpdm9pZAoJY2FsbHN1YiByZWdpc3RlclRhc2sKCWludCAxCglyZXR1cm4KCi8vIHJlZ2lzdGVyVGFzayhyZWdpc3RyYXRpb25GZWVEZXBvc2l0OiBQYXlUeG4sIHRhc2s6IFRhc2spOiB2b2lkCi8vCi8vIFJlZ2lzdGVyIGEgdGFzayB0byBiZSBleGVjdXRlZAovLyBPbmx5IGFwcCBpdCBzZWxmIGNhbiBjYWxsIHJlZ2lzdGVyIHRhc2sKLy8KLy8gQHBhcmFtIHJlZ2lzdHJhdGlvbkZlZURlcG9zaXQgVGhlIGF4ZmVyIG9yIHBheSB0aGF0IGRlcG9zaXRzIHRoZSBpbml0aWFsIGZ1bmRzCi8vIEBwYXJhbSB0YXNrIFRoZSB0YXNrIG9iamVjdApyZWdpc3RlclRhc2s6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjk0CgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSB0YXNrLmFwcC5hZGRyZXNzKQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0yIC8vIHRhc2s6IFRhc2sKCWV4dHJhY3QgOCA4CglidG9pCglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czo5NQoJLy8gYXNzZXJ0KHRhc2suZnVuZHMgPT09IDApCglmcmFtZV9kaWcgLTIgLy8gdGFzazogVGFzawoJZXh0cmFjdCAwIDgKCWJ0b2kKCWludCAwCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6OTcKCS8vIHZlcmlmeVBheVR4bihyZWdpc3RyYXRpb25GZWVEZXBvc2l0LCB7CgkvLyAgICAgICByZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICB9KQoJLy8gdmVyaWZ5IHJlY2VpdmVyCglmcmFtZV9kaWcgLTEgLy8gcmVnaXN0cmF0aW9uRmVlRGVwb3NpdDogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxMDAKCS8vIGFzc2VydChyZWdpc3RyYXRpb25GZWVEZXBvc2l0LmFtb3VudCA+IDUwMF8wMDApCglmcmFtZV9kaWcgLTEgLy8gcmVnaXN0cmF0aW9uRmVlRGVwb3NpdDogUGF5VHhuCglndHhucyBBbW91bnQKCWludCA1MDBfMDAwCgk+Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxMDIKCS8vIHRoaXMudGFza3ModGFzay5hcHApLnZhbHVlID0gdGFzawoJYnl0ZSAweDc0IC8vICJ0IgoJZnJhbWVfZGlnIC0yIC8vIHRhc2s6IFRhc2sKCWV4dHJhY3QgOCA4CglidG9pCglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyAtMiAvLyB0YXNrOiBUYXNrCglib3hfcHV0CgoJLy8gKmlmMV9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjEwMwoJLy8gdGhpcy51c2VyMnRhc2tzKHRhc2suYXBwLmNyZWF0b3IpLmV4aXN0cwoJYnl0ZSAweDc1IC8vICJ1IgoJZnJhbWVfZGlnIC0yIC8vIHRhc2s6IFRhc2sKCWV4dHJhY3QgOCA4CglidG9pCglhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCglwb3AKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCglieiAqaWYxX2Vsc2UKCgkvLyAqaWYxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjEwNAoJLy8gdGhpcy51c2VyMnRhc2tzKHRhc2suYXBwLmNyZWF0b3IpLnZhbHVlLnB1c2godGFzay5hcHApCglieXRlIDB4NzUgLy8gInUiCglmcmFtZV9kaWcgLTIgLy8gdGFzazogVGFzawoJZXh0cmFjdCA4IDgKCWJ0b2kKCWFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKCXBvcAoJY29uY2F0CglpbnQgMgoJaW50IDAKCWJveF9leHRyYWN0CglmcmFtZV9kaWcgLTIgLy8gdGFzazogVGFzawoJZXh0cmFjdCA4IDgKCWJ0b2kKCWl0b2IKCWNvbmNhdAoJYnl0ZSAweDc1IC8vICJ1IgoJZnJhbWVfZGlnIC0yIC8vIHRhc2s6IFRhc2sKCWV4dHJhY3QgOCA4CglidG9pCglhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCglwb3AKCWNvbmNhdAoJZHVwCglib3hfZGVsCglwb3AKCXN3YXAKCWR1cAoJbGVuCglpbnQgOAoJLwoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJYm94X3B1dAoJYiAqaWYxX2VuZAoKKmlmMV9lbHNlOgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTA2CgkvLyBuZXdXaGl0ZWxpc3Q6IEFwcElEW10gPSBbdGFzay5hcHBdCglmcmFtZV9kaWcgLTIgLy8gdGFzazogVGFzawoJZXh0cmFjdCA4IDgKCWJ0b2kKCWl0b2IKCWZyYW1lX2J1cnkgMCAvLyBuZXdXaGl0ZWxpc3Q6IEFwcElEW10KCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxMDcKCS8vIHRoaXMudXNlcjJ0YXNrcyh0YXNrLmFwcC5jcmVhdG9yKS52YWx1ZSA9IG5ld1doaXRlbGlzdAoJYnl0ZSAweDc1IC8vICJ1IgoJZnJhbWVfZGlnIC0yIC8vIHRhc2s6IFRhc2sKCWV4dHJhY3QgOCA4CglidG9pCglhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCglwb3AKCWNvbmNhdAoJZHVwCglib3hfZGVsCglwb3AKCWZyYW1lX2RpZyAwIC8vIG5ld1doaXRlbGlzdDogQXBwSURbXQoJZHVwCglsZW4KCWludCA4CgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cglib3hfcHV0CgoqaWYxX2VuZDoKCXJldHN1YgoKLy8gdW5yZWdpc3RlclRhc2sodWludDY0LHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfdW5yZWdpc3RlclRhc2s6CgkvLyBpbmRleFRvRGVsZXRlOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBhcHA6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgdW5yZWdpc3RlclRhc2sodWludDY0LHVpbnQ2NCl2b2lkCgljYWxsc3ViIHVucmVnaXN0ZXJUYXNrCglpbnQgMQoJcmV0dXJuCgovLyB1bnJlZ2lzdGVyVGFzayhhcHA6IEFwcElELCBpbmRleFRvRGVsZXRlOiB1aW50NjQpOiB2b2lkCi8vCi8vIFVucmVnaXN0ZXIgYSB0YXNrIHdoZW4gdGFzayBpcyBkZWxldGVkCi8vCi8vIEBwYXJhbSBhcHAgQXBwIHRvIHVucmVnaXN0ZXIKLy8gQHBhcmFtIGluZGV4VG9EZWxldGUgQXBwIGluZGV4IHRvIGRlbGV0ZSBmcm9tIHVzZXIncyBhcHBzCnVucmVnaXN0ZXJUYXNrOgoJcHJvdG8gMiAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxMTgKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IGFwcC5hZGRyZXNzKQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0xIC8vIGFwcDogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjExOQoJLy8gdGFzayA9IHRoaXMudGFza3MoYXBwKS52YWx1ZQoJYnl0ZSAweDc0IC8vICJ0IgoJZnJhbWVfZGlnIC0xIC8vIGFwcDogQXBwSUQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfYnVyeSAwIC8vIHN0b3JhZ2Uga2V5Ly90YXNrCgoJLy8gKmlmMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjEyMAoJLy8gdGFzay5mdW5kcyA+IDAKCWludCAwCglpbnQgOAoJYnl0ZSAweDc0IC8vICJ0IgoJZnJhbWVfZGlnIC0xIC8vIGFwcDogQXBwSUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWludCAwCgk+CglieiAqaWYyX2VuZAoKCS8vICppZjJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTIxCgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICAgIGFzc2V0QW1vdW50OiB0YXNrLmZ1bmRzLAoJLy8gICAgICAgICBhc3NldFJlY2VpdmVyOiBhcHAuY3JlYXRvciwKCS8vICAgICAgICAgeGZlckFzc2V0OiBBc3NldElELmZyb21VaW50NjQodGhpcy5mZWVBc3NldElkLnZhbHVlKSwKCS8vICAgICAgICAgZmVlOiAwLAoJLy8gICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjEyMgoJLy8gYXNzZXRBbW91bnQ6IHRhc2suZnVuZHMKCWludCAwCglpbnQgOAoJYnl0ZSAweDc0IC8vICJ0IgoJZnJhbWVfZGlnIC0xIC8vIGFwcDogQXBwSUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxMjMKCS8vIGFzc2V0UmVjZWl2ZXI6IGFwcC5jcmVhdG9yCglmcmFtZV9kaWcgLTEgLy8gYXBwOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgoJcG9wCglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxMjQKCS8vIHhmZXJBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KHRoaXMuZmVlQXNzZXRJZC52YWx1ZSkKCWJ5dGUgMHg2NjYxIC8vICJmYSIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjEyNQoJLy8gZmVlOiAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoqaWYyX2VuZDoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjEyOAoJLy8gdGFzay5mdW5kcyA9IDAKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly90YXNrCglpbnQgMAoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTI5CgkvLyB0aGlzLnRhc2tzKGFwcCkuZGVsZXRlKCkKCWJ5dGUgMHg3NCAvLyAidCIKCWZyYW1lX2RpZyAtMSAvLyBhcHA6IEFwcElECglpdG9iCgljb25jYXQKCWJveF9kZWwKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxMzQKCS8vIHRoaXMudXNlcjJ0YXNrcyhhcHAuY3JlYXRvcikudmFsdWUuc3BsaWNlKGluZGV4VG9EZWxldGUsIDEpCglieXRlIDB4NzUgLy8gInUiCglmcmFtZV9kaWcgLTEgLy8gYXBwOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgoJcG9wCgljb25jYXQKCWludCAyCglpbnQgMAoJYm94X2V4dHJhY3QKCWludCAxCglmcmFtZV9kaWcgLTIgLy8gaW5kZXhUb0RlbGV0ZTogdWludDY0CglpbnQgOAoJKgoJc3RvcmUgMjQ3IC8vIHNwbGljZSBzdGFydAoJaW50IDE2CglzdG9yZSAyNDYgLy8gc3BsaWNlIGJ5dGUgbGVuZ3RoCglieXRlIDB4NzUgLy8gInUiCglmcmFtZV9kaWcgLTEgLy8gYXBwOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgoJcG9wCgljb25jYXQKCWludCAyCglpbnQgMAoJYm94X2V4dHJhY3QKCWludCAwCglsb2FkIDI0NyAvLyBzcGxpY2Ugc3RhcnQKCXN1YnN0cmluZzMKCWJ5dGUgMHg3NSAvLyAidSIKCWZyYW1lX2RpZyAtMSAvLyBhcHA6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCglwb3AKCWNvbmNhdAoJaW50IDIKCWludCAwCglib3hfZXh0cmFjdAoJZHVwCglsZW4KCWxvYWQgMjQ3IC8vIHNwbGljZSBzdGFydAoJbG9hZCAyNDYgLy8gc3BsaWNlIGJ5dGUgbGVuZ3RoCgkrCglpbnQgOAoJLQoJc3dhcAoJc3Vic3RyaW5nMwoJY29uY2F0CglieXRlIDB4NzUgLy8gInUiCglmcmFtZV9kaWcgLTEgLy8gYXBwOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgoJcG9wCgljb25jYXQKCWR1cAoJYm94X2RlbAoJcG9wCglzd2FwCglkdXAKCWxlbgoJaW50IDgKCS8KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWJveF9wdXQKCXJldHN1YgoKLy8gZXhlY3V0ZVRhc2soYXBwbCl2b2lkCiphYmlfcm91dGVfZXhlY3V0ZVRhc2s6CgkvLyB0YXNrQXBwQ2FsbDogYXBwbAoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgYXBwbAoJPT0KCWFzc2VydAoKCS8vIGV4ZWN1dGUgZXhlY3V0ZVRhc2soYXBwbCl2b2lkCgljYWxsc3ViIGV4ZWN1dGVUYXNrCglpbnQgMQoJcmV0dXJuCgovLyBleGVjdXRlVGFzayh0YXNrQXBwQ2FsbDogQXBwQ2FsbFR4bik6IHZvaWQKLy8KLy8gRXhlY3V0ZSBhIHRhc2sgYW5kIGdldCB0aGUgcmV3YXJkCi8vCi8vIEBwYXJhbSB0YXNrQXBwQ2FsbCBUaGUgY2FsbCB0byB0aGUgdGFzayBhcHAKZXhlY3V0ZVRhc2s6Cglwcm90byAxIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjE0NAoJLy8gdGFzayA9IHRoaXMudGFza3ModGFza0FwcENhbGwuYXBwbGljYXRpb25JRCkudmFsdWUKCWJ5dGUgMHg3NCAvLyAidCIKCWZyYW1lX2RpZyAtMSAvLyB0YXNrQXBwQ2FsbDogQXBwQ2FsbFR4bgoJZ3R4bnMgQXBwbGljYXRpb25JRAoJaXRvYgoJY29uY2F0CglmcmFtZV9idXJ5IDAgLy8gc3RvcmFnZSBrZXkvL3Rhc2sKCgkvLyAqaWYzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTQ3CgkvLyB0aGlzLmZlZUFzc2V0SWQudmFsdWUgPT09IDAKCWJ5dGUgMHg2NjYxIC8vICJmYSIKCWFwcF9nbG9iYWxfZ2V0CglpbnQgMAoJPT0KCWJ6ICppZjNfZWxzZQoKCS8vICppZjNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTQ4CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgIHJlY2VpdmVyOiB0aGlzLnR4bi5zZW5kZXIsCgkvLyAgICAgICAgIGFtb3VudDogdGFzay5mZWUsCgkvLyAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjE0OQoJLy8gcmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlcgoJdHhuIFNlbmRlcgoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjE1MAoJLy8gYW1vdW50OiB0YXNrLmZlZQoJaW50IDE2IC8vIGhlYWRPZmZzZXQKCWludCA4CglieXRlIDB4NzQgLy8gInQiCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTQ0CgkvLyB0YXNrQXBwQ2FsbC5hcHBsaWNhdGlvbklECglmcmFtZV9kaWcgLTEgLy8gdGFza0FwcENhbGw6IEFwcENhbGxUeG4KCWd0eG5zIEFwcGxpY2F0aW9uSUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJYiAqaWYzX2VuZAoKKmlmM19lbHNlOgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTUzCgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlciwKCS8vICAgICAgICAgYXNzZXRBbW91bnQ6IHRhc2suZmVlLAoJLy8gICAgICAgICB4ZmVyQXNzZXQ6IEFzc2V0SUQuZnJvbVVpbnQ2NCh0aGlzLmZlZUFzc2V0SWQudmFsdWUpLAoJLy8gICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjE1NAoJLy8gYXNzZXRSZWNlaXZlcjogdGhpcy50eG4uc2VuZGVyCgl0eG4gU2VuZGVyCglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxNTUKCS8vIGFzc2V0QW1vdW50OiB0YXNrLmZlZQoJaW50IDE2IC8vIGhlYWRPZmZzZXQKCWludCA4CglieXRlIDB4NzQgLy8gInQiCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTQ0CgkvLyB0YXNrQXBwQ2FsbC5hcHBsaWNhdGlvbklECglmcmFtZV9kaWcgLTEgLy8gdGFza0FwcENhbGw6IEFwcENhbGxUeG4KCWd0eG5zIEFwcGxpY2F0aW9uSUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxNTYKCS8vIHhmZXJBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KHRoaXMuZmVlQXNzZXRJZC52YWx1ZSkKCWJ5dGUgMHg2NjYxIC8vICJmYSIKCWFwcF9nbG9iYWxfZ2V0CglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCippZjNfZW5kOgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTYyCgkvLyB0YXNrLmZ1bmRzIC09IHRhc2suZmVlCglpbnQgMAoJZHVwCglpbnQgOAoJYnl0ZSAweDc0IC8vICJ0IgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjE0NAoJLy8gdGFza0FwcENhbGwuYXBwbGljYXRpb25JRAoJZnJhbWVfZGlnIC0xIC8vIHRhc2tBcHBDYWxsOiBBcHBDYWxsVHhuCglndHhucyBBcHBsaWNhdGlvbklECglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTYyCgkvLyB0YXNrLmZlZQoJaW50IDE2IC8vIGhlYWRPZmZzZXQKCWludCA4CglieXRlIDB4NzQgLy8gInQiCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTQ0CgkvLyB0YXNrQXBwQ2FsbC5hcHBsaWNhdGlvbklECglmcmFtZV9kaWcgLTEgLy8gdGFza0FwcENhbGw6IEFwcENhbGxUeG4KCWd0eG5zIEFwcGxpY2F0aW9uSUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCS0KCWl0b2IKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly90YXNrCgljb3ZlciAyCglib3hfcmVwbGFjZQoJcmV0c3ViCgovLyBmdW5kVGFzayh1aW50NjQsdHhuKXZvaWQKKmFiaV9yb3V0ZV9mdW5kVGFzazoKCS8vIGRlcG9zaXQ6IHR4bgoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCgoJLy8gdGFza0FwcElkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGZ1bmRUYXNrKHVpbnQ2NCx0eG4pdm9pZAoJY2FsbHN1YiBmdW5kVGFzawoJaW50IDEKCXJldHVybgoKLy8gZnVuZFRhc2sodGFza0FwcElkOiBBcHBJRCwgZGVwb3NpdDogVHhuKTogdm9pZAovLwovLyBEZXBvc2l0IGZ1bmRzIGZvciBhIHRhc2sKLy8KLy8gQHBhcmFtIHRhc2tBcHBJZCBUaGUgSUQgb2YgdGhlIHRhc2sgdG8gZnVuZAovLyBAcGFyYW0gZGVwb3NpdCBUaGUgcGF5IG9yIGF4ZmVyIHRvIGZ1bmQgdGhlIHRhc2sKZnVuZFRhc2s6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAyCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTcyCgkvLyB0YXNrID0gdGhpcy50YXNrcyh0YXNrQXBwSWQpLnZhbHVlCglieXRlIDB4NzQgLy8gInQiCglmcmFtZV9kaWcgLTEgLy8gdGFza0FwcElkOiBBcHBJRAoJaXRvYgoJY29uY2F0CglmcmFtZV9idXJ5IDAgLy8gc3RvcmFnZSBrZXkvL3Rhc2sKCgkvLyAqaWY0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTc0CgkvLyB0aGlzLmZlZUFzc2V0SWQudmFsdWUgPT09IDAKCWJ5dGUgMHg2NjYxIC8vICJmYSIKCWFwcF9nbG9iYWxfZ2V0CglpbnQgMAoJPT0KCWJ6ICppZjRfZWxzZQoKCS8vICppZjRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTc1CgkvLyB2ZXJpZnlQYXlUeG4oZGVwb3NpdCwgewoJLy8gICAgICAgICByZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgIH0pCgkvLyB2ZXJpZnkgcGF5CglmcmFtZV9kaWcgLTIgLy8gZGVwb3NpdDogVHhuCglndHhucyBUeXBlRW51bQoJaW50IHBheQoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIC0yIC8vIGRlcG9zaXQ6IFR4bgoJZ3R4bnMgUmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTc4CgkvLyBmZWUgPSBkZXBvc2l0LmFtb3VudCAvIDEwMAoJZnJhbWVfZGlnIC0yIC8vIGRlcG9zaXQ6IFR4bgoJZ3R4bnMgQW1vdW50CglpbnQgMTAwCgkvCglmcmFtZV9idXJ5IDEgLy8gZmVlOiB1aW50NjQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxNzkKCS8vIHRhc2suZnVuZHMgKz0gZGVwb3NpdC5hbW91bnQgLSBmZWUKCWludCAwCglkdXAKCWludCA4CglieXRlIDB4NzQgLy8gInQiCglmcmFtZV9kaWcgLTEgLy8gdGFza0FwcElkOiBBcHBJRAoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC0yIC8vIGRlcG9zaXQ6IFR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9kaWcgMSAvLyBmZWU6IHVpbnQ2NAoJLQoJKwoJaXRvYgoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3Rhc2sKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTgwCgkvLyB0aGlzLmRlcG9zaXRlZEZ1bmRzLnZhbHVlICs9IGRlcG9zaXQuYW1vdW50IC0gZmVlCglieXRlIDB4NjQgLy8gImQiCglhcHBfZ2xvYmFsX2dldAoJZnJhbWVfZGlnIC0yIC8vIGRlcG9zaXQ6IFR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9kaWcgMSAvLyBmZWU6IHVpbnQ2NAoJLQoJKwoJYnl0ZSAweDY0IC8vICJkIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCWIgKmlmNF9lbmQKCippZjRfZWxzZToKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjE4MgoJLy8gdmVyaWZ5QXNzZXRUcmFuc2ZlclR4bihkZXBvc2l0LCB7CgkvLyAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICAgIHhmZXJBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KHRoaXMuZmVlQXNzZXRJZC52YWx1ZSksCgkvLyAgICAgICB9KQoJLy8gdmVyaWZ5IGF4ZmVyCglmcmFtZV9kaWcgLTIgLy8gZGVwb3NpdDogVHhuCglndHhucyBUeXBlRW51bQoJaW50IGF4ZmVyCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IGFzc2V0UmVjZWl2ZXIKCWZyYW1lX2RpZyAtMiAvLyBkZXBvc2l0OiBUeG4KCWd0eG5zIEFzc2V0UmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gdmVyaWZ5IHhmZXJBc3NldAoJZnJhbWVfZGlnIC0yIC8vIGRlcG9zaXQ6IFR4bgoJZ3R4bnMgWGZlckFzc2V0CglieXRlIDB4NjY2MSAvLyAiZmEiCglhcHBfZ2xvYmFsX2dldAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjE4NgoJLy8gZmVlID0gZGVwb3NpdC5hbW91bnQgLyAxMDAKCWZyYW1lX2RpZyAtMiAvLyBkZXBvc2l0OiBUeG4KCWd0eG5zIEFtb3VudAoJaW50IDEwMAoJLwoJZnJhbWVfYnVyeSAyIC8vIGZlZTogdWludDY0CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTg3CgkvLyB0YXNrLmZ1bmRzICs9IGRlcG9zaXQuYXNzZXRBbW91bnQgLSBmZWUKCWludCAwCglkdXAKCWludCA4CglieXRlIDB4NzQgLy8gInQiCglmcmFtZV9kaWcgLTEgLy8gdGFza0FwcElkOiBBcHBJRAoJaXRvYgoJY29uY2F0Cgljb3ZlciAyCglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC0yIC8vIGRlcG9zaXQ6IFR4bgoJZ3R4bnMgQXNzZXRBbW91bnQKCWZyYW1lX2RpZyAyIC8vIGZlZTogdWludDY0CgktCgkrCglpdG9iCglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vdGFzawoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoxODgKCS8vIHRoaXMuZGVwb3NpdGVkRnVuZHMudmFsdWUgKz0gZGVwb3NpdC5hc3NldEFtb3VudCAtIGZlZQoJYnl0ZSAweDY0IC8vICJkIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMiAvLyBkZXBvc2l0OiBUeG4KCWd0eG5zIEFzc2V0QW1vdW50CglmcmFtZV9kaWcgMiAvLyBmZWU6IHVpbnQ2NAoJLQoJKwoJYnl0ZSAweDY0IC8vICJkIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCippZjRfZW5kOgoJcmV0c3ViCgovLyBjaGFuZ2VUYXNrRmVlKHVpbnQ2NCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX2NoYW5nZVRhc2tGZWU6CgkvLyBmZWU6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIHRhc2tBcHBJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBjaGFuZ2VUYXNrRmVlKHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiBjaGFuZ2VUYXNrRmVlCglpbnQgMQoJcmV0dXJuCgovLyBjaGFuZ2VUYXNrRmVlKHRhc2tBcHBJZDogQXBwSUQsIGZlZTogdWludDY0KTogdm9pZAovLwovLyBDcmVhdG9yIG9mIHRoZSB0YXNrIGlzIGFsbG93ZWQgdG8gY2hhbmdlIHRoZSBmZWUKLy8KLy8gQHBhcmFtIHRhc2tBcHBJZCBUaGUgSUQgb2YgdGhlIHRhc2sgdG8gZnVuZAovLyBAcGFyYW0gZmVlIEZlZSBpbiBiYXNlIHVuaXRzIG9mIHRoZSBmZWUgdG9rZW4KY2hhbmdlVGFza0ZlZToKCXByb3RvIDIgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MTk5CgkvLyB0YXNrID0gdGhpcy50YXNrcyh0YXNrQXBwSWQpLnZhbHVlCglieXRlIDB4NzQgLy8gInQiCglmcmFtZV9kaWcgLTEgLy8gdGFza0FwcElkOiBBcHBJRAoJaXRvYgoJY29uY2F0CglmcmFtZV9idXJ5IDAgLy8gc3RvcmFnZSBrZXkvL3Rhc2sKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyMDAKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IHRhc2suYXBwLmNyZWF0b3IpCgl0eG4gU2VuZGVyCglpbnQgOCAvLyBoZWFkT2Zmc2V0CglpbnQgOAoJYnl0ZSAweDc0IC8vICJ0IgoJZnJhbWVfZGlnIC0xIC8vIHRhc2tBcHBJZDogQXBwSUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKCXBvcAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjIwMQoJLy8gdGFzay5mZWUgPSBmZWUKCWludCAxNiAvLyBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTIgLy8gZmVlOiB1aW50NjQKCWl0b2IKCWZyYW1lX2RpZyAwIC8vIHN0b3JhZ2Uga2V5Ly90YXNrCgljb3ZlciAyCglib3hfcmVwbGFjZQoJcmV0c3ViCgovLyB1bmZ1bmRUYXNrKHVpbnQ2NCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3VuZnVuZFRhc2s6CgkvLyBhbW91bnQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIHRhc2tBcHBJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSB1bmZ1bmRUYXNrKHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiB1bmZ1bmRUYXNrCglpbnQgMQoJcmV0dXJuCgovLyB1bmZ1bmRUYXNrKHRhc2tBcHBJZDogQXBwSUQsIGFtb3VudDogdWludDY0KTogdm9pZAovLwovLyBSZW1vdmUgZnVuZHMgZm9yIGEgdGFzawovLyBDcmVhdG9yIG9mIHRoZSB1bmRlcmx5aW5nIHRhc2sgY2FuIHJlbW92ZSB0aGUgZnVuZHMgZnJvbSB0aGUgcG9vbAovLwovLyBAcGFyYW0gdGFza0FwcElkIFRoZSBJRCBvZiB0aGUgdGFzayB0byBmdW5kCi8vIEBwYXJhbSBhbW91bnQgVGhlIGFtb3VudCB0byB3aXRoZHJhdyBmcm9tIHRoZSBwb29sCnVuZnVuZFRhc2s6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjIxMgoJLy8gdGFzayA9IHRoaXMudGFza3ModGFza0FwcElkKS52YWx1ZQoJYnl0ZSAweDc0IC8vICJ0IgoJZnJhbWVfZGlnIC0xIC8vIHRhc2tBcHBJZDogQXBwSUQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfYnVyeSAwIC8vIHN0b3JhZ2Uga2V5Ly90YXNrCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjEzCgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSB0YXNrLmFwcC5jcmVhdG9yKQoJdHhuIFNlbmRlcgoJaW50IDggLy8gaGVhZE9mZnNldAoJaW50IDgKCWJ5dGUgMHg3NCAvLyAidCIKCWZyYW1lX2RpZyAtMSAvLyB0YXNrQXBwSWQ6IEFwcElECglpdG9iCgljb25jYXQKCWNvdmVyIDIKCWJveF9leHRyYWN0CglidG9pCglhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCglwb3AKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyMTQKCS8vIHRhc2suZnVuZHMgLT0gYW1vdW50CglpbnQgMAoJZHVwCglpbnQgOAoJYnl0ZSAweDc0IC8vICJ0IgoJZnJhbWVfZGlnIC0xIC8vIHRhc2tBcHBJZDogQXBwSUQKCWl0b2IKCWNvbmNhdAoJY292ZXIgMgoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnQ6IHVpbnQ2NAoJLQoJaXRvYgoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL3Rhc2sKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjE1CgkvLyB0aGlzLmRlcG9zaXRlZEZ1bmRzLnZhbHVlIC09IGFtb3VudAoJYnl0ZSAweDY0IC8vICJkIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnQ6IHVpbnQ2NAoJLQoJYnl0ZSAweDY0IC8vICJkIgoJc3dhcAoJYXBwX2dsb2JhbF9wdXQKCgkvLyAqaWY1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjE2CgkvLyB0aGlzLmZlZUFzc2V0SWQudmFsdWUgPT09IDAKCWJ5dGUgMHg2NjYxIC8vICJmYSIKCWFwcF9nbG9iYWxfZ2V0CglpbnQgMAoJPT0KCWJ6ICppZjVfZWxzZQoKCS8vICppZjVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjE3CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgIGFtb3VudDogYW1vdW50LAoJLy8gICAgICAgICByZWNlaXZlcjogdGhpcy50eG4uc2VuZGVyLAoJLy8gICAgICAgICBmZWU6IDAsCgkvLyAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjIxOAoJLy8gYW1vdW50OiBhbW91bnQKCWZyYW1lX2RpZyAtMiAvLyBhbW91bnQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyMTkKCS8vIHJlY2VpdmVyOiB0aGlzLnR4bi5zZW5kZXIKCXR4biBTZW5kZXIKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyMjAKCS8vIGZlZTogMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJYiAqaWY1X2VuZAoKKmlmNV9lbHNlOgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjIzCgkvLyBzZW5kQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCgkvLyAgICAgICAgIHhmZXJBc3NldDogQXNzZXRJRC5mcm9tVWludDY0KHRoaXMuZmVlQXNzZXRJZC52YWx1ZSksCgkvLyAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlciwKCS8vICAgICAgICAgZmVlOiAwLAoJLy8gICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjIyNAoJLy8gYXNzZXRBbW91bnQ6IGFtb3VudAoJZnJhbWVfZGlnIC0yIC8vIGFtb3VudDogdWludDY0CglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjI1CgkvLyB4ZmVyQXNzZXQ6IEFzc2V0SUQuZnJvbVVpbnQ2NCh0aGlzLmZlZUFzc2V0SWQudmFsdWUpCglieXRlIDB4NjY2MSAvLyAiZmEiCglhcHBfZ2xvYmFsX2dldAoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyMjYKCS8vIGFzc2V0UmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlcgoJdHhuIFNlbmRlcgoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjI3CgkvLyBmZWU6IDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCippZjVfZW5kOgoJcmV0c3ViCgovLyBwYXltZW50KGFkZHJlc3MsdWludDY0LGFkZHJlc3Msc3RyaW5nKXZvaWQKKmFiaV9yb3V0ZV9wYXltZW50OgoJLy8gbm90ZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglleHRyYWN0IDIgMAoKCS8vIHJlY2VpdmVyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gYW1vdW50OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBzZW5kZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBleGVjdXRlIHBheW1lbnQoYWRkcmVzcyx1aW50NjQsYWRkcmVzcyxzdHJpbmcpdm9pZAoJY2FsbHN1YiBwYXltZW50CglpbnQgMQoJcmV0dXJuCgovLyBwYXltZW50KHNlbmRlcjogQWRkcmVzcywgYW1vdW50OiB1aW50NjQsIHJlY2VpdmVyOiBBZGRyZXNzLCBub3RlOiBzdHJpbmcpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIHNlbmQgcGF5L2F4ZmVyIHRyYW5zYWN0aW9uIG91dCBvZiB0aGUgc21hcnQgY29udHJhY3QKLy8KLy8gQHBhcmFtIHNlbmRlciBTZW5kZXIuIFRoaXMgYXBwIGlkIG9yIGFueSByZWtleWVkIGFjY291bnQgdG8gdGhlIGFkZHJlc3Mgb2YgdGhpcyBzYwovLyBAcGFyYW0gYW1vdW50IEFtb3VudAovLyBAcGFyYW0gbm90ZSBOb3RlCi8vIEBwYXJhbSByZWNlaXZlciBSZWNlaXZlcgpwYXltZW50OgoJcHJvdG8gNCAwCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjQxCgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBnbG9iYWxzLmNyZWF0b3JBZGRyZXNzKQoJdHhuIFNlbmRlcgoJZ2xvYmFsIENyZWF0b3JBZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gKmlmNl9jb25kaXRpb24KCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI0MgoJLy8gdGhpcy5mZWVBc3NldElkLnZhbHVlID09PSAwCglieXRlIDB4NjY2MSAvLyAiZmEiCglhcHBfZ2xvYmFsX2dldAoJaW50IDAKCT09CglieiAqaWY2X2VuZAoKCS8vICppZjZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjQ0CgkvLyBhc3NlcnQoZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLmJhbGFuY2UgLSBhbW91bnQgPj0gdGhpcy5kZXBvc2l0ZWRGdW5kcy52YWx1ZSkKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglhY2N0X3BhcmFtc19nZXQgQWNjdEJhbGFuY2UKCXBvcAoJZnJhbWVfZGlnIC0yIC8vIGFtb3VudDogdWludDY0CgktCglieXRlIDB4NjQgLy8gImQiCglhcHBfZ2xvYmFsX2dldAoJPj0KCWFzc2VydAoKKmlmNl9lbmQ6CgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyNDYKCS8vIHNlbmRQYXltZW50KHsKCS8vICAgICAgIGFtb3VudDogYW1vdW50LAoJLy8gICAgICAgcmVjZWl2ZXI6IHJlY2VpdmVyLAoJLy8gICAgICAgbm90ZTogbm90ZSwKCS8vICAgICAgIHNlbmRlcjogc2VuZGVyLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnQgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjQ3CgkvLyBhbW91bnQ6IGFtb3VudAoJZnJhbWVfZGlnIC0yIC8vIGFtb3VudDogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI0OAoJLy8gcmVjZWl2ZXI6IHJlY2VpdmVyCglmcmFtZV9kaWcgLTMgLy8gcmVjZWl2ZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyNDkKCS8vIG5vdGU6IG5vdGUKCWZyYW1lX2RpZyAtNCAvLyBub3RlOiBzdHJpbmcKCWl0eG5fZmllbGQgTm90ZQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI1MAoJLy8gc2VuZGVyOiBzZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgU2VuZGVyCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBhc3NldFRyYW5zZmVyKGFkZHJlc3MsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHN0cmluZyl2b2lkCiphYmlfcm91dGVfYXNzZXRUcmFuc2ZlcjoKCS8vIG5vdGU6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJZXh0cmFjdCAyIDAKCgkvLyBhc3NldFJlY2VpdmVyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gYXNzZXRBbW91bnQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIHhmZXJBc3NldDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gc2VuZGVyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBhc3NldFRyYW5zZmVyKGFkZHJlc3MsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHN0cmluZyl2b2lkCgljYWxsc3ViIGFzc2V0VHJhbnNmZXIKCWludCAxCglyZXR1cm4KCi8vIGFzc2V0VHJhbnNmZXIoc2VuZGVyOiBBZGRyZXNzLCB4ZmVyQXNzZXQ6IEFzc2V0SUQsIGFzc2V0QW1vdW50OiB1aW50NjQsIGFzc2V0UmVjZWl2ZXI6IEFkZHJlc3MsIG5vdGU6IHN0cmluZyk6IHZvaWQKLy8KLy8gQ3JlYXRvciBjYW4gc2VuZCBwYXkvYXhmZXIgdHJhbnNhY3Rpb24gb3V0IG9mIHRoZSBzbWFydCBjb250cmFjdAovLyBAcGFyYW0gc2VuZGVyIFNlbmRlci4gVGhpcyBhcHAgaWQgb3IgYW55IHJla2V5ZWQgYWNjb3VudCB0byB0aGUgYWRkcmVzcyBvZiB0aGlzIHNjCmFzc2V0VHJhbnNmZXI6Cglwcm90byA1IDAKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyNTkKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IGdsb2JhbHMuY3JlYXRvckFkZHJlc3MpCgl0eG4gU2VuZGVyCglnbG9iYWwgQ3JlYXRvckFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyAqaWY3X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjYwCgkvLyB0aGlzLmZlZUFzc2V0SWQudmFsdWUgPT09IHhmZXJBc3NldC5pZAoJYnl0ZSAweDY2NjEgLy8gImZhIgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2RpZyAtMiAvLyB4ZmVyQXNzZXQ6IEFzc2V0SUQKCT09CglieiAqaWY3X2VuZAoKCS8vICppZjdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjYyCgkvLyBhc3NlcnQoZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLmFzc2V0QmFsYW5jZSh4ZmVyQXNzZXQpIC0gYXNzZXRBbW91bnQgPj0gdGhpcy5kZXBvc2l0ZWRGdW5kcy52YWx1ZSkKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglmcmFtZV9kaWcgLTIgLy8geGZlckFzc2V0OiBBc3NldElECglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXBvcAoJZnJhbWVfZGlnIC0zIC8vIGFzc2V0QW1vdW50OiB1aW50NjQKCS0KCWJ5dGUgMHg2NCAvLyAiZCIKCWFwcF9nbG9iYWxfZ2V0Cgk+PQoJYXNzZXJ0CgoqaWY3X2VuZDoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI2NAoJLy8gc2VuZEFzc2V0VHJhbnNmZXIoewoJLy8gICAgICAgYXNzZXRBbW91bnQ6IGFzc2V0QW1vdW50LAoJLy8gICAgICAgYXNzZXRSZWNlaXZlcjogYXNzZXRSZWNlaXZlciwKCS8vICAgICAgIHhmZXJBc3NldDogeGZlckFzc2V0LAoJLy8gICAgICAgbm90ZTogbm90ZSwKCS8vICAgICAgIGFzc2V0U2VuZGVyOiBzZW5kZXIsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI2NQoJLy8gYXNzZXRBbW91bnQ6IGFzc2V0QW1vdW50CglmcmFtZV9kaWcgLTMgLy8gYXNzZXRBbW91bnQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI2NgoJLy8gYXNzZXRSZWNlaXZlcjogYXNzZXRSZWNlaXZlcgoJZnJhbWVfZGlnIC00IC8vIGFzc2V0UmVjZWl2ZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI2NwoJLy8geGZlckFzc2V0OiB4ZmVyQXNzZXQKCWZyYW1lX2RpZyAtMiAvLyB4ZmVyQXNzZXQ6IEFzc2V0SUQKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6MjY4CgkvLyBub3RlOiBub3RlCglmcmFtZV9kaWcgLTUgLy8gbm90ZTogc3RyaW5nCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyNjkKCS8vIGFzc2V0U2VuZGVyOiBzZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRTZW5kZXIKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglyZXRzdWIKCi8vIHNlbmRPbmxpbmVLZXlSZWdpc3RyYXRpb24oYnl0ZVtdLGJ5dGVbXSxieXRlW10sdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3NlbmRPbmxpbmVLZXlSZWdpc3RyYXRpb246CgkvLyB2b3RlS2V5RGlsdXRpb246IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgoJYnRvaQoKCS8vIHZvdGVMYXN0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWJ0b2kKCgkvLyB2b3RlRmlyc3Q6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJYnRvaQoKCS8vIHN0YXRlUHJvb2ZQazogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglleHRyYWN0IDIgMAoKCS8vIHNlbGVjdGlvblBrOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWV4dHJhY3QgMiAwCgoJLy8gdm90ZVBrOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBzZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uKGJ5dGVbXSxieXRlW10sYnl0ZVtdLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKCWNhbGxzdWIgc2VuZE9ubGluZUtleVJlZ2lzdHJhdGlvbgoJaW50IDEKCXJldHVybgoKLy8gc2VuZE9ubGluZUtleVJlZ2lzdHJhdGlvbih2b3RlUGs6IGJ5dGVzLCBzZWxlY3Rpb25QazogYnl0ZXMsIHN0YXRlUHJvb2ZQazogYnl0ZXMsIHZvdGVGaXJzdDogdWludDY0LCB2b3RlTGFzdDogdWludDY0LCB2b3RlS2V5RGlsdXRpb246IHVpbnQ2NCk6IHZvaWQKLy8KLy8gQ3JlYXRvciBjYW4gcGVyZm9tIGtleSByZWdpc3RyYXRpb24gZm9yIHRoaXMgTFAgcG9vbApzZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uOgoJcHJvdG8gNiAwCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6Mjg0CgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBnbG9iYWxzLmNyZWF0b3JBZGRyZXNzKQoJdHhuIFNlbmRlcgoJZ2xvYmFsIENyZWF0b3JBZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6Mjg1CgkvLyBzZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uKHsKCS8vICAgICAgIHNlbGVjdGlvblBLOiBzZWxlY3Rpb25QaywKCS8vICAgICAgIHN0YXRlUHJvb2ZQSzogc3RhdGVQcm9vZlBrLAoJLy8gICAgICAgdm90ZUZpcnN0OiB2b3RlRmlyc3QsCgkvLyAgICAgICB2b3RlS2V5RGlsdXRpb246IHZvdGVLZXlEaWx1dGlvbiwKCS8vICAgICAgIHZvdGVMYXN0OiB2b3RlTGFzdCwKCS8vICAgICAgIHZvdGVQSzogdm90ZVBrLAoJLy8gICAgICAgZmVlOiAwLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnQga2V5cmVnCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6Mjg2CgkvLyBzZWxlY3Rpb25QSzogc2VsZWN0aW9uUGsKCWZyYW1lX2RpZyAtMiAvLyBzZWxlY3Rpb25QazogYnl0ZXMKCWl0eG5fZmllbGQgU2VsZWN0aW9uUEsKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyODcKCS8vIHN0YXRlUHJvb2ZQSzogc3RhdGVQcm9vZlBrCglmcmFtZV9kaWcgLTMgLy8gc3RhdGVQcm9vZlBrOiBieXRlcwoJaXR4bl9maWVsZCBTdGF0ZVByb29mUEsKCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czoyODgKCS8vIHZvdGVGaXJzdDogdm90ZUZpcnN0CglmcmFtZV9kaWcgLTQgLy8gdm90ZUZpcnN0OiB1aW50NjQKCWl0eG5fZmllbGQgVm90ZUZpcnN0CgoJLy8gY29udHJhY3RzXEJpYXRlY1Rhc2tNYW5hZ2VyLmFsZ28udHM6Mjg5CgkvLyB2b3RlS2V5RGlsdXRpb246IHZvdGVLZXlEaWx1dGlvbgoJZnJhbWVfZGlnIC02IC8vIHZvdGVLZXlEaWx1dGlvbjogdWludDY0CglpdHhuX2ZpZWxkIFZvdGVLZXlEaWx1dGlvbgoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI5MAoJLy8gdm90ZUxhc3Q6IHZvdGVMYXN0CglmcmFtZV9kaWcgLTUgLy8gdm90ZUxhc3Q6IHVpbnQ2NAoJaXR4bl9maWVsZCBWb3RlTGFzdAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI5MQoJLy8gdm90ZVBLOiB2b3RlUGsKCWZyYW1lX2RpZyAtMSAvLyB2b3RlUGs6IGJ5dGVzCglpdHhuX2ZpZWxkIFZvdGVQSwoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjI5MgoJLy8gZmVlOiAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglyZXRzdWIKCi8vIHNlbmRPZmZsaW5lS2V5UmVnaXN0cmF0aW9uKCl2b2lkCiphYmlfcm91dGVfc2VuZE9mZmxpbmVLZXlSZWdpc3RyYXRpb246CgkvLyBleGVjdXRlIHNlbmRPZmZsaW5lS2V5UmVnaXN0cmF0aW9uKCl2b2lkCgljYWxsc3ViIHNlbmRPZmZsaW5lS2V5UmVnaXN0cmF0aW9uCglpbnQgMQoJcmV0dXJuCgovLyBzZW5kT2ZmbGluZUtleVJlZ2lzdHJhdGlvbigpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIHBlcmZvbSBrZXkgdW5yZWdpc3RyYXRpb24gZm9yIHRoaXMgTFAgcG9vbApzZW5kT2ZmbGluZUtleVJlZ2lzdHJhdGlvbjoKCXByb3RvIDAgMAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjMwMAoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1xCaWF0ZWNUYXNrTWFuYWdlci5hbGdvLnRzOjMwMQoJLy8gc2VuZE9mZmxpbmVLZXlSZWdpc3RyYXRpb24oeyBmZWU6IDAgfSkKCWl0eG5fYmVnaW4KCWludCBrZXlyZWcKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHNcQmlhdGVjVGFza01hbmFnZXIuYWxnby50czozMDEKCS8vIGZlZTogMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgoqY3JlYXRlX05vT3A6CgltZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoJZXJyCgoqY2FsbF9Ob09wOgoJbWV0aG9kICJib290c3RyYXAocGF5LHVpbnQ2NCl2b2lkIgoJbWV0aG9kICJyZWdpc3RlclRhc2socGF5LCh1aW50NjQsdWludDY0LHVpbnQ2NCkpdm9pZCIKCW1ldGhvZCAidW5yZWdpc3RlclRhc2sodWludDY0LHVpbnQ2NCl2b2lkIgoJbWV0aG9kICJleGVjdXRlVGFzayhhcHBsKXZvaWQiCgltZXRob2QgImZ1bmRUYXNrKHVpbnQ2NCx0eG4pdm9pZCIKCW1ldGhvZCAiY2hhbmdlVGFza0ZlZSh1aW50NjQsdWludDY0KXZvaWQiCgltZXRob2QgInVuZnVuZFRhc2sodWludDY0LHVpbnQ2NCl2b2lkIgoJbWV0aG9kICJwYXltZW50KGFkZHJlc3MsdWludDY0LGFkZHJlc3Msc3RyaW5nKXZvaWQiCgltZXRob2QgImFzc2V0VHJhbnNmZXIoYWRkcmVzcyx1aW50NjQsdWludDY0LGFkZHJlc3Msc3RyaW5nKXZvaWQiCgltZXRob2QgInNlbmRPbmxpbmVLZXlSZWdpc3RyYXRpb24oYnl0ZVtdLGJ5dGVbXSxieXRlW10sdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCIKCW1ldGhvZCAic2VuZE9mZmxpbmVLZXlSZWdpc3RyYXRpb24oKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2Jvb3RzdHJhcCAqYWJpX3JvdXRlX3JlZ2lzdGVyVGFzayAqYWJpX3JvdXRlX3VucmVnaXN0ZXJUYXNrICphYmlfcm91dGVfZXhlY3V0ZVRhc2sgKmFiaV9yb3V0ZV9mdW5kVGFzayAqYWJpX3JvdXRlX2NoYW5nZVRhc2tGZWUgKmFiaV9yb3V0ZV91bmZ1bmRUYXNrICphYmlfcm91dGVfcGF5bWVudCAqYWJpX3JvdXRlX2Fzc2V0VHJhbnNmZXIgKmFiaV9yb3V0ZV9zZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uICphYmlfcm91dGVfc2VuZE9mZmxpbmVLZXlSZWdpc3RyYXRpb24KCWVycgoKKmNhbGxfVXBkYXRlQXBwbGljYXRpb246CgltZXRob2QgInVwZGF0ZUFwcGxpY2F0aW9uKHN0cmluZyl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV91cGRhdGVBcHBsaWNhdGlvbgoJZXJy\",\n    \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDEw\"\n  },\n  \"contract\": {\n    \"name\": \"BiatecTaskManager\",\n    \"desc\": \"\",\n    \"methods\": [\n      {\n        \"name\": \"createApplication\",\n        \"desc\": \"Initial setup\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"updateApplication\",\n        \"desc\": \"Creator can update application\",\n        \"args\": [\n          {\n            \"name\": \"version\",\n            \"type\": \"string\",\n            \"desc\": \"App version\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"bootstrap\",\n        \"desc\": \"Bootstrap the contract to optin to the fee asset and setup basic variables\",\n        \"args\": [\n          {\n            \"name\": \"txBaseDeposit\",\n            \"type\": \"pay\",\n            \"desc\": \"Deposit MBR\"\n          },\n          {\n            \"name\": \"feeAssetId\",\n            \"type\": \"uint64\",\n            \"desc\": \"Fee asset id\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"registerTask\",\n        \"desc\": \"Register a task to be executedOnly app it self can call register task\",\n        \"args\": [\n          {\n            \"name\": \"registrationFeeDeposit\",\n            \"type\": \"pay\",\n            \"desc\": \"The axfer or pay that deposits the initial funds\"\n          },\n          {\n            \"name\": \"task\",\n            \"type\": \"(uint64,uint64,uint64)\",\n            \"desc\": \"The task object\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"unregisterTask\",\n        \"desc\": \"Unregister a task when task is deleted\",\n        \"args\": [\n          {\n            \"name\": \"app\",\n            \"type\": \"uint64\",\n            \"desc\": \"App to unregister\"\n          },\n          {\n            \"name\": \"indexToDelete\",\n            \"type\": \"uint64\",\n            \"desc\": \"App index to delete from user's apps\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"executeTask\",\n        \"desc\": \"Execute a task and get the reward\",\n        \"args\": [\n          {\n            \"name\": \"taskAppCall\",\n            \"type\": \"appl\",\n            \"desc\": \"The call to the task app\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"fundTask\",\n        \"desc\": \"Deposit funds for a task\",\n        \"args\": [\n          {\n            \"name\": \"taskAppId\",\n            \"type\": \"uint64\",\n            \"desc\": \"The ID of the task to fund\"\n          },\n          {\n            \"name\": \"deposit\",\n            \"type\": \"txn\",\n            \"desc\": \"The pay or axfer to fund the task\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"changeTaskFee\",\n        \"desc\": \"Creator of the task is allowed to change the fee\",\n        \"args\": [\n          {\n            \"name\": \"taskAppId\",\n            \"type\": \"uint64\",\n            \"desc\": \"The ID of the task to fund\"\n          },\n          {\n            \"name\": \"fee\",\n            \"type\": \"uint64\",\n            \"desc\": \"Fee in base units of the fee token\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"unfundTask\",\n        \"desc\": \"Remove funds for a taskCreator of the underlying task can remove the funds from the pool\",\n        \"args\": [\n          {\n            \"name\": \"taskAppId\",\n            \"type\": \"uint64\",\n            \"desc\": \"The ID of the task to fund\"\n          },\n          {\n            \"name\": \"amount\",\n            \"type\": \"uint64\",\n            \"desc\": \"The amount to withdraw from the pool\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"payment\",\n        \"desc\": \"Creator can send pay/axfer transaction out of the smart contract\",\n        \"args\": [\n          {\n            \"name\": \"sender\",\n            \"type\": \"address\",\n            \"desc\": \"Sender. This app id or any rekeyed account to the address of this sc\"\n          },\n          {\n            \"name\": \"amount\",\n            \"type\": \"uint64\",\n            \"desc\": \"Amount\"\n          },\n          {\n            \"name\": \"receiver\",\n            \"type\": \"address\",\n            \"desc\": \"Receiver\"\n          },\n          {\n            \"name\": \"note\",\n            \"type\": \"string\",\n            \"desc\": \"Note\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"assetTransfer\",\n        \"desc\": \"Creator can send pay/axfer transaction out of the smart contract\",\n        \"args\": [\n          {\n            \"name\": \"sender\",\n            \"type\": \"address\",\n            \"desc\": \"Sender. This app id or any rekeyed account to the address of this sc\"\n          },\n          {\n            \"name\": \"xferAsset\",\n            \"type\": \"uint64\"\n          },\n          {\n            \"name\": \"assetAmount\",\n            \"type\": \"uint64\"\n          },\n          {\n            \"name\": \"assetReceiver\",\n            \"type\": \"address\"\n          },\n          {\n            \"name\": \"note\",\n            \"type\": \"string\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"sendOnlineKeyRegistration\",\n        \"desc\": \"Creator can perfom key registration for this LP pool\",\n        \"args\": [\n          {\n            \"name\": \"votePk\",\n            \"type\": \"byte[]\"\n          },\n          {\n            \"name\": \"selectionPk\",\n            \"type\": \"byte[]\"\n          },\n          {\n            \"name\": \"stateProofPk\",\n            \"type\": \"byte[]\"\n          },\n          {\n            \"name\": \"voteFirst\",\n            \"type\": \"uint64\"\n          },\n          {\n            \"name\": \"voteLast\",\n            \"type\": \"uint64\"\n          },\n          {\n            \"name\": \"voteKeyDilution\",\n            \"type\": \"uint64\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"sendOfflineKeyRegistration\",\n        \"desc\": \"Creator can perfom key unregistration for this LP pool\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      }\n    ]\n  }\n};\nvar BiatecTaskManagerCallFactory = class {\n  /**\n   * Gets available create call factories\n   */\n  static get create() {\n    return {\n      /**\n       * Constructs a create call for the BiatecTaskManager smart contract using the createApplication()void ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      createApplication(args, params = {}) {\n        return __spreadValues({\n          method: \"createApplication()void\",\n          methodArgs: Array.isArray(args) ? args : []\n        }, params);\n      }\n    };\n  }\n  /**\n   * Gets available update call factories\n   */\n  static get update() {\n    return {\n      /**\n       * Constructs an update call for the BiatecTaskManager smart contract using the updateApplication(string)void ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      updateApplication(args, params = {}) {\n        return __spreadValues({\n          method: \"updateApplication(string)void\",\n          methodArgs: Array.isArray(args) ? args : [args.version]\n        }, params);\n      }\n    };\n  }\n  /**\n   * Constructs a no op call for the bootstrap(pay,uint64)void ABI method\n   *\n   * Bootstrap the contract to optin to the fee asset and setup basic variables\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static bootstrap(args, params) {\n    return __spreadValues({\n      method: \"bootstrap(pay,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.txBaseDeposit, args.feeAssetId]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the registerTask(pay,(uint64,uint64,uint64))void ABI method\n   *\n   * Register a task to be executedOnly app it self can call register task\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static registerTask(args, params) {\n    return __spreadValues({\n      method: \"registerTask(pay,(uint64,uint64,uint64))void\",\n      methodArgs: Array.isArray(args) ? args : [args.registrationFeeDeposit, args.task]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the unregisterTask(uint64,uint64)void ABI method\n   *\n   * Unregister a task when task is deleted\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static unregisterTask(args, params) {\n    return __spreadValues({\n      method: \"unregisterTask(uint64,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.app, args.indexToDelete]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the executeTask(appl)void ABI method\n   *\n   * Execute a task and get the reward\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static executeTask(args, params) {\n    return __spreadValues({\n      method: \"executeTask(appl)void\",\n      methodArgs: Array.isArray(args) ? args : [args.taskAppCall]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the fundTask(uint64,txn)void ABI method\n   *\n   * Deposit funds for a task\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static fundTask(args, params) {\n    return __spreadValues({\n      method: \"fundTask(uint64,txn)void\",\n      methodArgs: Array.isArray(args) ? args : [args.taskAppId, args.deposit]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the changeTaskFee(uint64,uint64)void ABI method\n   *\n   * Creator of the task is allowed to change the fee\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static changeTaskFee(args, params) {\n    return __spreadValues({\n      method: \"changeTaskFee(uint64,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.taskAppId, args.fee]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the unfundTask(uint64,uint64)void ABI method\n   *\n   * Remove funds for a taskCreator of the underlying task can remove the funds from the pool\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static unfundTask(args, params) {\n    return __spreadValues({\n      method: \"unfundTask(uint64,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.taskAppId, args.amount]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the payment(address,uint64,address,string)void ABI method\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static payment(args, params) {\n    return __spreadValues({\n      method: \"payment(address,uint64,address,string)void\",\n      methodArgs: Array.isArray(args) ? args : [args.sender, args.amount, args.receiver, args.note]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the assetTransfer(address,uint64,uint64,address,string)void ABI method\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static assetTransfer(args, params) {\n    return __spreadValues({\n      method: \"assetTransfer(address,uint64,uint64,address,string)void\",\n      methodArgs: Array.isArray(args) ? args : [args.sender, args.xferAsset, args.assetAmount, args.assetReceiver, args.note]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void ABI method\n   *\n   * Creator can perfom key registration for this LP pool\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static sendOnlineKeyRegistration(args, params) {\n    return __spreadValues({\n      method: \"sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.votePk, args.selectionPk, args.stateProofPk, args.voteFirst, args.voteLast, args.voteKeyDilution]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the sendOfflineKeyRegistration()void ABI method\n   *\n   * Creator can perfom key unregistration for this LP pool\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static sendOfflineKeyRegistration(args, params) {\n    return __spreadValues({\n      method: \"sendOfflineKeyRegistration()void\",\n      methodArgs: Array.isArray(args) ? args : []\n    }, params);\n  }\n};\nvar BiatecTaskManagerClient = class _BiatecTaskManagerClient {\n  /**\n   * Creates a new instance of `BiatecTaskManagerClient`\n   *\n   * @param appDetails appDetails The details to identify the app to deploy\n   * @param algod An algod client instance\n   */\n  constructor(appDetails, algod) {\n    this.algod = algod;\n    this.sender = appDetails.sender;\n    this.appClient = algokit.getAppClient(__spreadProps(__spreadValues({}, appDetails), {\n      app: APP_SPEC\n    }), algod);\n  }\n  /**\n   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type\n   *\n   * @param result The AppCallTransactionResult to be mapped\n   * @param returnValueFormatter An optional delegate to format the return value if required\n   * @returns The smart contract response with an updated return value\n   */\n  mapReturnValue(result, returnValueFormatter) {\n    var _a, _b, _c;\n    if ((_a = result.return) == null ? void 0 : _a.decodeError) {\n      throw result.return.decodeError;\n    }\n    const returnValue = ((_b = result.return) == null ? void 0 : _b.returnValue) !== void 0 && returnValueFormatter !== void 0 ? returnValueFormatter(result.return.returnValue) : (_c = result.return) == null ? void 0 : _c.returnValue;\n    return __spreadProps(__spreadValues({}, result), { return: returnValue });\n  }\n  /**\n   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP\n   *\n   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters\n   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type\n   * @returns The result of the smart contract call\n   */\n  call(typedCallParams, returnValueFormatter) {\n    return __async(this, null, function* () {\n      return this.mapReturnValue(yield this.appClient.call(typedCallParams), returnValueFormatter);\n    });\n  }\n  /**\n   * Idempotently deploys the BiatecTaskManager smart contract.\n   *\n   * @param params The arguments for the contract calls and any additional parameters for the call\n   * @returns The deployment result\n   */\n  deploy(params = {}) {\n    var _a, _b;\n    const createArgs = (_a = params.createCall) == null ? void 0 : _a.call(params, BiatecTaskManagerCallFactory.create);\n    const updateArgs = (_b = params.updateCall) == null ? void 0 : _b.call(params, BiatecTaskManagerCallFactory.update);\n    return this.appClient.deploy(__spreadProps(__spreadValues({}, params), {\n      updateArgs,\n      createArgs,\n      createOnCompleteAction: createArgs == null ? void 0 : createArgs.onCompleteAction\n    }));\n  }\n  /**\n   * Gets available create methods\n   */\n  get create() {\n    const $this = this;\n    return {\n      /**\n       * Creates a new instance of the BiatecTaskManager smart contract using the createApplication()void ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The create result\n       */\n      createApplication(_0) {\n        return __async(this, arguments, function* (args, params = {}) {\n          return $this.mapReturnValue(yield $this.appClient.create(BiatecTaskManagerCallFactory.create.createApplication(args, params)));\n        });\n      }\n    };\n  }\n  /**\n   * Gets available update methods\n   */\n  get update() {\n    const $this = this;\n    return {\n      /**\n       * Updates an existing instance of the BiatecTaskManager smart contract using the updateApplication(string)void ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The update result\n       */\n      updateApplication(_0) {\n        return __async(this, arguments, function* (args, params = {}) {\n          return $this.mapReturnValue(yield $this.appClient.update(BiatecTaskManagerCallFactory.update.updateApplication(args, params)));\n        });\n      }\n    };\n  }\n  /**\n   * Makes a clear_state call to an existing instance of the BiatecTaskManager smart contract.\n   *\n   * @param args The arguments for the bare call\n   * @returns The clear_state result\n   */\n  clearState(args = {}) {\n    return this.appClient.clearState(args);\n  }\n  /**\n   * Calls the bootstrap(pay,uint64)void ABI method.\n   *\n   * Bootstrap the contract to optin to the fee asset and setup basic variables\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  bootstrap(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.bootstrap(args, params));\n  }\n  /**\n   * Calls the registerTask(pay,(uint64,uint64,uint64))void ABI method.\n   *\n   * Register a task to be executedOnly app it self can call register task\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  registerTask(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.registerTask(args, params));\n  }\n  /**\n   * Calls the unregisterTask(uint64,uint64)void ABI method.\n   *\n   * Unregister a task when task is deleted\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  unregisterTask(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.unregisterTask(args, params));\n  }\n  /**\n   * Calls the executeTask(appl)void ABI method.\n   *\n   * Execute a task and get the reward\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  executeTask(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.executeTask(args, params));\n  }\n  /**\n   * Calls the fundTask(uint64,txn)void ABI method.\n   *\n   * Deposit funds for a task\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  fundTask(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.fundTask(args, params));\n  }\n  /**\n   * Calls the changeTaskFee(uint64,uint64)void ABI method.\n   *\n   * Creator of the task is allowed to change the fee\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  changeTaskFee(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.changeTaskFee(args, params));\n  }\n  /**\n   * Calls the unfundTask(uint64,uint64)void ABI method.\n   *\n   * Remove funds for a taskCreator of the underlying task can remove the funds from the pool\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  unfundTask(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.unfundTask(args, params));\n  }\n  /**\n   * Calls the payment(address,uint64,address,string)void ABI method.\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  payment(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.payment(args, params));\n  }\n  /**\n   * Calls the assetTransfer(address,uint64,uint64,address,string)void ABI method.\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  assetTransfer(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.assetTransfer(args, params));\n  }\n  /**\n   * Calls the sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void ABI method.\n   *\n   * Creator can perfom key registration for this LP pool\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  sendOnlineKeyRegistration(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.sendOnlineKeyRegistration(args, params));\n  }\n  /**\n   * Calls the sendOfflineKeyRegistration()void ABI method.\n   *\n   * Creator can perfom key unregistration for this LP pool\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  sendOfflineKeyRegistration(args, params = {}) {\n    return this.call(BiatecTaskManagerCallFactory.sendOfflineKeyRegistration(args, params));\n  }\n  /**\n   * Extracts a binary state value out of an AppState dictionary\n   *\n   * @param state The state dictionary containing the state value\n   * @param key The key of the state value\n   * @returns A BinaryState instance containing the state value, or undefined if the key was not found\n   */\n  static getBinaryState(state, key) {\n    const value = state[key];\n    if (!value)\n      return void 0;\n    if (!(\"valueRaw\" in value))\n      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`);\n    return {\n      asString() {\n        return value.value;\n      },\n      asByteArray() {\n        return value.valueRaw;\n      }\n    };\n  }\n  /**\n   * Extracts a integer state value out of an AppState dictionary\n   *\n   * @param state The state dictionary containing the state value\n   * @param key The key of the state value\n   * @returns An IntegerState instance containing the state value, or undefined if the key was not found\n   */\n  static getIntegerState(state, key) {\n    const value = state[key];\n    if (!value)\n      return void 0;\n    if (\"valueRaw\" in value)\n      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`);\n    return {\n      asBigInt() {\n        return typeof value.value === \"bigint\" ? value.value : BigInt(value.value);\n      },\n      asNumber() {\n        return typeof value.value === \"bigint\" ? Number(value.value) : value.value;\n      }\n    };\n  }\n  /**\n   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value\n   */\n  getGlobalState() {\n    return __async(this, null, function* () {\n      const state = yield this.appClient.getGlobalState();\n      return {\n        get fa() {\n          return _BiatecTaskManagerClient.getIntegerState(state, \"fa\");\n        },\n        get d() {\n          return _BiatecTaskManagerClient.getIntegerState(state, \"d\");\n        },\n        get scver() {\n          return _BiatecTaskManagerClient.getBinaryState(state, \"scver\");\n        }\n      };\n    });\n  }\n  compose() {\n    const client = this;\n    const atc = new AtomicTransactionComposer();\n    let promiseChain = Promise.resolve();\n    const resultMappers = [];\n    return {\n      bootstrap(args, params) {\n        promiseChain = promiseChain.then(() => client.bootstrap(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      registerTask(args, params) {\n        promiseChain = promiseChain.then(() => client.registerTask(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      unregisterTask(args, params) {\n        promiseChain = promiseChain.then(() => client.unregisterTask(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      executeTask(args, params) {\n        promiseChain = promiseChain.then(() => client.executeTask(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      fundTask(args, params) {\n        promiseChain = promiseChain.then(() => client.fundTask(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      changeTaskFee(args, params) {\n        promiseChain = promiseChain.then(() => client.changeTaskFee(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      unfundTask(args, params) {\n        promiseChain = promiseChain.then(() => client.unfundTask(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      payment(args, params) {\n        promiseChain = promiseChain.then(() => client.payment(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      assetTransfer(args, params) {\n        promiseChain = promiseChain.then(() => client.assetTransfer(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      sendOnlineKeyRegistration(args, params) {\n        promiseChain = promiseChain.then(() => client.sendOnlineKeyRegistration(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      sendOfflineKeyRegistration(args, params) {\n        promiseChain = promiseChain.then(() => client.sendOfflineKeyRegistration(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      get update() {\n        const $this = this;\n        return {\n          updateApplication(args, params) {\n            promiseChain = promiseChain.then(() => client.update.updateApplication(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n            resultMappers.push(void 0);\n            return $this;\n          }\n        };\n      },\n      clearState(args) {\n        promiseChain = promiseChain.then(() => client.clearState(__spreadProps(__spreadValues({}, args), { sendParams: __spreadProps(__spreadValues({}, args == null ? void 0 : args.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      addTransaction(txn, defaultSender) {\n        promiseChain = promiseChain.then(() => __async(this, null, function* () {\n          return atc.addTransaction(yield algokit.getTransactionWithSigner(txn, defaultSender != null ? defaultSender : client.sender));\n        }));\n        return this;\n      },\n      atc() {\n        return __async(this, null, function* () {\n          yield promiseChain;\n          return atc;\n        });\n      },\n      simulate(options) {\n        return __async(this, null, function* () {\n          var _a2;\n          yield promiseChain;\n          const result = yield atc.simulate(client.algod, new modelsv2.SimulateRequest(__spreadValues({ txnGroups: [] }, options)));\n          return __spreadProps(__spreadValues({}, result), {\n            returns: (_a2 = result.methodResults) == null ? void 0 : _a2.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val.returnValue) : val.returnValue)\n          });\n        });\n      },\n      execute(sendParams) {\n        return __async(this, null, function* () {\n          var _a2;\n          yield promiseChain;\n          const result = yield algokit.sendAtomicTransactionComposer({ atc, sendParams }, client.algod);\n          return __spreadProps(__spreadValues({}, result), {\n            returns: (_a2 = result.returns) == null ? void 0 : _a2.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val.returnValue) : val.returnValue)\n          });\n        });\n      }\n    };\n  }\n};\n\n// contracts/clients/BiatecCronJob__SHORT_HASH__Client.ts\nimport * as algokit2 from \"@algorandfoundation/algokit-utils\";\nimport { AtomicTransactionComposer as AtomicTransactionComposer2, modelsv2 as modelsv22 } from \"algosdk\";\nvar APP_SPEC2 = {\n  \"hints\": {\n    \"createApplication()void\": {\n      \"call_config\": {\n        \"no_op\": \"CREATE\"\n      }\n    },\n    \"updateApplication(string,string)void\": {\n      \"call_config\": {\n        \"update_application\": \"CALL\"\n      }\n    },\n    \"deleteApplication()void\": {\n      \"call_config\": {\n        \"delete_application\": \"CALL\"\n      }\n    },\n    \"unregisterApplication(uint64,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"setPeriod(uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"payment(uint64,address,string)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"assetTransfer(uint64,uint64,address,string)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"bootstrap(uint64,pay,string,uint64,uint64,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"sendOfflineKeyRegistration()void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"noop()void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    },\n    \"exec()void\": {\n      \"call_config\": {\n        \"no_op\": \"CALL\"\n      }\n    }\n  },\n  \"bare_call_config\": {\n    \"no_op\": \"NEVER\",\n    \"opt_in\": \"NEVER\",\n    \"close_out\": \"NEVER\",\n    \"update_application\": \"NEVER\",\n    \"delete_application\": \"NEVER\"\n  },\n  \"schema\": {\n    \"local\": {\n      \"declared\": {},\n      \"reserved\": {}\n    },\n    \"global\": {\n      \"declared\": {\n        \"id\": {\n          \"type\": \"bytes\",\n          \"key\": \"id\"\n        },\n        \"lastRun\": {\n          \"type\": \"uint64\",\n          \"key\": \"l\"\n        },\n        \"period\": {\n          \"type\": \"uint64\",\n          \"key\": \"p\"\n        },\n        \"start\": {\n          \"type\": \"uint64\",\n          \"key\": \"s\"\n        },\n        \"appPoolManager\": {\n          \"type\": \"uint64\",\n          \"key\": \"pool\"\n        },\n        \"version\": {\n          \"type\": \"bytes\",\n          \"key\": \"scver\"\n        }\n      },\n      \"reserved\": {}\n    }\n  },\n  \"state\": {\n    \"global\": {\n      \"num_byte_slices\": 2,\n      \"num_uints\": 4\n    },\n    \"local\": {\n      \"num_byte_slices\": 0,\n      \"num_uints\": 0\n    }\n  },\n  \"source\": {\n    \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjkwLjMKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIGNvbnRyYWN0LCBpdHMgcmVzcGVjdGl2ZSBicmFuY2ggd2lsbCBiZSAiKk5PVF9JTVBMRU1FTlRFRCIgd2hpY2gganVzdCBjb250YWlucyAiZXJyIgp0eG4gQXBwbGljYXRpb25JRAohCmludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpjYWxsX1VwZGF0ZUFwcGxpY2F0aW9uICpjYWxsX0RlbGV0ZUFwcGxpY2F0aW9uICpjcmVhdGVfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQKCipOT1RfSU1QTEVNRU5URUQ6CgllcnIKCi8vIGNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkCiphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb246CgkvLyBleGVjdXRlIGNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkCgljYWxsc3ViIGNyZWF0ZUFwcGxpY2F0aW9uCglpbnQgMQoJcmV0dXJuCgovLyBjcmVhdGVBcHBsaWNhdGlvbigpOiB2b2lkCi8vCi8vIEluaXRpYWwgc2V0dXAKY3JlYXRlQXBwbGljYXRpb246Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czo1MQoJLy8gdGhpcy5sYXN0UnVuLnZhbHVlID0gMAoJYnl0ZSAweDZjIC8vICJsIgoJaW50IDAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6NTIKCS8vIHRoaXMucGVyaW9kLnZhbHVlID0gMAoJYnl0ZSAweDcwIC8vICJwIgoJaW50IDAKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6NTMKCS8vIHRoaXMuc3RhcnQudmFsdWUgPSAwCglieXRlIDB4NzMgLy8gInMiCglpbnQgMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czo1NAoJLy8gdGhpcy52ZXJzaW9uLnZhbHVlID0gJ0JJQVRFQy1DUk9OLTAxLTAxLTAxJwoJYnl0ZSAweDczNjM3NjY1NzIgLy8gInNjdmVyIgoJYnl0ZSAweDAwMTQ0MjQ5NDE1NDQ1NDMyZDQzNTI0ZjRlMmQzMDMxMmQzMDMxMmQzMDMxCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyB1cGRhdGVBcHBsaWNhdGlvbihzdHJpbmcsc3RyaW5nKXZvaWQKKmFiaV9yb3V0ZV91cGRhdGVBcHBsaWNhdGlvbjoKCS8vIGlkOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWV4dHJhY3QgMiAwCgoJLy8gdmVyc2lvbjogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgdXBkYXRlQXBwbGljYXRpb24oc3RyaW5nLHN0cmluZyl2b2lkCgljYWxsc3ViIHVwZGF0ZUFwcGxpY2F0aW9uCglpbnQgMQoJcmV0dXJuCgovLyB1cGRhdGVBcHBsaWNhdGlvbih2ZXJzaW9uOiBzdHJpbmcsIGlkOiBzdHJpbmcpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIHVwZGF0ZSBhcHBsaWNhdGlvbgp1cGRhdGVBcHBsaWNhdGlvbjoKCXByb3RvIDIgMAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjYxCgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBnbG9iYWxzLmNyZWF0b3JBZGRyZXNzKQoJdHhuIFNlbmRlcgoJZ2xvYmFsIENyZWF0b3JBZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6NjIKCS8vIHRoaXMudmVyc2lvbi52YWx1ZSA9IHZlcnNpb24KCWJ5dGUgMHg3MzYzNzY2NTcyIC8vICJzY3ZlciIKCWZyYW1lX2RpZyAtMSAvLyB2ZXJzaW9uOiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjYzCgkvLyB0aGlzLmlkLnZhbHVlID0gaWQKCWJ5dGUgMHg2OTY0IC8vICJpZCIKCWZyYW1lX2RpZyAtMiAvLyBpZDogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gZGVsZXRlQXBwbGljYXRpb24oKXZvaWQKKmFiaV9yb3V0ZV9kZWxldGVBcHBsaWNhdGlvbjoKCS8vIGV4ZWN1dGUgZGVsZXRlQXBwbGljYXRpb24oKXZvaWQKCWNhbGxzdWIgZGVsZXRlQXBwbGljYXRpb24KCWludCAxCglyZXR1cm4KCi8vIGRlbGV0ZUFwcGxpY2F0aW9uKCk6IHZvaWQKLy8KLy8gQ3JlYXRvciBjYW4gZGVsZXRlIGFwcGxpY2F0aW9uCmRlbGV0ZUFwcGxpY2F0aW9uOgoJcHJvdG8gMCAwCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6NzAKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IGdsb2JhbHMuY3JlYXRvckFkZHJlc3MpCgl0eG4gU2VuZGVyCglnbG9iYWwgQ3JlYXRvckFkZHJlc3MKCT09Cglhc3NlcnQKCXJldHN1YgoKLy8gdW5yZWdpc3RlckFwcGxpY2F0aW9uKHVpbnQ2NCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3VucmVnaXN0ZXJBcHBsaWNhdGlvbjoKCS8vIGluZGV4VG9EZWxldGU6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIGFwcFBvb2xNYW5hZ2VyOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIHVucmVnaXN0ZXJBcHBsaWNhdGlvbih1aW50NjQsdWludDY0KXZvaWQKCWNhbGxzdWIgdW5yZWdpc3RlckFwcGxpY2F0aW9uCglpbnQgMQoJcmV0dXJuCgovLyB1bnJlZ2lzdGVyQXBwbGljYXRpb24oYXBwUG9vbE1hbmFnZXI6IEFwcElELCBpbmRleFRvRGVsZXRlOiB1aW50NjQpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIHVucmVnaXN0ZXJBcHBsaWNhdGlvbiBiZWZvcmUgaGUgZGVsZXRlcyBpdAovLwovLyBAcGFyYW0gYXBwUG9vbE1hbmFnZXIgUG9vbCBtYW5hZ2VyIHdoZXJlIHRoZSB0YXNrIGlzIHJlZ2lzdGVyZWQKLy8gQHBhcmFtIGluZGV4VG9EZWxldGUgQXBwIGluZGV4IHRvIGRlbGV0ZSBmcm9tIHVzZXIncyBhcHBzCnVucmVnaXN0ZXJBcHBsaWNhdGlvbjoKCXByb3RvIDIgMAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjgwCgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBnbG9iYWxzLmNyZWF0b3JBZGRyZXNzKQoJdHhuIFNlbmRlcgoJZ2xvYmFsIENyZWF0b3JBZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6ODEKCS8vIGFzc2VydCh0aGlzLmFwcFBvb2xNYW5hZ2VyLnZhbHVlID09PSBhcHBQb29sTWFuYWdlcikKCWJ5dGUgMHg3MDZmNmY2YyAvLyAicG9vbCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9kaWcgLTEgLy8gYXBwUG9vbE1hbmFnZXI6IEFwcElECgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6ODIKCS8vIHNlbmRNZXRob2RDYWxsPFtBcHBJRCwgdWludDY0XSwgdm9pZD4oewoJLy8gICAgICAgbmFtZTogJ3VucmVnaXN0ZXJUYXNrJywKCS8vICAgICAgIG1ldGhvZEFyZ3M6IFtnbG9iYWxzLmN1cnJlbnRBcHBsaWNhdGlvbklELCBpbmRleFRvRGVsZXRlXSwKCS8vICAgICAgIGFwcGxpY2F0aW9uSUQ6IGFwcFBvb2xNYW5hZ2VyLAoJLy8gICAgICAgZmVlOiAwLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnQgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJbWV0aG9kICJ1bnJlZ2lzdGVyVGFzayh1aW50NjQsdWludDY0KXZvaWQiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjg0CgkvLyBtZXRob2RBcmdzOiBbZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25JRCwgaW5kZXhUb0RlbGV0ZV0KCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAtMiAvLyBpbmRleFRvRGVsZXRlOiB1aW50NjQKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6ODUKCS8vIGFwcGxpY2F0aW9uSUQ6IGFwcFBvb2xNYW5hZ2VyCglmcmFtZV9kaWcgLTEgLy8gYXBwUG9vbE1hbmFnZXI6IEFwcElECglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czo4NgoJLy8gZmVlOiAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglyZXRzdWIKCi8vIHNldFBlcmlvZCh1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3NldFBlcmlvZDoKCS8vIHBlcmlvZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBzZXRQZXJpb2QodWludDY0KXZvaWQKCWNhbGxzdWIgc2V0UGVyaW9kCglpbnQgMQoJcmV0dXJuCgovLyBzZXRQZXJpb2QocGVyaW9kOiB1aW50NjQpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIGNoYW5nZSB0aGUgcGVyaW9kIGhvdyBvZnRlciB0aGUgc2NyaXB0IGNhbiBiZSBleGVjdXRlZCBieSBleGVjdXRvcnMKLy8KLy8gQHBhcmFtIHBlcmlvZCBQZXJpb2QgaW4gc2Vjb25kcwpzZXRQZXJpb2Q6Cglwcm90byAxIDAKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czo5NgoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjk3CgkvLyB0aGlzLnBlcmlvZC52YWx1ZSA9IHBlcmlvZAoJYnl0ZSAweDcwIC8vICJwIgoJZnJhbWVfZGlnIC0xIC8vIHBlcmlvZDogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyBwYXltZW50KHVpbnQ2NCxhZGRyZXNzLHN0cmluZyl2b2lkCiphYmlfcm91dGVfcGF5bWVudDoKCS8vIG5vdGU6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZXh0cmFjdCAyIDAKCgkvLyByZWNlaXZlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAzMgoJPT0KCWFzc2VydAoKCS8vIGFtb3VudDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBwYXltZW50KHVpbnQ2NCxhZGRyZXNzLHN0cmluZyl2b2lkCgljYWxsc3ViIHBheW1lbnQKCWludCAxCglyZXR1cm4KCi8vIHBheW1lbnQoYW1vdW50OiB1aW50NjQsIHJlY2VpdmVyOiBBZGRyZXNzLCBub3RlOiBzdHJpbmcpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIHNlbmQgcGF5L2F4ZmVyIHRyYW5zYWN0aW9uIG91dCBvZiB0aGUgc21hcnQgY29udHJhY3QKLy8KLy8gQHBhcmFtIGFtb3VudCBBbW91bnQKLy8gQHBhcmFtIG5vdGUgTm90ZQovLyBAcGFyYW0gcmVjZWl2ZXIgUmVjZWl2ZXIKcGF5bWVudDoKCXByb3RvIDMgMAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjEwOAoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjEwOQoJLy8gc2VuZFBheW1lbnQoewoJLy8gICAgICAgYW1vdW50OiBhbW91bnQsCgkvLyAgICAgICByZWNlaXZlcjogcmVjZWl2ZXIsCgkvLyAgICAgICBub3RlOiBub3RlLAoJLy8gICAgIH0pCglpdHhuX2JlZ2luCglpbnQgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTEwCgkvLyBhbW91bnQ6IGFtb3VudAoJZnJhbWVfZGlnIC0xIC8vIGFtb3VudDogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjExMQoJLy8gcmVjZWl2ZXI6IHJlY2VpdmVyCglmcmFtZV9kaWcgLTIgLy8gcmVjZWl2ZXI6IEFkZHJlc3MKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxMTIKCS8vIG5vdGU6IG5vdGUKCWZyYW1lX2RpZyAtMyAvLyBub3RlOiBzdHJpbmcKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxMTQKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IGdsb2JhbHMuY3JlYXRvckFkZHJlc3MpCgl0eG4gU2VuZGVyCglnbG9iYWwgQ3JlYXRvckFkZHJlc3MKCT09Cglhc3NlcnQKCXJldHN1YgoKLy8gYXNzZXRUcmFuc2Zlcih1aW50NjQsdWludDY0LGFkZHJlc3Msc3RyaW5nKXZvaWQKKmFiaV9yb3V0ZV9hc3NldFRyYW5zZmVyOgoJLy8gbm90ZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglleHRyYWN0IDIgMAoKCS8vIGFzc2V0UmVjZWl2ZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBhc3NldEFtb3VudDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8geGZlckFzc2V0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGFzc2V0VHJhbnNmZXIodWludDY0LHVpbnQ2NCxhZGRyZXNzLHN0cmluZyl2b2lkCgljYWxsc3ViIGFzc2V0VHJhbnNmZXIKCWludCAxCglyZXR1cm4KCi8vIGFzc2V0VHJhbnNmZXIoeGZlckFzc2V0OiBBc3NldElELCBhc3NldEFtb3VudDogdWludDY0LCBhc3NldFJlY2VpdmVyOiBBZGRyZXNzLCBub3RlOiBzdHJpbmcpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIHNlbmQgcGF5L2F4ZmVyIHRyYW5zYWN0aW9uIG91dCBvZiB0aGUgc21hcnQgY29udHJhY3QKLy8gQHBhcmFtIHhmZXJBc3NldCBBc3NldCBpZAovLyBAcGFyYW0gYXNzZXRBbW91bnQgQW1vdW50Ci8vIEBwYXJhbSBub3RlIE5vdGUKLy8gQHBhcmFtIGFzc2V0UmVjZWl2ZXIgUmVjZWl2ZXIKYXNzZXRUcmFuc2ZlcjoKCXByb3RvIDQgMAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjEyNQoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjEyNgoJLy8gc2VuZEFzc2V0VHJhbnNmZXIoewoJLy8gICAgICAgYXNzZXRBbW91bnQ6IGFzc2V0QW1vdW50LAoJLy8gICAgICAgYXNzZXRSZWNlaXZlcjogYXNzZXRSZWNlaXZlciwKCS8vICAgICAgIHhmZXJBc3NldDogeGZlckFzc2V0LAoJLy8gICAgICAgbm90ZTogbm90ZSwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGF4ZmVyCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTI3CgkvLyBhc3NldEFtb3VudDogYXNzZXRBbW91bnQKCWZyYW1lX2RpZyAtMiAvLyBhc3NldEFtb3VudDogdWludDY0CglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTI4CgkvLyBhc3NldFJlY2VpdmVyOiBhc3NldFJlY2VpdmVyCglmcmFtZV9kaWcgLTMgLy8gYXNzZXRSZWNlaXZlcjogQWRkcmVzcwoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTI5CgkvLyB4ZmVyQXNzZXQ6IHhmZXJBc3NldAoJZnJhbWVfZGlnIC0xIC8vIHhmZXJBc3NldDogQXNzZXRJRAoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxMzAKCS8vIG5vdGU6IG5vdGUKCWZyYW1lX2RpZyAtNCAvLyBub3RlOiBzdHJpbmcKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCXJldHN1YgoKLy8gYm9vdHN0cmFwKHVpbnQ2NCxwYXksc3RyaW5nLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9ib290c3RyYXA6CgkvLyBmZWU6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJYnRvaQoKCS8vIHN0YXJ0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWJ0b2kKCgkvLyBwZXJpb2Q6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIGlkOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWV4dHJhY3QgMiAwCgoJLy8gdHhCYXNlRGVwb3NpdDogcGF5Cgl0eG4gR3JvdXBJbmRleAoJaW50IDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBwYXkKCT09Cglhc3NlcnQKCgkvLyBhcHBQb29sTWFuYWdlcjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBib290c3RyYXAodWludDY0LHBheSxzdHJpbmcsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZAoJY2FsbHN1YiBib290c3RyYXAKCWludCAxCglyZXR1cm4KCi8vIGJvb3RzdHJhcChhcHBQb29sTWFuYWdlcjogQXBwSUQsIHR4QmFzZURlcG9zaXQ6IFBheVR4biwgaWQ6IHN0cmluZywgcGVyaW9kOiB1aW50NjQsIHN0YXJ0OiB1aW50NjQsIGZlZTogdWludDY0KTogdm9pZAovLwovLyBCb290c3RyYXAgdGhlIGNvbnRyYWN0IHRvIG9wdGluIHRvIHRoZSBmZWUgYXNzZXQgYW5kIHNldHVwIGJhc2ljIHZhcmlhYmxlcwovLwovLyBAcGFyYW0gYXBwUG9vbE1hbmFnZXIgVGFza3MgUG9vbCBtYW5hZ2VyIGFwcAovLyBAcGFyYW0gdHhCYXNlRGVwb3NpdCBEZXBvc2l0IE1CUgovLyBAcGFyYW0gaWQgSGFzaCBpZCBvZiB0aGUgaW5wdXQgYXBwCi8vIEBwYXJhbSBwZXJpb2QgIFBlcmlvZCBpbiBzZWNvbmRzIGhvdyBvZnRlbiB0aGlzIHNtYXJ0IGNvbnRyYWN0IGNhbiBiZSBydW4KLy8gQHBhcmFtIHN0YXJ0IFN0YXJ0IHRpbWUgaW4gdW5peCB0aW1lc3RhbXAgc2Vjb25kcy4gQ29udHJhY3QgY2FuIGJlIGV4ZWN0dXRlZCB3aGVuIE1hdGguZmxvb3IoKGN1cnJlbnRUaW1lICsgc3RhcnQpIC8gcGVyaW9kKSA+IE1hdGguZmxvb3IoKGxhc3RSdW4gKyBzdGFydCkgLyBwZXJpb2QpCi8vIEBwYXJhbSBmZWUgRXhlY3V0aW9uIGZlZSBmb3IgdGhlIHRhc2sKYm9vdHN0cmFwOgoJcHJvdG8gNiAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjE1MgoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjE1MwoJLy8gdmVyaWZ5UGF5VHhuKHR4QmFzZURlcG9zaXQsIHsKCS8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmFwcC5hZGRyZXNzLAoJLy8gICAgICAgYW1vdW50OiB7IGdyZWF0ZXJUaGFuRXF1YWxUbzogMCB9LAoJLy8gICAgIH0pCgkvLyB2ZXJpZnkgcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMiAvLyB0eEJhc2VEZXBvc2l0OiBQYXlUeG4KCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSBhbW91bnQKCWZyYW1lX2RpZyAtMiAvLyB0eEJhc2VEZXBvc2l0OiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJaW50IDAKCT49Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxNTgKCS8vIGtlZXAgPSAxMDAwMDAKCWludCAxMDAwMDAKCWZyYW1lX2J1cnkgMCAvLyBrZWVwOiB1aW50NjQKCgkvLyAqaWYwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTU5CgkvLyBnbG9iYWxzLm1pbkJhbGFuY2UgPiBrZWVwCglnbG9iYWwgTWluQmFsYW5jZQoJZnJhbWVfZGlnIDAgLy8ga2VlcDogdWludDY0Cgk+CglieiAqaWYwX2VuZAoKCS8vICppZjBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTU5CgkvLyBrZWVwID0gZ2xvYmFscy5taW5CYWxhbmNlCglnbG9iYWwgTWluQmFsYW5jZQoJZnJhbWVfYnVyeSAwIC8vIGtlZXA6IHVpbnQ2NAoKKmlmMF9lbmQ6CgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxNjMKCS8vIHRhc2s6IFRhc2sgPSB7CgkvLyAgICAgICBhcHA6IGdsb2JhbHMuY3VycmVudEFwcGxpY2F0aW9uSUQsCgkvLyAgICAgICBmZWU6IGZlZSwKCS8vICAgICAgIGZ1bmRzOiAwLAoJLy8gICAgIH0KCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfZGlnIC02IC8vIGZlZTogdWludDY0CglpdG9iCgljb25jYXQKCWZyYW1lX2J1cnkgMSAvLyB0YXNrOiBUYXNrCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTY5CgkvLyBzZW5kTWV0aG9kQ2FsbDxbUGF5VHhuLCBUYXNrXSwgdm9pZD4oewoJLy8gICAgICAgbmFtZTogJ3JlZ2lzdGVyVGFzaycsCgkvLyAgICAgICBtZXRob2RBcmdzOiBbCgkvLyAgICAgICAgIHsKCS8vICAgICAgICAgICBhbW91bnQ6IGdsb2JhbHMuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcy5iYWxhbmNlIC0ga2VlcCwKCS8vICAgICAgICAgICBub3RlOiAncmVnJywKCS8vICAgICAgICAgICByZWNlaXZlcjogYXBwUG9vbE1hbmFnZXIuYWRkcmVzcywKCS8vICAgICAgICAgICBmZWU6IDAsCgkvLyAgICAgICAgIH0sCgkvLyAgICAgICAgIHRhc2ssCgkvLyAgICAgICBdLAoJLy8gICAgICAgYXBwbGljYXRpb25JRDogYXBwUG9vbE1hbmFnZXIsCgkvLyAgICAgICBmZWU6IDAsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxNzMKCS8vIGFtb3VudDogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLmJhbGFuY2UgLSBrZWVwCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCglwb3AKCWZyYW1lX2RpZyAwIC8vIGtlZXA6IHVpbnQ2NAoJLQoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxNzQKCS8vIG5vdGU6ICdyZWcnCglieXRlIDB4NzI2NTY3IC8vICJyZWciCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxNzUKCS8vIHJlY2VpdmVyOiBhcHBQb29sTWFuYWdlci5hZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gYXBwUG9vbE1hbmFnZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxNzYKCS8vIGZlZTogMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCglpdHhuX25leHQKCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgltZXRob2QgInJlZ2lzdGVyVGFzayhwYXksKHVpbnQ2NCx1aW50NjQsdWludDY0KSl2b2lkIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxNzEKCS8vIG1ldGhvZEFyZ3M6IFsKCS8vICAgICAgICAgewoJLy8gICAgICAgICAgIGFtb3VudDogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLmJhbGFuY2UgLSBrZWVwLAoJLy8gICAgICAgICAgIG5vdGU6ICdyZWcnLAoJLy8gICAgICAgICAgIHJlY2VpdmVyOiBhcHBQb29sTWFuYWdlci5hZGRyZXNzLAoJLy8gICAgICAgICAgIGZlZTogMCwKCS8vICAgICAgICAgfSwKCS8vICAgICAgICAgdGFzaywKCS8vICAgICAgIF0KCWZyYW1lX2RpZyAxIC8vIHRhc2s6IFRhc2sKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTgwCgkvLyBhcHBsaWNhdGlvbklEOiBhcHBQb29sTWFuYWdlcgoJZnJhbWVfZGlnIC0xIC8vIGFwcFBvb2xNYW5hZ2VyOiBBcHBJRAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTgxCgkvLyBmZWU6IDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxODQKCS8vIGFzc2VydChwZXJpb2QgPiAwKQoJZnJhbWVfZGlnIC00IC8vIHBlcmlvZDogdWludDY0CglpbnQgMAoJPgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTg1CgkvLyB0aGlzLmlkLnZhbHVlID0gaWQKCWJ5dGUgMHg2OTY0IC8vICJpZCIKCWZyYW1lX2RpZyAtMyAvLyBpZDogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoxODYKCS8vIHRoaXMucGVyaW9kLnZhbHVlID0gcGVyaW9kCglieXRlIDB4NzAgLy8gInAiCglmcmFtZV9kaWcgLTQgLy8gcGVyaW9kOiB1aW50NjQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MTg3CgkvLyB0aGlzLnN0YXJ0LnZhbHVlID0gc3RhcnQKCWJ5dGUgMHg3MyAvLyAicyIKCWZyYW1lX2RpZyAtNSAvLyBzdGFydDogdWludDY0CglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjE4OAoJLy8gdGhpcy5hcHBQb29sTWFuYWdlci52YWx1ZSA9IGFwcFBvb2xNYW5hZ2VyCglieXRlIDB4NzA2ZjZmNmMgLy8gInBvb2wiCglmcmFtZV9kaWcgLTEgLy8gYXBwUG9vbE1hbmFnZXI6IEFwcElECglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgovLyBzZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uKGJ5dGVbXSxieXRlW10sYnl0ZVtdLHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9zZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uOgoJLy8gdm90ZUtleURpbHV0aW9uOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDYKCWJ0b2kKCgkvLyB2b3RlTGFzdDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglidG9pCgoJLy8gdm90ZUZpcnN0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWJ0b2kKCgkvLyBzdGF0ZVByb29mUGs6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZXh0cmFjdCAyIDAKCgkvLyBzZWxlY3Rpb25QazogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglleHRyYWN0IDIgMAoKCS8vIHZvdGVQazogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgc2VuZE9ubGluZUtleVJlZ2lzdHJhdGlvbihieXRlW10sYnl0ZVtdLGJ5dGVbXSx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkCgljYWxsc3ViIHNlbmRPbmxpbmVLZXlSZWdpc3RyYXRpb24KCWludCAxCglyZXR1cm4KCi8vIHNlbmRPbmxpbmVLZXlSZWdpc3RyYXRpb24odm90ZVBrOiBieXRlcywgc2VsZWN0aW9uUGs6IGJ5dGVzLCBzdGF0ZVByb29mUGs6IGJ5dGVzLCB2b3RlRmlyc3Q6IHVpbnQ2NCwgdm90ZUxhc3Q6IHVpbnQ2NCwgdm90ZUtleURpbHV0aW9uOiB1aW50NjQpOiB2b2lkCi8vCi8vIENyZWF0b3IgY2FuIHBlcmZvbSBrZXkgcmVnaXN0cmF0aW9uIGZvciB0aGlzIExQIHBvb2wKc2VuZE9ubGluZUtleVJlZ2lzdHJhdGlvbjoKCXByb3RvIDYgMAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjIwMgoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjIwMwoJLy8gc2VuZE9ubGluZUtleVJlZ2lzdHJhdGlvbih7CgkvLyAgICAgICBzZWxlY3Rpb25QSzogc2VsZWN0aW9uUGssCgkvLyAgICAgICBzdGF0ZVByb29mUEs6IHN0YXRlUHJvb2ZQaywKCS8vICAgICAgIHZvdGVGaXJzdDogdm90ZUZpcnN0LAoJLy8gICAgICAgdm90ZUtleURpbHV0aW9uOiB2b3RlS2V5RGlsdXRpb24sCgkvLyAgICAgICB2b3RlTGFzdDogdm90ZUxhc3QsCgkvLyAgICAgICB2b3RlUEs6IHZvdGVQaywKCS8vICAgICAgIGZlZTogMCwKCS8vICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGtleXJlZwoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjIwNAoJLy8gc2VsZWN0aW9uUEs6IHNlbGVjdGlvblBrCglmcmFtZV9kaWcgLTIgLy8gc2VsZWN0aW9uUGs6IGJ5dGVzCglpdHhuX2ZpZWxkIFNlbGVjdGlvblBLCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MjA1CgkvLyBzdGF0ZVByb29mUEs6IHN0YXRlUHJvb2ZQawoJZnJhbWVfZGlnIC0zIC8vIHN0YXRlUHJvb2ZQazogYnl0ZXMKCWl0eG5fZmllbGQgU3RhdGVQcm9vZlBLCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MjA2CgkvLyB2b3RlRmlyc3Q6IHZvdGVGaXJzdAoJZnJhbWVfZGlnIC00IC8vIHZvdGVGaXJzdDogdWludDY0CglpdHhuX2ZpZWxkIFZvdGVGaXJzdAoKCS8vIGNvbnRyYWN0c1x0ZW1wbGF0ZS5hbGdvLnRzOjIwNwoJLy8gdm90ZUtleURpbHV0aW9uOiB2b3RlS2V5RGlsdXRpb24KCWZyYW1lX2RpZyAtNiAvLyB2b3RlS2V5RGlsdXRpb246IHVpbnQ2NAoJaXR4bl9maWVsZCBWb3RlS2V5RGlsdXRpb24KCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMDgKCS8vIHZvdGVMYXN0OiB2b3RlTGFzdAoJZnJhbWVfZGlnIC01IC8vIHZvdGVMYXN0OiB1aW50NjQKCWl0eG5fZmllbGQgVm90ZUxhc3QKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMDkKCS8vIHZvdGVQSzogdm90ZVBrCglmcmFtZV9kaWcgLTEgLy8gdm90ZVBrOiBieXRlcwoJaXR4bl9maWVsZCBWb3RlUEsKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMTAKCS8vIGZlZTogMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyBzZW5kT2ZmbGluZUtleVJlZ2lzdHJhdGlvbigpdm9pZAoqYWJpX3JvdXRlX3NlbmRPZmZsaW5lS2V5UmVnaXN0cmF0aW9uOgoJLy8gZXhlY3V0ZSBzZW5kT2ZmbGluZUtleVJlZ2lzdHJhdGlvbigpdm9pZAoJY2FsbHN1YiBzZW5kT2ZmbGluZUtleVJlZ2lzdHJhdGlvbgoJaW50IDEKCXJldHVybgoKLy8gc2VuZE9mZmxpbmVLZXlSZWdpc3RyYXRpb24oKTogdm9pZAovLwovLyBDcmVhdG9yIGNhbiBwZXJmb20ga2V5IHVucmVnaXN0cmF0aW9uIGZvciB0aGlzIExQIHBvb2wKc2VuZE9mZmxpbmVLZXlSZWdpc3RyYXRpb246Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMTgKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IGdsb2JhbHMuY3JlYXRvckFkZHJlc3MpCgl0eG4gU2VuZGVyCglnbG9iYWwgQ3JlYXRvckFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMTkKCS8vIHNlbmRPZmZsaW5lS2V5UmVnaXN0cmF0aW9uKHsgZmVlOiAwIH0pCglpdHhuX2JlZ2luCglpbnQga2V5cmVnCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MjE5CgkvLyBmZWU6IDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCXJldHN1YgoKLy8gbm9vcCgpdm9pZAoqYWJpX3JvdXRlX25vb3A6CgkvLyBleGVjdXRlIG5vb3AoKXZvaWQKCWNhbGxzdWIgbm9vcAoJaW50IDEKCXJldHVybgoKLy8gbm9vcCgpOiB2b2lkCi8vCi8vIE5vIG9wLCBmb3IgcHVycG9zZSBvZiBhZGRpbmcgZXh0cmEgcmVzb3VyY2VzIHRvIHRoZSB0eCBncm91cApub29wOgoJcHJvdG8gMCAwCgoJLy8gY29udHJhY3RzXHRlbXBsYXRlLmFsZ28udHM6MjI2CgkvLyBsb2coJzEnKQoJYnl0ZSAweDMxIC8vICIxIgoJbG9nCglyZXRzdWIKCi8vIGV4ZWMoKXZvaWQKKmFiaV9yb3V0ZV9leGVjOgoJLy8gZXhlY3V0ZSBleGVjKCl2b2lkCgljYWxsc3ViIGV4ZWMKCWludCAxCglyZXR1cm4KCi8vIGV4ZWMoKTogdm9pZAovLwovLyBBbnlvbmUgY2FuIGV4ZWN1dGUgdGhpcyBzY2hlZHVsZXIgbWV0aG9kIHdoZW4gdGltZSBpcyByaWdodCBhbmQgaGUgd2lsbCBiZSByZXdhcmRlZCB0aGUgZmVlCmV4ZWM6Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMzMKCS8vIGFzc2VydCh0aGlzLnN0YXJ0LnZhbHVlIDw9IGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wLCAnRVJSX05PX1NUQVJUX1lFVCcpCglieXRlIDB4NzMgLy8gInMiCglhcHBfZ2xvYmFsX2dldAoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJPD0KCgkvLyBFUlJfTk9fU1RBUlRfWUVUCglhc3NlcnQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMzQKCS8vIGFzc2VydCgKCS8vICAgICAgIChnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCArIHRoaXMuc3RhcnQudmFsdWUpIC8gdGhpcy5wZXJpb2QudmFsdWUgPgoJLy8gICAgICAgICAodGhpcy5sYXN0UnVuLnZhbHVlICsgdGhpcy5zdGFydC52YWx1ZSkgLyB0aGlzLnBlcmlvZC52YWx1ZSwKCS8vICAgICAgICdFUlJfTk9fVElNRV9ZRVQnCgkvLyAgICAgKQoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJYnl0ZSAweDczIC8vICJzIgoJYXBwX2dsb2JhbF9nZXQKCSsKCWJ5dGUgMHg3MCAvLyAicCIKCWFwcF9nbG9iYWxfZ2V0CgkvCglieXRlIDB4NmMgLy8gImwiCglhcHBfZ2xvYmFsX2dldAoJYnl0ZSAweDczIC8vICJzIgoJYXBwX2dsb2JhbF9nZXQKCSsKCWJ5dGUgMHg3MCAvLyAicCIKCWFwcF9nbG9iYWxfZ2V0CgkvCgk+CgoJLy8gRVJSX05PX1RJTUVfWUVUCglhc3NlcnQKCgkvLyBjb250cmFjdHNcdGVtcGxhdGUuYWxnby50czoyMzkKCS8vIHRoaXMubGFzdFJ1bi52YWx1ZSA9IGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wCglieXRlIDB4NmMgLy8gImwiCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglhcHBfZ2xvYmFsX3B1dAoJcmV0c3ViCgoqY3JlYXRlX05vT3A6CgltZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoJZXJyCgoqY2FsbF9Ob09wOgoJbWV0aG9kICJ1bnJlZ2lzdGVyQXBwbGljYXRpb24odWludDY0LHVpbnQ2NCl2b2lkIgoJbWV0aG9kICJzZXRQZXJpb2QodWludDY0KXZvaWQiCgltZXRob2QgInBheW1lbnQodWludDY0LGFkZHJlc3Msc3RyaW5nKXZvaWQiCgltZXRob2QgImFzc2V0VHJhbnNmZXIodWludDY0LHVpbnQ2NCxhZGRyZXNzLHN0cmluZyl2b2lkIgoJbWV0aG9kICJib290c3RyYXAodWludDY0LHBheSxzdHJpbmcsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCIKCW1ldGhvZCAic2VuZE9ubGluZUtleVJlZ2lzdHJhdGlvbihieXRlW10sYnl0ZVtdLGJ5dGVbXSx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkIgoJbWV0aG9kICJzZW5kT2ZmbGluZUtleVJlZ2lzdHJhdGlvbigpdm9pZCIKCW1ldGhvZCAibm9vcCgpdm9pZCIKCW1ldGhvZCAiZXhlYygpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfdW5yZWdpc3RlckFwcGxpY2F0aW9uICphYmlfcm91dGVfc2V0UGVyaW9kICphYmlfcm91dGVfcGF5bWVudCAqYWJpX3JvdXRlX2Fzc2V0VHJhbnNmZXIgKmFiaV9yb3V0ZV9ib290c3RyYXAgKmFiaV9yb3V0ZV9zZW5kT25saW5lS2V5UmVnaXN0cmF0aW9uICphYmlfcm91dGVfc2VuZE9mZmxpbmVLZXlSZWdpc3RyYXRpb24gKmFiaV9yb3V0ZV9ub29wICphYmlfcm91dGVfZXhlYwoJZXJyCgoqY2FsbF9VcGRhdGVBcHBsaWNhdGlvbjoKCW1ldGhvZCAidXBkYXRlQXBwbGljYXRpb24oc3RyaW5nLHN0cmluZyl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV91cGRhdGVBcHBsaWNhdGlvbgoJZXJyCgoqY2FsbF9EZWxldGVBcHBsaWNhdGlvbjoKCW1ldGhvZCAiZGVsZXRlQXBwbGljYXRpb24oKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2RlbGV0ZUFwcGxpY2F0aW9uCgllcnI=\",\n    \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDEw\"\n  },\n  \"contract\": {\n    \"name\": \"BiatecCronJob__SHORT_HASH__\",\n    \"desc\": \"\",\n    \"methods\": [\n      {\n        \"name\": \"createApplication\",\n        \"desc\": \"Initial setup\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"updateApplication\",\n        \"desc\": \"Creator can update application\",\n        \"args\": [\n          {\n            \"name\": \"version\",\n            \"type\": \"string\"\n          },\n          {\n            \"name\": \"id\",\n            \"type\": \"string\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"deleteApplication\",\n        \"desc\": \"Creator can delete application\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"unregisterApplication\",\n        \"desc\": \"Creator can unregisterApplication before he deletes it\",\n        \"args\": [\n          {\n            \"name\": \"appPoolManager\",\n            \"type\": \"uint64\",\n            \"desc\": \"Pool manager where the task is registered\"\n          },\n          {\n            \"name\": \"indexToDelete\",\n            \"type\": \"uint64\",\n            \"desc\": \"App index to delete from user's apps\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"setPeriod\",\n        \"desc\": \"Creator can change the period how ofter the script can be executed by executors\",\n        \"args\": [\n          {\n            \"name\": \"period\",\n            \"type\": \"uint64\",\n            \"desc\": \"Period in seconds\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"payment\",\n        \"desc\": \"Creator can send pay/axfer transaction out of the smart contract\",\n        \"args\": [\n          {\n            \"name\": \"amount\",\n            \"type\": \"uint64\",\n            \"desc\": \"Amount\"\n          },\n          {\n            \"name\": \"receiver\",\n            \"type\": \"address\",\n            \"desc\": \"Receiver\"\n          },\n          {\n            \"name\": \"note\",\n            \"type\": \"string\",\n            \"desc\": \"Note\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"assetTransfer\",\n        \"desc\": \"Creator can send pay/axfer transaction out of the smart contract\",\n        \"args\": [\n          {\n            \"name\": \"xferAsset\",\n            \"type\": \"uint64\",\n            \"desc\": \"Asset id\"\n          },\n          {\n            \"name\": \"assetAmount\",\n            \"type\": \"uint64\",\n            \"desc\": \"Amount\"\n          },\n          {\n            \"name\": \"assetReceiver\",\n            \"type\": \"address\",\n            \"desc\": \"Receiver\"\n          },\n          {\n            \"name\": \"note\",\n            \"type\": \"string\",\n            \"desc\": \"Note\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"bootstrap\",\n        \"desc\": \"Bootstrap the contract to optin to the fee asset and setup basic variables\",\n        \"args\": [\n          {\n            \"name\": \"appPoolManager\",\n            \"type\": \"uint64\",\n            \"desc\": \"Tasks Pool manager app\"\n          },\n          {\n            \"name\": \"txBaseDeposit\",\n            \"type\": \"pay\",\n            \"desc\": \"Deposit MBR\"\n          },\n          {\n            \"name\": \"id\",\n            \"type\": \"string\",\n            \"desc\": \"Hash id of the input app\"\n          },\n          {\n            \"name\": \"period\",\n            \"type\": \"uint64\",\n            \"desc\": \"Period in seconds how often this smart contract can be run\"\n          },\n          {\n            \"name\": \"start\",\n            \"type\": \"uint64\",\n            \"desc\": \"Start time in unix timestamp seconds. Contract can be exectuted when Math.floor((currentTime + start) / period)>Math.floor((lastRun + start) / period)\"\n          },\n          {\n            \"name\": \"fee\",\n            \"type\": \"uint64\",\n            \"desc\": \"Execution fee for the task\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"sendOnlineKeyRegistration\",\n        \"desc\": \"Creator can perfom key registration for this LP pool\",\n        \"args\": [\n          {\n            \"name\": \"votePk\",\n            \"type\": \"byte[]\"\n          },\n          {\n            \"name\": \"selectionPk\",\n            \"type\": \"byte[]\"\n          },\n          {\n            \"name\": \"stateProofPk\",\n            \"type\": \"byte[]\"\n          },\n          {\n            \"name\": \"voteFirst\",\n            \"type\": \"uint64\"\n          },\n          {\n            \"name\": \"voteLast\",\n            \"type\": \"uint64\"\n          },\n          {\n            \"name\": \"voteKeyDilution\",\n            \"type\": \"uint64\"\n          }\n        ],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"sendOfflineKeyRegistration\",\n        \"desc\": \"Creator can perfom key unregistration for this LP pool\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"noop\",\n        \"desc\": \"No op, for purpose of adding extra resources to the tx group\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      },\n      {\n        \"name\": \"exec\",\n        \"desc\": \"Anyone can execute this scheduler method when time is right and he will be rewarded the fee\",\n        \"args\": [],\n        \"returns\": {\n          \"type\": \"void\"\n        }\n      }\n    ]\n  }\n};\nvar BiatecCronJobShortHashCallFactory = class {\n  /**\n   * Gets available create call factories\n   */\n  static get create() {\n    return {\n      /**\n       * Constructs a create call for the BiatecCronJob__SHORT_HASH__ smart contract using the createApplication()void ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      createApplication(args, params = {}) {\n        return __spreadValues({\n          method: \"createApplication()void\",\n          methodArgs: Array.isArray(args) ? args : []\n        }, params);\n      }\n    };\n  }\n  /**\n   * Gets available update call factories\n   */\n  static get update() {\n    return {\n      /**\n       * Constructs an update call for the BiatecCronJob__SHORT_HASH__ smart contract using the updateApplication(string,string)void ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      updateApplication(args, params = {}) {\n        return __spreadValues({\n          method: \"updateApplication(string,string)void\",\n          methodArgs: Array.isArray(args) ? args : [args.version, args.id]\n        }, params);\n      }\n    };\n  }\n  /**\n   * Gets available delete call factories\n   */\n  static get delete() {\n    return {\n      /**\n       * Constructs a delete call for the BiatecCronJob__SHORT_HASH__ smart contract using the deleteApplication()void ABI method\n       *\n       * @param args Any args for the contract call\n       * @param params Any additional parameters for the call\n       * @returns A TypedCallParams object for the call\n       */\n      deleteApplication(args, params = {}) {\n        return __spreadValues({\n          method: \"deleteApplication()void\",\n          methodArgs: Array.isArray(args) ? args : []\n        }, params);\n      }\n    };\n  }\n  /**\n   * Constructs a no op call for the unregisterApplication(uint64,uint64)void ABI method\n   *\n   * Creator can unregisterApplication before he deletes it\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static unregisterApplication(args, params) {\n    return __spreadValues({\n      method: \"unregisterApplication(uint64,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.appPoolManager, args.indexToDelete]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the setPeriod(uint64)void ABI method\n   *\n   * Creator can change the period how ofter the script can be executed by executors\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static setPeriod(args, params) {\n    return __spreadValues({\n      method: \"setPeriod(uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.period]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the payment(uint64,address,string)void ABI method\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static payment(args, params) {\n    return __spreadValues({\n      method: \"payment(uint64,address,string)void\",\n      methodArgs: Array.isArray(args) ? args : [args.amount, args.receiver, args.note]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the assetTransfer(uint64,uint64,address,string)void ABI method\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static assetTransfer(args, params) {\n    return __spreadValues({\n      method: \"assetTransfer(uint64,uint64,address,string)void\",\n      methodArgs: Array.isArray(args) ? args : [args.xferAsset, args.assetAmount, args.assetReceiver, args.note]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the bootstrap(uint64,pay,string,uint64,uint64,uint64)void ABI method\n   *\n   * Bootstrap the contract to optin to the fee asset and setup basic variables\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static bootstrap(args, params) {\n    return __spreadValues({\n      method: \"bootstrap(uint64,pay,string,uint64,uint64,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.appPoolManager, args.txBaseDeposit, args.id, args.period, args.start, args.fee]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void ABI method\n   *\n   * Creator can perfom key registration for this LP pool\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static sendOnlineKeyRegistration(args, params) {\n    return __spreadValues({\n      method: \"sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void\",\n      methodArgs: Array.isArray(args) ? args : [args.votePk, args.selectionPk, args.stateProofPk, args.voteFirst, args.voteLast, args.voteKeyDilution]\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the sendOfflineKeyRegistration()void ABI method\n   *\n   * Creator can perfom key unregistration for this LP pool\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static sendOfflineKeyRegistration(args, params) {\n    return __spreadValues({\n      method: \"sendOfflineKeyRegistration()void\",\n      methodArgs: Array.isArray(args) ? args : []\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the noop()void ABI method\n   *\n   * No op, for purpose of adding extra resources to the tx group\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static noop(args, params) {\n    return __spreadValues({\n      method: \"noop()void\",\n      methodArgs: Array.isArray(args) ? args : []\n    }, params);\n  }\n  /**\n   * Constructs a no op call for the exec()void ABI method\n   *\n   * Anyone can execute this scheduler method when time is right and he will be rewarded the fee\n   *\n   * @param args Any args for the contract call\n   * @param params Any additional parameters for the call\n   * @returns A TypedCallParams object for the call\n   */\n  static exec(args, params) {\n    return __spreadValues({\n      method: \"exec()void\",\n      methodArgs: Array.isArray(args) ? args : []\n    }, params);\n  }\n};\nvar BiatecCronJobShortHashClient = class _BiatecCronJobShortHashClient {\n  /**\n   * Creates a new instance of `BiatecCronJobShortHashClient`\n   *\n   * @param appDetails appDetails The details to identify the app to deploy\n   * @param algod An algod client instance\n   */\n  constructor(appDetails, algod) {\n    this.algod = algod;\n    this.sender = appDetails.sender;\n    this.appClient = algokit2.getAppClient(__spreadProps(__spreadValues({}, appDetails), {\n      app: APP_SPEC2\n    }), algod);\n  }\n  /**\n   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type\n   *\n   * @param result The AppCallTransactionResult to be mapped\n   * @param returnValueFormatter An optional delegate to format the return value if required\n   * @returns The smart contract response with an updated return value\n   */\n  mapReturnValue(result, returnValueFormatter) {\n    var _a, _b, _c;\n    if ((_a = result.return) == null ? void 0 : _a.decodeError) {\n      throw result.return.decodeError;\n    }\n    const returnValue = ((_b = result.return) == null ? void 0 : _b.returnValue) !== void 0 && returnValueFormatter !== void 0 ? returnValueFormatter(result.return.returnValue) : (_c = result.return) == null ? void 0 : _c.returnValue;\n    return __spreadProps(__spreadValues({}, result), { return: returnValue });\n  }\n  /**\n   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP\n   *\n   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters\n   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type\n   * @returns The result of the smart contract call\n   */\n  call(typedCallParams, returnValueFormatter) {\n    return __async(this, null, function* () {\n      return this.mapReturnValue(yield this.appClient.call(typedCallParams), returnValueFormatter);\n    });\n  }\n  /**\n   * Idempotently deploys the BiatecCronJob__SHORT_HASH__ smart contract.\n   *\n   * @param params The arguments for the contract calls and any additional parameters for the call\n   * @returns The deployment result\n   */\n  deploy(params = {}) {\n    var _a, _b, _c;\n    const createArgs = (_a = params.createCall) == null ? void 0 : _a.call(params, BiatecCronJobShortHashCallFactory.create);\n    const updateArgs = (_b = params.updateCall) == null ? void 0 : _b.call(params, BiatecCronJobShortHashCallFactory.update);\n    const deleteArgs = (_c = params.deleteCall) == null ? void 0 : _c.call(params, BiatecCronJobShortHashCallFactory.delete);\n    return this.appClient.deploy(__spreadProps(__spreadValues({}, params), {\n      updateArgs,\n      deleteArgs,\n      createArgs,\n      createOnCompleteAction: createArgs == null ? void 0 : createArgs.onCompleteAction\n    }));\n  }\n  /**\n   * Gets available create methods\n   */\n  get create() {\n    const $this = this;\n    return {\n      /**\n       * Creates a new instance of the BiatecCronJob__SHORT_HASH__ smart contract using the createApplication()void ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The create result\n       */\n      createApplication(_0) {\n        return __async(this, arguments, function* (args, params = {}) {\n          return $this.mapReturnValue(yield $this.appClient.create(BiatecCronJobShortHashCallFactory.create.createApplication(args, params)));\n        });\n      }\n    };\n  }\n  /**\n   * Gets available update methods\n   */\n  get update() {\n    const $this = this;\n    return {\n      /**\n       * Updates an existing instance of the BiatecCronJob__SHORT_HASH__ smart contract using the updateApplication(string,string)void ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The update result\n       */\n      updateApplication(_0) {\n        return __async(this, arguments, function* (args, params = {}) {\n          return $this.mapReturnValue(yield $this.appClient.update(BiatecCronJobShortHashCallFactory.update.updateApplication(args, params)));\n        });\n      }\n    };\n  }\n  /**\n   * Gets available delete methods\n   */\n  get delete() {\n    const $this = this;\n    return {\n      /**\n       * Deletes an existing instance of the BiatecCronJob__SHORT_HASH__ smart contract using the deleteApplication()void ABI method.\n       *\n       * @param args The arguments for the smart contract call\n       * @param params Any additional parameters for the call\n       * @returns The delete result\n       */\n      deleteApplication(_0) {\n        return __async(this, arguments, function* (args, params = {}) {\n          return $this.mapReturnValue(yield $this.appClient.delete(BiatecCronJobShortHashCallFactory.delete.deleteApplication(args, params)));\n        });\n      }\n    };\n  }\n  /**\n   * Makes a clear_state call to an existing instance of the BiatecCronJob__SHORT_HASH__ smart contract.\n   *\n   * @param args The arguments for the bare call\n   * @returns The clear_state result\n   */\n  clearState(args = {}) {\n    return this.appClient.clearState(args);\n  }\n  /**\n   * Calls the unregisterApplication(uint64,uint64)void ABI method.\n   *\n   * Creator can unregisterApplication before he deletes it\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  unregisterApplication(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.unregisterApplication(args, params));\n  }\n  /**\n   * Calls the setPeriod(uint64)void ABI method.\n   *\n   * Creator can change the period how ofter the script can be executed by executors\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  setPeriod(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.setPeriod(args, params));\n  }\n  /**\n   * Calls the payment(uint64,address,string)void ABI method.\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  payment(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.payment(args, params));\n  }\n  /**\n   * Calls the assetTransfer(uint64,uint64,address,string)void ABI method.\n   *\n   * Creator can send pay/axfer transaction out of the smart contract\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  assetTransfer(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.assetTransfer(args, params));\n  }\n  /**\n   * Calls the bootstrap(uint64,pay,string,uint64,uint64,uint64)void ABI method.\n   *\n   * Bootstrap the contract to optin to the fee asset and setup basic variables\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  bootstrap(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.bootstrap(args, params));\n  }\n  /**\n   * Calls the sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64)void ABI method.\n   *\n   * Creator can perfom key registration for this LP pool\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  sendOnlineKeyRegistration(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.sendOnlineKeyRegistration(args, params));\n  }\n  /**\n   * Calls the sendOfflineKeyRegistration()void ABI method.\n   *\n   * Creator can perfom key unregistration for this LP pool\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  sendOfflineKeyRegistration(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.sendOfflineKeyRegistration(args, params));\n  }\n  /**\n   * Calls the noop()void ABI method.\n   *\n   * No op, for purpose of adding extra resources to the tx group\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  noop(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.noop(args, params));\n  }\n  /**\n   * Calls the exec()void ABI method.\n   *\n   * Anyone can execute this scheduler method when time is right and he will be rewarded the fee\n   *\n   * @param args The arguments for the contract call\n   * @param params Any additional parameters for the call\n   * @returns The result of the call\n   */\n  exec(args, params = {}) {\n    return this.call(BiatecCronJobShortHashCallFactory.exec(args, params));\n  }\n  /**\n   * Extracts a binary state value out of an AppState dictionary\n   *\n   * @param state The state dictionary containing the state value\n   * @param key The key of the state value\n   * @returns A BinaryState instance containing the state value, or undefined if the key was not found\n   */\n  static getBinaryState(state, key) {\n    const value = state[key];\n    if (!value)\n      return void 0;\n    if (!(\"valueRaw\" in value))\n      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`);\n    return {\n      asString() {\n        return value.value;\n      },\n      asByteArray() {\n        return value.valueRaw;\n      }\n    };\n  }\n  /**\n   * Extracts a integer state value out of an AppState dictionary\n   *\n   * @param state The state dictionary containing the state value\n   * @param key The key of the state value\n   * @returns An IntegerState instance containing the state value, or undefined if the key was not found\n   */\n  static getIntegerState(state, key) {\n    const value = state[key];\n    if (!value)\n      return void 0;\n    if (\"valueRaw\" in value)\n      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`);\n    return {\n      asBigInt() {\n        return typeof value.value === \"bigint\" ? value.value : BigInt(value.value);\n      },\n      asNumber() {\n        return typeof value.value === \"bigint\" ? Number(value.value) : value.value;\n      }\n    };\n  }\n  /**\n   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value\n   */\n  getGlobalState() {\n    return __async(this, null, function* () {\n      const state = yield this.appClient.getGlobalState();\n      return {\n        get id() {\n          return _BiatecCronJobShortHashClient.getBinaryState(state, \"id\");\n        },\n        get l() {\n          return _BiatecCronJobShortHashClient.getIntegerState(state, \"l\");\n        },\n        get p() {\n          return _BiatecCronJobShortHashClient.getIntegerState(state, \"p\");\n        },\n        get s() {\n          return _BiatecCronJobShortHashClient.getIntegerState(state, \"s\");\n        },\n        get pool() {\n          return _BiatecCronJobShortHashClient.getIntegerState(state, \"pool\");\n        },\n        get scver() {\n          return _BiatecCronJobShortHashClient.getBinaryState(state, \"scver\");\n        }\n      };\n    });\n  }\n  compose() {\n    const client = this;\n    const atc = new AtomicTransactionComposer2();\n    let promiseChain = Promise.resolve();\n    const resultMappers = [];\n    return {\n      unregisterApplication(args, params) {\n        promiseChain = promiseChain.then(() => client.unregisterApplication(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      setPeriod(args, params) {\n        promiseChain = promiseChain.then(() => client.setPeriod(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      payment(args, params) {\n        promiseChain = promiseChain.then(() => client.payment(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      assetTransfer(args, params) {\n        promiseChain = promiseChain.then(() => client.assetTransfer(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      bootstrap(args, params) {\n        promiseChain = promiseChain.then(() => client.bootstrap(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      sendOnlineKeyRegistration(args, params) {\n        promiseChain = promiseChain.then(() => client.sendOnlineKeyRegistration(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      sendOfflineKeyRegistration(args, params) {\n        promiseChain = promiseChain.then(() => client.sendOfflineKeyRegistration(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      noop(args, params) {\n        promiseChain = promiseChain.then(() => client.noop(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      exec(args, params) {\n        promiseChain = promiseChain.then(() => client.exec(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      get update() {\n        const $this = this;\n        return {\n          updateApplication(args, params) {\n            promiseChain = promiseChain.then(() => client.update.updateApplication(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n            resultMappers.push(void 0);\n            return $this;\n          }\n        };\n      },\n      get delete() {\n        const $this = this;\n        return {\n          deleteApplication(args, params) {\n            promiseChain = promiseChain.then(() => client.delete.deleteApplication(args, __spreadProps(__spreadValues({}, params), { sendParams: __spreadProps(__spreadValues({}, params == null ? void 0 : params.sendParams), { skipSending: true, atc }) })));\n            resultMappers.push(void 0);\n            return $this;\n          }\n        };\n      },\n      clearState(args) {\n        promiseChain = promiseChain.then(() => client.clearState(__spreadProps(__spreadValues({}, args), { sendParams: __spreadProps(__spreadValues({}, args == null ? void 0 : args.sendParams), { skipSending: true, atc }) })));\n        resultMappers.push(void 0);\n        return this;\n      },\n      addTransaction(txn, defaultSender) {\n        promiseChain = promiseChain.then(() => __async(this, null, function* () {\n          return atc.addTransaction(yield algokit2.getTransactionWithSigner(txn, defaultSender != null ? defaultSender : client.sender));\n        }));\n        return this;\n      },\n      atc() {\n        return __async(this, null, function* () {\n          yield promiseChain;\n          return atc;\n        });\n      },\n      simulate(options) {\n        return __async(this, null, function* () {\n          var _a2;\n          yield promiseChain;\n          const result = yield atc.simulate(client.algod, new modelsv22.SimulateRequest(__spreadValues({ txnGroups: [] }, options)));\n          return __spreadProps(__spreadValues({}, result), {\n            returns: (_a2 = result.methodResults) == null ? void 0 : _a2.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val.returnValue) : val.returnValue)\n          });\n        });\n      },\n      execute(sendParams) {\n        return __async(this, null, function* () {\n          var _a2;\n          yield promiseChain;\n          const result = yield algokit2.sendAtomicTransactionComposer({ atc, sendParams }, client.algod);\n          return __spreadProps(__spreadValues({}, result), {\n            returns: (_a2 = result.returns) == null ? void 0 : _a2.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val.returnValue) : val.returnValue)\n          });\n        });\n      }\n    };\n  }\n};\nexport {\n  BiatecCronJobShortHashClient,\n  BiatecTaskManagerClient,\n  getBoxReferenceApp_default as getBoxReferenceApp,\n  getBoxReferenceUser_default as getBoxReferenceUser,\n  getPoolManagerApp_default as getPoolManagerApp,\n  parseBoxData_default as parseBoxData\n};\n//# sourceMappingURL=index.mjs.map","const base642base64url = (input: string) => {\n  return input.replaceAll(\"+\", \"-\").replaceAll(\"/\", \"_\").replaceAll(\"=\", \"\");\n};\nexport default base642base64url;\n","/**\n * Converts a value which might be a number or a bigint into a number to be used with apis that don't support bigint.\n *\n * Throws an UnsafeConversionError if the conversion would result in an unsafe integer for the Number type\n * @param value\n */\nconst toNumber = (value) => {\n    if (typeof value === 'number')\n        return value;\n    if (value > BigInt(Number.MAX_SAFE_INTEGER)) {\n        throw new UnsafeConversionError(`Cannot convert ${value} to a Number as it is larger than the maximum safe integer the Number type can hold.`);\n    }\n    else if (value < BigInt(Number.MIN_SAFE_INTEGER)) {\n        throw new UnsafeConversionError(`Cannot convert ${value} to a Number as it is smaller than the minimum safe integer the Number type can hold.`);\n    }\n    return Number(value);\n};\nclass UnsafeConversionError extends Error {\n}\n/**\n * Calculates the amount of funds to add to a wallet to bring it up to the minimum spending balance.\n * @param minSpendingBalance The minimum spending balance for the wallet\n * @param currentSpendingBalance The current spending balance for the wallet\n * @param minFundingIncrement The minimum amount of funds that can be added to the wallet\n * @returns The amount of funds to add to the wallet or null if the wallet is already above the minimum spending balance\n */\nconst calculateFundAmount = (minSpendingBalance, currentSpendingBalance, minFundingIncrement) => {\n    if (minSpendingBalance > currentSpendingBalance) {\n        const minFundAmount = minSpendingBalance - currentSpendingBalance;\n        return Math.max(minFundAmount, minFundingIncrement);\n    }\n    else {\n        return null;\n    }\n};\n/**\n * Checks if the current environment is Node.js\n *\n * @returns A boolean indicating whether the current environment is Node.js\n */\nconst isNode = () => {\n    return typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n};\n\nexport { UnsafeConversionError, calculateFundAmount, isNode, toNumber };\n//# sourceMappingURL=util.mjs.map\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable no-console */\n/** A logger implementation that writes to console */\nconst consoleLogger = {\n    error: console.error,\n    warn: console.warn,\n    info: console.info,\n    verbose: () => { },\n    debug: console.debug,\n};\nconst infoConsoleLogger = {\n    error: console.error,\n    warn: console.warn,\n    info: console.info,\n    verbose: () => { },\n    debug: () => { },\n};\nconst verboseConsoleLogger = {\n    error: console.error,\n    warn: console.warn,\n    info: console.info,\n    verbose: console.trace,\n    debug: console.debug,\n};\nconst warningConsoleLogger = {\n    error: console.error,\n    warn: console.warn,\n    info: () => { },\n    verbose: () => { },\n    debug: () => { },\n};\n/** A logger implementation that does nothing */\nconst nullLogger = {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    error: function (message, ...optionalParams) { },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    warn: function (message, ...optionalParams) { },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    info: function (message, ...optionalParams) { },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    verbose: function (message, ...optionalParams) { },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    debug: function (message, ...optionalParams) { },\n};\n\nexport { consoleLogger, infoConsoleLogger, nullLogger, verboseConsoleLogger, warningConsoleLogger };\n//# sourceMappingURL=logging.mjs.map\n","import { isNode } from '../util.mjs';\nimport { nullLogger, consoleLogger } from './logging.mjs';\n\n/** Updatable AlgoKit config */\nclass UpdatableConfig {\n    get populateAppCallResources() {\n        return this.config.populateAppCallResources;\n    }\n    get logger() {\n        return this.config.logger;\n    }\n    get debug() {\n        return this.config.debug;\n    }\n    get projectRoot() {\n        return this.config.projectRoot;\n    }\n    get traceAll() {\n        return this.config.traceAll;\n    }\n    get traceBufferSizeMb() {\n        return this.config.traceBufferSizeMb;\n    }\n    get maxSearchDepth() {\n        return this.config.maxSearchDepth;\n    }\n    /**\n     * Returns the current logger, or the null logger if true is passed in to `returnNullLogger`\n     * @param returnNullLogger Whether or not to return the null logger\n     * @returns The requested logger\n     */\n    getLogger(returnNullLogger) {\n        if (returnNullLogger) {\n            return nullLogger;\n        }\n        return this.logger;\n    }\n    /**\n     * Temporarily run with debug set to true.\n     * @param lambda A lambda expression with code to run with debug config set to true\n     */\n    withDebug(lambda) {\n        const original = this.config.debug;\n        try {\n            this.config.debug = true;\n            lambda();\n        }\n        finally {\n            this.config.debug = original;\n        }\n    }\n    constructor() {\n        this.config = {\n            logger: consoleLogger,\n            debug: false,\n            projectRoot: null,\n            traceAll: false,\n            traceBufferSizeMb: 256,\n            maxSearchDepth: 10,\n            populateAppCallResources: false,\n        };\n        if (isNode()) {\n            this.configureProjectRoot();\n        }\n    }\n    /**\n     * Configures the project root by searching for a specific file within a depth limit.\n     * This is only supported in a Node environment.\n     */\n    async configureProjectRoot() {\n        if (!isNode()) {\n            throw new Error('`configureProjectRoot` can only be called in Node.js environment.');\n        }\n        const fs = await import('fs');\n        const path = await import('path');\n        const _dirname = await import('path').then(async (path) => path.dirname(await import('url').then((url) => url.fileURLToPath(import.meta.url))));\n        if (!_dirname) {\n            return;\n        }\n        let currentPath = path.resolve(_dirname);\n        for (let i = 0; i < this.config.maxSearchDepth; i++) {\n            if (fs.existsSync(`${currentPath}/.algokit.toml`)) {\n                this.config.projectRoot = currentPath;\n                break;\n            }\n            currentPath = path.dirname(currentPath);\n        }\n    }\n    /**\n     * Update the AlgoKit configuration with your own configuration settings\n     * @param newConfig Partial or complete config to replace\n     */\n    configure(newConfig) {\n        this.config = { ...this.config, ...newConfig };\n    }\n}\n\nexport { UpdatableConfig };\n//# sourceMappingURL=config.mjs.map\n","import { UpdatableConfig } from './types/config.mjs';\n\n/** The AlgoKit config. To update it use the configure method. */\nconst Config = new UpdatableConfig();\n\nexport { Config };\n//# sourceMappingURL=config.mjs.map\n","import algosdk from 'algosdk';\n\nvar modelsv2 = algosdk.modelsv2;\n/**\n * Performs a simulation of the transactions loaded into the given AtomicTransactionComposer.\n * @param atc The AtomicTransactionComposer with transaction(s) loaded.\n * @param algod An Algod client to perform the simulation.\n * @returns The simulation result, which includes various details about how the transactions would be processed.\n */\nasync function performAtomicTransactionComposerSimulate(atc, algod) {\n    const unsignedTransactionsSigners = atc.buildGroup();\n    const decodedSignedTransactions = unsignedTransactionsSigners.map((ts) => algosdk.encodeUnsignedSimulateTransaction(ts.txn));\n    const simulateRequest = new modelsv2.SimulateRequest({\n        allowEmptySignatures: true,\n        allowMoreLogging: true,\n        execTraceConfig: new modelsv2.SimulateTraceConfig({\n            enable: true,\n            scratchChange: true,\n            stackChange: true,\n            stateChange: true,\n        }),\n        txnGroups: [\n            new modelsv2.SimulateRequestTransactionGroup({\n                txns: decodedSignedTransactions.map((txn) => algosdk.decodeObj(txn)),\n            }),\n        ],\n    });\n    const simulateResult = await algod.simulateTransactions(simulateRequest).do();\n    return simulateResult;\n}\n\nexport { performAtomicTransactionComposerSimulate };\n//# sourceMappingURL=perform-atomic-transaction-composer-simulate.mjs.map\n","import { Config } from '../config.mjs';\nimport { performAtomicTransactionComposerSimulate } from '../transaction/perform-atomic-transaction-composer-simulate.mjs';\nimport { isNode } from '../util.mjs';\n\nconst TRACES_FILE_EXT = '.trace.avm.json';\nconst DEBUG_TRACES_DIR = 'debug_traces';\n/**\n * This function simulates the atomic transactions using the provided `AtomicTransactionComposer` object and `Algodv2` object,\n * and persists the simulation response to an AlgoKit AVM Debugger compliant JSON file.\n *\n * @param param0 The parameters to control the simulation and persistence.\n *\n * @returns The simulation result, which includes various details about how the transactions would be processed.\n *\n * @example\n * const atc = new AtomicTransactionComposer();\n * const algod = new algosdk.Algodv2(token, server, port);\n * const projectRoot = '/path/to/project';\n * const bufferSizeMb = 10;\n *\n * const result = await simulateAndPersistResponse({ atc, projectRoot, algod, bufferSizeMb });\n * console.log(result);\n */\nasync function simulateAndPersistResponse({ atc, projectRoot, algod, bufferSizeMb }) {\n    if (!isNode()) {\n        throw new Error('Sourcemaps can only be persisted in Node.js environment.');\n    }\n    const fs = await import('fs');\n    const path = await import('path');\n    try {\n        const atcToSimulate = atc.clone();\n        const simulateResult = await performAtomicTransactionComposerSimulate(atcToSimulate, algod);\n        const txnGroups = simulateResult.txnGroups;\n        const txnTypesCount = txnGroups.reduce((acc, txnGroup) => {\n            const txnType = txnGroup.txnResults[0].txnResult.txn.txn.type;\n            acc[txnType] = (acc[txnType] || 0) + 1;\n            return acc;\n        }, {});\n        const txnTypesStr = Object.entries(txnTypesCount)\n            .map(([type, count]) => `${count}#${type}`)\n            .join('_');\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '');\n        const outputRootDir = path.join(projectRoot, DEBUG_TRACES_DIR);\n        const outputFileName = `${timestamp}_lr${simulateResult.lastRound}_${txnTypesStr}${TRACES_FILE_EXT}`;\n        const outputFilePath = path.join(outputRootDir, outputFileName);\n        try {\n            await fs.promises.access(path.dirname(outputFilePath));\n        }\n        catch (error) {\n            const err = error;\n            if (err.code === 'ENOENT') {\n                await fs.promises.mkdir(path.dirname(outputFilePath), { recursive: true });\n            }\n            else {\n                throw err;\n            }\n        }\n        // cleanup old files if buffer size is exceeded\n        let totalSize = (await Promise.all((await fs.promises.readdir(outputRootDir)).map(async (file) => (await fs.promises.stat(path.join(outputRootDir, file))).size))).reduce((a, b) => a + b, 0);\n        if (totalSize > bufferSizeMb * 1024 * 1024) {\n            const sortedFiles = (await fs.promises.readdir(outputRootDir)).map(async (file) => {\n                const stats = await fs.promises.stat(path.join(outputRootDir, file));\n                return { file, mtime: stats.mtime };\n            });\n            // Since map returns an array of promises, we need to await all of them\n            const resolvedFiles = await Promise.all(sortedFiles);\n            resolvedFiles.sort((a, b) => a.mtime.getTime() - b.mtime.getTime());\n            while (totalSize > bufferSizeMb * 1024 * 1024) {\n                const oldestFilePromise = sortedFiles.shift();\n                if (oldestFilePromise) {\n                    const oldestFile = await oldestFilePromise;\n                    const stats = await fs.promises.stat(path.join(outputRootDir, oldestFile.file));\n                    totalSize -= stats.size;\n                    await fs.promises.unlink(path.join(outputRootDir, oldestFile.file));\n                }\n            }\n        }\n        await fs.promises.writeFile(outputFilePath, JSON.stringify(simulateResult.get_obj_for_encoding(), null, 2));\n        return simulateResult;\n    }\n    catch (error) {\n        const err = error instanceof Error ? error : new Error(String(error));\n        Config.getLogger().error(`Failed to simulate and persist avm traces: ${err.stack ?? err.message ?? err}.`);\n        throw err;\n    }\n}\n\nexport { simulateAndPersistResponse };\n//# sourceMappingURL=simulate-and-persist-response.mjs.map\n","import algosdk from 'algosdk';\nimport { Buffer } from 'buffer';\nimport { Config } from '../config.mjs';\nimport { simulateAndPersistResponse } from '../debugging/simulate-and-persist-response.mjs';\nimport { toNumber } from '../util.mjs';\nimport { performAtomicTransactionComposerSimulate } from './perform-atomic-transaction-composer-simulate.mjs';\n\nvar AtomicTransactionComposer = algosdk.AtomicTransactionComposer;\nvar modelsv2 = algosdk.modelsv2;\nconst MAX_TRANSACTION_GROUP_SIZE = 16;\nconst MAX_APP_CALL_FOREIGN_REFERENCES = 8;\nconst MAX_APP_CALL_ACCOUNT_REFERENCES = 4;\n/** Encodes a transaction note into a byte array ready to be included in an Algorand transaction.\n *\n * @param note The transaction note\n * @returns the transaction note ready for inclusion in a transaction\n *\n *  Case on the value of `data` this either be:\n *   * `null` | `undefined`: `undefined`\n *   * `string`: The string value\n *   * Uint8Array: passthrough\n *   * Arc2TransactionNote object: ARC-0002 compatible transaction note\n *   * Else: The object/value converted into a JSON string representation\n */\nfunction encodeTransactionNote(note) {\n    if (note == null || typeof note === 'undefined') {\n        return undefined;\n    }\n    else if (typeof note === 'object' && note.constructor === Uint8Array) {\n        return note;\n    }\n    else if (typeof note === 'object' && 'dAppName' in note) {\n        const arc2Payload = `${note.dAppName}:${note.format}${typeof note.data === 'string' ? note.data : JSON.stringify(note.data)}`;\n        const encoder = new TextEncoder();\n        return encoder.encode(arc2Payload);\n    }\n    else {\n        const n = typeof note === 'string' ? note : JSON.stringify(note);\n        const encoder = new TextEncoder();\n        return encoder.encode(n);\n    }\n}\n/** Encodes a transaction lease into a 32-byte array ready to be included in an Algorand transaction.\n *\n * @param lease The transaction lease as a string or binary array or null/undefined if there is no lease\n * @returns the transaction lease ready for inclusion in a transaction or `undefined` if there is no lease\n * @throws if the length of the data is > 32 bytes or empty\n * @example algokit.encodeLease('UNIQUE_ID')\n * @example algokit.encodeLease(new Uint8Array([1, 2, 3]))\n */\nfunction encodeLease(lease) {\n    if (lease === null || typeof lease === 'undefined') {\n        return undefined;\n    }\n    else if (typeof lease === 'object' && lease.constructor === Uint8Array) {\n        if (lease.length === 0 || lease.length > 32) {\n            throw new Error(`Received invalid lease; expected something with length between 1 and 32, but received bytes with length ${lease.length}`);\n        }\n        if (lease.length === 32)\n            return lease;\n        const lease32 = new Uint8Array(32);\n        lease32.set(lease, 0);\n        return lease32;\n    }\n    else if (typeof lease === 'string') {\n        if (lease.length === 0 || lease.length > 32) {\n            throw new Error(`Received invalid lease; expected something with length between 1 and 32, but received '${lease}' with length ${lease.length}`);\n        }\n        const encoder = new TextEncoder();\n        const lease32 = new Uint8Array(32);\n        lease32.set(encoder.encode(lease), 0);\n        return lease32;\n    }\n    else {\n        throw new Error(`Unknown lease type received of ${typeof lease}`);\n    }\n}\n/**\n * Returns the public address of the given transaction sender.\n * @param sender A transaction sender\n * @returns The public address\n */\nconst getSenderAddress = function (sender) {\n    return typeof sender === 'string' ? sender : 'addr' in sender ? sender.addr : sender.address();\n};\n/**\n * Given a transaction in a variety of supported formats, returns a TransactionWithSigner object ready to be passed to an\n * AtomicTransactionComposer's addTransaction method.\n * @param transaction One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the\n * signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by\n * one of algokit utils' helpers (signer is obtained from the defaultSender parameter)\n * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not\n * include a signer.\n * @returns A TransactionWithSigner object.\n */\nconst getTransactionWithSigner = async (transaction, defaultSender) => {\n    if ('txn' in transaction)\n        return transaction;\n    if (defaultSender === undefined)\n        throw new Error('Default sender must be provided when passing in a transaction object that does not contain its own signer');\n    return transaction instanceof Promise\n        ? {\n            txn: (await transaction).transaction,\n            signer: getSenderTransactionSigner(defaultSender),\n        }\n        : 'transaction' in transaction\n            ? {\n                txn: transaction.transaction,\n                signer: getSenderTransactionSigner(transaction.signer),\n            }\n            : {\n                txn: transaction,\n                signer: getSenderTransactionSigner(defaultSender),\n            };\n};\nconst memoize = (fn) => {\n    const cache = new Map();\n    const cached = function (val) {\n        return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);\n    };\n    cached.cache = cache;\n    return cached;\n};\n/**\n * Returns a `TransactionSigner` for the given transaction sender.\n * This function has memoization, so will return the same transaction signer for a given sender.\n * @param sender A transaction sender\n * @returns A transaction signer\n */\nconst getSenderTransactionSigner = memoize(function (sender) {\n    return 'signer' in sender\n        ? sender.signer\n        : 'lsig' in sender\n            ? algosdk.makeLogicSigAccountTransactionSigner(sender)\n            : algosdk.makeBasicAccountTransactionSigner(sender);\n});\n/**\n * Signs a single transaction by the given signer.\n * @param transaction The transaction to sign\n * @param signer The signer to sign\n * @returns The signed transaction as a `Uint8Array`\n */\nconst signTransaction = async (transaction, signer) => {\n    return 'sk' in signer\n        ? transaction.signTxn(signer.sk)\n        : 'lsig' in signer\n            ? algosdk.signLogicSigTransactionObject(transaction, signer).blob\n            : 'sign' in signer\n                ? signer.sign(transaction)\n                : (await signer.signer([transaction], [0]))[0];\n};\n/** Prepares a transaction for sending and then (if instructed) signs and sends the given transaction to the chain.\n *\n * @param send The details for the transaction to prepare/send, including:\n *   * `transaction`: The unsigned transaction\n *   * `from`: The account to sign the transaction with: either an account with private key loaded or a logic signature account\n *   * `config`: The sending configuration for this transaction\n * @param algod An algod client\n *\n * @returns An object with transaction (`transaction`) and (if `skipWaiting` is `false` or `undefined`) confirmation (`confirmation`)\n */\nconst sendTransaction = async function (send, algod) {\n    const { transaction, from, sendParams } = send;\n    const { skipSending, skipWaiting, fee, maxFee, suppressLog, maxRoundsToWaitForConfirmation, atc } = sendParams ?? {};\n    controlFees(transaction, { fee, maxFee });\n    if (atc) {\n        atc.addTransaction({ txn: transaction, signer: getSenderTransactionSigner(from) });\n        return { transaction };\n    }\n    if (skipSending) {\n        return { transaction };\n    }\n    let txnToSend = transaction;\n    const populateResources = sendParams?.populateAppCallResources ?? Config.populateAppCallResources;\n    // Populate  resources if the transaction is an appcall and populateAppCallResources wasn't explicitly set to false\n    // NOTE: Temporary false by default until this algod bug is fixed: https://github.com/algorand/go-algorand/issues/5914\n    if (txnToSend.type === algosdk.TransactionType.appl && populateResources) {\n        const newAtc = new AtomicTransactionComposer();\n        newAtc.addTransaction({ txn: txnToSend, signer: getSenderTransactionSigner(from) });\n        const packed = await populateAppCallResources(newAtc, algod);\n        txnToSend = packed.buildGroup()[0].txn;\n    }\n    const signedTransaction = await signTransaction(txnToSend, from);\n    await algod.sendRawTransaction(signedTransaction).do();\n    Config.getLogger(suppressLog).verbose(`Sent transaction ID ${txnToSend.txID()} ${txnToSend.type} from ${getSenderAddress(from)}`);\n    let confirmation = undefined;\n    if (!skipWaiting) {\n        confirmation = await waitForConfirmation(txnToSend.txID(), maxRoundsToWaitForConfirmation ?? 5, algod);\n    }\n    return { transaction: txnToSend, confirmation };\n};\n/**\n * Get all of the unamed resources used by the group in the given ATC\n *\n * @param algod The algod client to use for the simulation\n * @param atc The ATC containing the txn group\n * @returns The unnamed resources accessed by the group and by each transaction in the group\n */\nasync function getUnnamedAppCallResourcesAccessed(atc, algod) {\n    const simReq = new algosdk.modelsv2.SimulateRequest({\n        txnGroups: [],\n        allowUnnamedResources: true,\n        allowEmptySignatures: true,\n    });\n    const signerWithFixedSgnr = async (txns, indexes) => {\n        const stxns = await algosdk.makeEmptyTransactionSigner()(txns, indexes);\n        return Promise.all(stxns.map(async (stxn) => {\n            const decodedStxn = algosdk.decodeSignedTransaction(stxn);\n            const sender = algosdk.encodeAddress(decodedStxn.txn.from.publicKey);\n            const authAddr = (await algod.accountInformation(sender).do())['auth-addr'];\n            const stxnObj = { txn: decodedStxn.txn.get_obj_for_encoding() };\n            if (authAddr !== undefined) {\n                stxnObj.sgnr = Buffer.from(algosdk.decodeAddress(authAddr).publicKey);\n            }\n            return algosdk.encodeObj(stxnObj);\n        }));\n    };\n    const emptySignerAtc = atc.clone();\n    emptySignerAtc['transactions'].forEach((t) => {\n        t.signer = signerWithFixedSgnr;\n    });\n    const result = await emptySignerAtc.simulate(algod, simReq);\n    const groupResponse = result.simulateResponse.txnGroups[0];\n    if (groupResponse.failureMessage) {\n        throw Error(`Error during resource population simulation in transaction ${groupResponse.failedAt}: ${groupResponse.failureMessage}`);\n    }\n    return {\n        group: groupResponse.unnamedResourcesAccessed,\n        txns: groupResponse.txnResults.map(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (t) => t.unnamedResourcesAccessed),\n    };\n}\n/**\n * Take an existing Atomic Transaction Composer and return a new one with the required\n *  app call resources packed into it\n *\n * @param algod The algod client to use for the simulation\n * @param atc The ATC containing the txn group\n * @returns A new ATC with the resources packed into the transactions\n *\n * @privateRemarks\n *\n * This entire function will eventually be implemented in simulate upstream in algod. The simulate endpoint will return\n * an array of refference arrays for each transaction, so this eventually will eventually just call simulate and set the\n * reference arrays in the transactions to the reference arrays returned by simulate.\n *\n * See https://github.com/algorand/go-algorand/pull/5684\n *\n */\nasync function populateAppCallResources(atc, algod) {\n    const unnamedResourcesAccessed = await getUnnamedAppCallResourcesAccessed(atc, algod);\n    const group = atc.buildGroup();\n    unnamedResourcesAccessed.txns.forEach((r, i) => {\n        if (r === undefined)\n            return;\n        if (r.boxes || r.extraBoxRefs)\n            throw Error('Unexpected boxes at the transaction level');\n        if (r.appLocals)\n            throw Error('Unexpected app local at the transaction level');\n        if (r.assetHoldings)\n            throw Error('Unexpected asset holding at the transaction level');\n        // Do accounts first because the account limit is 4\n        r.accounts?.forEach((a) => {\n            group[i].txn.appAccounts = [...(group[i].txn.appAccounts ?? []), algosdk.decodeAddress(a)];\n        });\n        r.apps?.forEach((a) => {\n            group[i].txn.appForeignApps = [...(group[i].txn.appForeignApps ?? []), Number(a)];\n        });\n        r.assets?.forEach((a) => {\n            group[i].txn.appForeignAssets = [...(group[i].txn.appForeignAssets ?? []), Number(a)];\n        });\n        const accounts = group[i].txn.appAccounts?.length || 0;\n        if (accounts > MAX_APP_CALL_ACCOUNT_REFERENCES)\n            throw Error(`Account reference limit of ${MAX_APP_CALL_ACCOUNT_REFERENCES} exceeded in transaction ${i}`);\n        const assets = group[i].txn.appForeignAssets?.length || 0;\n        const apps = group[i].txn.appForeignApps?.length || 0;\n        const boxes = group[i].txn.boxes?.length || 0;\n        if (accounts + assets + apps + boxes > MAX_APP_CALL_FOREIGN_REFERENCES) {\n            throw Error(`Resource reference limit of ${MAX_APP_CALL_FOREIGN_REFERENCES} exceeded in transaction ${i}`);\n        }\n    });\n    const populateGroupResource = (txns, reference, type) => {\n        const isApplBelowLimit = (t) => {\n            if (t.txn.type !== algosdk.TransactionType.appl)\n                return false;\n            const accounts = t.txn.appAccounts?.length || 0;\n            const assets = t.txn.appForeignAssets?.length || 0;\n            const apps = t.txn.appForeignApps?.length || 0;\n            const boxes = t.txn.boxes?.length || 0;\n            return accounts + assets + apps + boxes < MAX_APP_CALL_FOREIGN_REFERENCES;\n        };\n        // If this is a asset holding or app local, first try to find a transaction that already has the account available\n        if (type === 'assetHolding' || type === 'appLocal') {\n            const { account } = reference;\n            let txnIndex = txns.findIndex((t) => {\n                if (!isApplBelowLimit(t))\n                    return false;\n                return (\n                // account is in the foreign accounts array\n                t.txn.appAccounts?.map((a) => algosdk.encodeAddress(a.publicKey)).includes(account) ||\n                    // account is available as an app account\n                    t.txn.appForeignApps?.map((a) => algosdk.getApplicationAddress(a)).includes(account) ||\n                    // account is available since it's in one of the fields\n                    Object.values(t.txn)\n                        .map((f) => JSON.stringify(f))\n                        .includes(JSON.stringify(algosdk.decodeAddress(account))));\n            });\n            if (txnIndex > -1) {\n                if (type === 'assetHolding') {\n                    const { asset } = reference;\n                    txns[txnIndex].txn.appForeignAssets = [...(txns[txnIndex].txn.appForeignAssets ?? []), Number(asset)];\n                }\n                else {\n                    const { app } = reference;\n                    txns[txnIndex].txn.appForeignApps = [...(txns[txnIndex].txn.appForeignApps ?? []), Number(app)];\n                }\n                return;\n            }\n            // Now try to find a txn that already has that app or asset available\n            txnIndex = txns.findIndex((t) => {\n                if (!isApplBelowLimit(t))\n                    return false;\n                // check if there is space in the accounts array\n                if ((t.txn.appAccounts?.length || 0) >= MAX_APP_CALL_ACCOUNT_REFERENCES)\n                    return false;\n                if (type === 'assetHolding') {\n                    const { asset } = reference;\n                    return t.txn.appForeignAssets?.includes(Number(asset));\n                }\n                else {\n                    const { app } = reference;\n                    return t.txn.appForeignApps?.includes(Number(app)) || t.txn.appIndex === Number(app);\n                }\n            });\n            if (txnIndex > -1) {\n                const { account } = reference;\n                txns[txnIndex].txn.appAccounts = [...(txns[txnIndex].txn.appAccounts ?? []), algosdk.decodeAddress(account)];\n                return;\n            }\n        }\n        // If this is a box, first try to find a transaction that already has the app available\n        if (type === 'box') {\n            const { app, name } = reference;\n            const txnIndex = txns.findIndex((t) => {\n                if (!isApplBelowLimit(t))\n                    return false;\n                // If the app is in the foreign array OR the app being called, then we know it's available\n                return t.txn.appForeignApps?.includes(Number(app)) || t.txn.appIndex === Number(app);\n            });\n            if (txnIndex > -1) {\n                txns[txnIndex].txn.boxes = [...(txns[txnIndex].txn.boxes ?? []), { appIndex: Number(app), name }];\n                return;\n            }\n        }\n        // Find the txn index to put the reference(s)\n        const txnIndex = txns.findIndex((t) => {\n            if (t.txn.type !== algosdk.TransactionType.appl)\n                return false;\n            const accounts = t.txn.appAccounts?.length || 0;\n            if (type === 'account')\n                return accounts < MAX_APP_CALL_ACCOUNT_REFERENCES;\n            const assets = t.txn.appForeignAssets?.length || 0;\n            const apps = t.txn.appForeignApps?.length || 0;\n            const boxes = t.txn.boxes?.length || 0;\n            // If we're adding local state or asset holding, we need space for the acocunt and the other reference\n            if (type === 'assetHolding' || type === 'appLocal') {\n                return accounts + assets + apps + boxes < MAX_APP_CALL_FOREIGN_REFERENCES - 1 && accounts < MAX_APP_CALL_ACCOUNT_REFERENCES;\n            }\n            // If we're adding a box, we need space for both the box ref and the app ref\n            if (type === 'box' && BigInt(reference.app) !== BigInt(0)) {\n                return accounts + assets + apps + boxes < MAX_APP_CALL_FOREIGN_REFERENCES - 1;\n            }\n            return accounts + assets + apps + boxes < MAX_APP_CALL_FOREIGN_REFERENCES;\n        });\n        if (txnIndex === -1) {\n            throw Error('No more transactions below reference limit. Add another app call to the group.');\n        }\n        if (type === 'account') {\n            txns[txnIndex].txn.appAccounts = [...(txns[txnIndex].txn.appAccounts ?? []), algosdk.decodeAddress(reference)];\n        }\n        else if (type === 'app') {\n            txns[txnIndex].txn.appForeignApps = [...(txns[txnIndex].txn.appForeignApps ?? []), Number(reference)];\n        }\n        else if (type === 'box') {\n            const { app, name } = reference;\n            txns[txnIndex].txn.boxes = [...(txns[txnIndex].txn.boxes ?? []), { appIndex: Number(app), name }];\n            if (app.toString() !== '0') {\n                txns[txnIndex].txn.appForeignApps = [...(txns[txnIndex].txn.appForeignApps ?? []), Number(app)];\n            }\n        }\n        else if (type === 'assetHolding') {\n            const { asset, account } = reference;\n            txns[txnIndex].txn.appForeignAssets = [...(txns[txnIndex].txn.appForeignAssets ?? []), Number(asset)];\n            txns[txnIndex].txn.appAccounts = [...(txns[txnIndex].txn.appAccounts ?? []), algosdk.decodeAddress(account)];\n        }\n        else if (type === 'appLocal') {\n            const { app, account } = reference;\n            txns[txnIndex].txn.appAccounts = [...(txns[txnIndex].txn.appAccounts ?? []), algosdk.decodeAddress(account)];\n            txns[txnIndex].txn.appForeignApps = [...(txns[txnIndex].txn.appForeignApps ?? []), Number(app)];\n        }\n        else if (type === 'asset') {\n            txns[txnIndex].txn.appForeignAssets = [...(txns[txnIndex].txn.appForeignAssets ?? []), Number(reference)];\n        }\n    };\n    const g = unnamedResourcesAccessed.group;\n    if (g) {\n        // Do cross-reference resources first because they are the most restrictive in terms\n        // of which transactions can be used\n        g.appLocals?.forEach((a) => {\n            populateGroupResource(group, a, 'appLocal');\n            // Remove resources from the group if we're adding them here\n            g.accounts = g.accounts?.filter((acc) => acc !== a.account);\n            g.apps = g.apps?.filter((app) => BigInt(app) !== BigInt(a.app));\n        });\n        g.assetHoldings?.forEach((a) => {\n            populateGroupResource(group, a, 'assetHolding');\n            // Remove resources from the group if we're adding them here\n            g.accounts = g.accounts?.filter((acc) => acc !== a.account);\n            g.assets = g.assets?.filter((asset) => BigInt(asset) !== BigInt(a.asset));\n        });\n        // Do accounts next because the account limit is 4\n        g.accounts?.forEach((a) => {\n            populateGroupResource(group, a, 'account');\n        });\n        g.boxes?.forEach((b) => {\n            populateGroupResource(group, b, 'box');\n            // Remove apps as resource from the group if we're adding it here\n            g.apps = g.apps?.filter((app) => BigInt(app) !== BigInt(b.app));\n        });\n        g.assets?.forEach((a) => {\n            populateGroupResource(group, a, 'asset');\n        });\n        g.apps?.forEach((a) => {\n            populateGroupResource(group, a, 'app');\n        });\n        if (g.extraBoxRefs) {\n            for (let i = 0; i < g.extraBoxRefs; i += 1) {\n                const ref = new algosdk.modelsv2.BoxReference({ app: 0, name: new Uint8Array(0) });\n                populateGroupResource(group, ref, 'box');\n            }\n        }\n    }\n    const newAtc = new algosdk.AtomicTransactionComposer();\n    group.forEach((t) => {\n        // eslint-disable-next-line no-param-reassign\n        t.txn.group = undefined;\n        newAtc.addTransaction(t);\n    });\n    newAtc['methodCalls'] = atc['methodCalls'];\n    return newAtc;\n}\n/**\n * Signs and sends transactions that have been collected by an `AtomicTransactionComposer`.\n * @param atcSend The parameters controlling the send, including:\n *  * `atc` The `AtomicTransactionComposer`\n *  * `sendParams` The parameters to control the send behaviour\n * @param algod An algod client\n * @returns An object with transaction IDs, transactions, group transaction ID (`groupTransactionId`) if more than 1 transaction sent, and (if `skipWaiting` is `false` or unset) confirmation (`confirmation`)\n */\nconst sendAtomicTransactionComposer = async function (atcSend, algod) {\n    const { atc: givenAtc, sendParams } = atcSend;\n    let atc;\n    // const hasAppCalls = () =>\n    //   givenAtc\n    //     .buildGroup()\n    //     .map((t) => t.txn.type)\n    //     .includes(algosdk.TransactionType.appl)\n    atc = givenAtc;\n    try {\n        // If populateAppCallResources is true OR if populateAppCallResources is undefined and there are app calls, then populate resources\n        // NOTE: Temporary false by default until this algod bug is fixed: https://github.com/algorand/go-algorand/issues/5914\n        const populateResources = sendParams?.populateAppCallResources ?? Config.populateAppCallResources;\n        if (populateResources) {\n            atc = await populateAppCallResources(givenAtc, algod);\n        }\n        const transactionsWithSigner = atc.buildGroup();\n        const transactionsToSend = transactionsWithSigner.map((t) => {\n            return t.txn;\n        });\n        let groupId = undefined;\n        if (transactionsToSend.length > 1) {\n            groupId = transactionsToSend[0].group ? Buffer.from(transactionsToSend[0].group).toString('base64') : '';\n            Config.getLogger(sendParams?.suppressLog).verbose(`Sending group of ${transactionsToSend.length} transactions (${groupId})`, {\n                transactionsToSend,\n            });\n            Config.getLogger(sendParams?.suppressLog).debug(`Transaction IDs (${groupId})`, transactionsToSend.map((t) => t.txID()));\n        }\n        if (Config.debug && Config.projectRoot && Config.traceAll) {\n            // Dump the traces to a file for use with AlgoKit AVM debugger\n            await simulateAndPersistResponse({\n                atc,\n                projectRoot: Config.projectRoot,\n                algod,\n                bufferSizeMb: Config.traceBufferSizeMb,\n            });\n        }\n        const result = await atc.execute(algod, sendParams?.maxRoundsToWaitForConfirmation ?? 5);\n        if (transactionsToSend.length > 1) {\n            Config.getLogger(sendParams?.suppressLog).verbose(`Group transaction (${groupId}) sent with ${transactionsToSend.length} transactions`);\n        }\n        else {\n            Config.getLogger(sendParams?.suppressLog).verbose(`Sent transaction ID ${transactionsToSend[0].txID()} ${transactionsToSend[0].type} from ${algosdk.encodeAddress(transactionsToSend[0].from.publicKey)}`);\n        }\n        let confirmations = undefined;\n        if (!sendParams?.skipWaiting) {\n            confirmations = await Promise.all(transactionsToSend.map(async (t) => modelsv2.PendingTransactionResponse.from_obj_for_encoding(await algod.pendingTransactionInformation(t.txID()).do())));\n        }\n        return {\n            groupId,\n            confirmations,\n            txIds: transactionsToSend.map((t) => t.txID()),\n            transactions: transactionsToSend,\n            returns: result.methodResults.map((r) => ({\n                decodeError: r.decodeError,\n                returnValue: r.returnValue,\n                rawReturnValue: r.rawReturnValue,\n            })),\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    }\n    catch (e) {\n        // Remove headers as it doesn't have anything useful.\n        delete e.response?.headers;\n        if (Config.debug && typeof e === 'object') {\n            e.traces = [];\n            Config.logger.error('Received error executing Atomic Transaction Composer and debug flag enabled; attempting simulation to get more information', e);\n            let simulate = undefined;\n            if (Config.debug && Config.projectRoot && !Config.traceAll) {\n                // Dump the traces to a file for use with AlgoKit AVM debugger\n                // Checks for false on traceAll because it should have been already\n                // executed above\n                simulate = await simulateAndPersistResponse({\n                    atc,\n                    projectRoot: Config.projectRoot,\n                    algod,\n                    bufferSizeMb: Config.traceBufferSizeMb,\n                });\n            }\n            else {\n                simulate = await performAtomicTransactionComposerSimulate(atc, algod);\n            }\n            if (simulate && simulate.txnGroups[0].failedAt) {\n                for (const txn of simulate.txnGroups[0].txnResults) {\n                    e.traces.push({\n                        trace: txn.execTrace?.get_obj_for_encoding(),\n                        appBudget: txn.appBudgetConsumed,\n                        logicSigBudget: txn.logicSigBudgetConsumed,\n                        logs: txn.txnResult.logs,\n                        message: simulate.txnGroups[0].failureMessage,\n                    });\n                }\n            }\n        }\n        else {\n            Config.logger.error('Received error executing Atomic Transaction Composer, for more information enable the debug flag', e);\n        }\n        throw e;\n    }\n};\n/**\n * Performs a dry run of the transactions loaded into the given AtomicTransactionComposer`\n * @param atc The AtomicTransactionComposer` with transaction(s) loaded\n * @param algod An Algod client\n * @returns The dryrun result\n */\nasync function performAtomicTransactionComposerDryrun(atc, algod) {\n    const signedTransactions = await atc.gatherSignatures();\n    const txns = signedTransactions.map((t) => {\n        return algosdk.decodeSignedTransaction(t);\n    });\n    const dryrun = await algosdk.createDryrun({ client: algod, txns });\n    return new algosdk.DryrunResult(await algod.dryrun(dryrun).do());\n}\n/**\n * Signs and sends a group of [up to 16](https://developer.algorand.org/docs/get-details/atomic_transfers/#create-transactions) transactions to the chain\n *\n * @param groupSend The group details to send, with:\n *   * `transactions`: The array of transactions to send along with their signing account\n *   * `sendParams`: The parameters to dictate how the group is sent\n * @param algod An algod client\n * @returns An object with transaction IDs, transactions, group transaction ID (`groupTransactionId`) if more than 1 transaction sent, and (if `skipWaiting` is `false` or unset) confirmation (`confirmation`)\n */\nconst sendGroupOfTransactions = async function (groupSend, algod) {\n    const { transactions, signer, sendParams } = groupSend;\n    const defaultTransactionSigner = signer ? getSenderTransactionSigner(signer) : undefined;\n    const transactionsWithSigner = await Promise.all(transactions.map(async (t) => {\n        if ('signer' in t)\n            return {\n                txn: t.transaction,\n                signer: getSenderTransactionSigner(t.signer),\n                sender: t.signer,\n            };\n        const txn = 'then' in t ? (await t).transaction : t;\n        if (!signer) {\n            throw new Error(`Attempt to send transaction ${txn.txID()} as part of a group transaction, but no signer parameter was provided.`);\n        }\n        return {\n            txn,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            signer: defaultTransactionSigner,\n            sender: signer,\n        };\n    }));\n    const atc = new AtomicTransactionComposer();\n    transactionsWithSigner.forEach((txn) => atc.addTransaction(txn));\n    return (await sendAtomicTransactionComposer({ atc, sendParams }, algod));\n};\n/**\n * Wait until the transaction is confirmed or rejected, or until `timeout`\n * number of rounds have passed.\n *\n * @param algod An algod client\n * @param transactionId The transaction ID to wait for\n * @param maxRoundsToWait Maximum number of rounds to wait\n *\n * @return Pending transaction information\n * @throws Throws an error if the transaction is not confirmed or rejected in the next `timeout` rounds\n */\nconst waitForConfirmation = async function (transactionId, maxRoundsToWait, algod) {\n    if (maxRoundsToWait < 0) {\n        throw new Error(`Invalid timeout, received ${maxRoundsToWait}, expected > 0`);\n    }\n    // Get current round\n    const status = modelsv2.NodeStatusResponse.from_obj_for_encoding(await algod.status().do());\n    if (status === undefined) {\n        throw new Error('Unable to get node status');\n    }\n    // Loop for up to `timeout` rounds looking for a confirmed transaction\n    const startRound = BigInt(status.lastRound) + 1n;\n    let currentRound = startRound;\n    while (currentRound < startRound + BigInt(maxRoundsToWait)) {\n        try {\n            const pendingInfo = modelsv2.PendingTransactionResponse.from_obj_for_encoding(await algod.pendingTransactionInformation(transactionId).do());\n            if (pendingInfo !== undefined) {\n                const confirmedRound = pendingInfo.confirmedRound;\n                if (confirmedRound && confirmedRound > 0) {\n                    return pendingInfo;\n                }\n                else {\n                    const poolError = pendingInfo.poolError;\n                    if (poolError != null && poolError.length > 0) {\n                        // If there was a pool error, then the transaction has been rejected!\n                        throw new Error(`Transaction ${transactionId} was rejected; pool error: ${poolError}`);\n                    }\n                }\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            if (e.name === 'URLTokenBaseHTTPError') {\n                currentRound++;\n                continue;\n            }\n        }\n        await algod.statusAfterBlock(toNumber(currentRound)).do();\n        currentRound++;\n    }\n    throw new Error(`Transaction ${transactionId} not confirmed after ${maxRoundsToWait} rounds`);\n};\n/**\n * Limit the acceptable fee to a defined amount of µALGOs.\n * This also sets the transaction to be flatFee to ensure the transaction only succeeds at\n * the estimated rate.\n * @param transaction The transaction to cap or suggested params object about to be used to create a transaction\n * @param maxAcceptableFee The maximum acceptable fee to pay\n */\nfunction capTransactionFee(transaction, maxAcceptableFee) {\n    // If a flat fee hasn't already been defined\n    if (!transaction.flatFee) {\n        // Once a transaction has been constructed by algosdk, transaction.fee indicates what the total transaction fee\n        // Will be based on the current suggested fee-per-byte value.\n        if (transaction.fee > maxAcceptableFee.microAlgos) {\n            throw new Error(`Cancelled transaction due to high network congestion fees. Algorand suggested fees would cause this transaction to cost ${transaction.fee} µALGOs. Cap for this transaction is ${maxAcceptableFee.microAlgos} µALGOs.`);\n        }\n        else if (transaction.fee > algosdk.ALGORAND_MIN_TX_FEE) {\n            Config.logger.warn(`Algorand network congestion fees are in effect. This transaction will incur a fee of ${transaction.fee} µALGOs.`);\n        }\n        // Now set the flat on the transaction. Otherwise the network may increase the fee above our cap and perform the transaction.\n        transaction.flatFee = true;\n    }\n}\n/**\n * Allows for control of fees on a `Transaction` or `SuggestedParams` object\n * @param transaction The transaction or suggested params\n * @param feeControl The fee control parameters\n */\nfunction controlFees(transaction, feeControl) {\n    const { fee, maxFee } = feeControl;\n    if (fee) {\n        transaction.fee = fee.microAlgos;\n        transaction.flatFee = true;\n    }\n    if (maxFee !== undefined) {\n        capTransactionFee(transaction, maxFee);\n    }\n    return transaction;\n}\n/**\n * Returns suggested transaction parameters from algod unless some are already provided.\n * @param params Optionally provide parameters to use\n * @param algod Algod algod\n * @returns The suggested transaction parameters\n */\nasync function getTransactionParams(params, algod) {\n    return params ? { ...params } : await algod.getTransactionParams().do();\n}\n/**\n * Returns the array of transactions currently present in the given `AtomicTransactionComposer`\n * @param atc The atomic transaction composer\n * @returns The array of transactions with signers\n */\nfunction getAtomicTransactionComposerTransactions(atc) {\n    try {\n        return atc.clone().buildGroup();\n    }\n    catch {\n        return [];\n    }\n}\n\nexport { MAX_APP_CALL_ACCOUNT_REFERENCES, MAX_APP_CALL_FOREIGN_REFERENCES, MAX_TRANSACTION_GROUP_SIZE, capTransactionFee, controlFees, encodeLease, encodeTransactionNote, getAtomicTransactionComposerTransactions, getSenderAddress, getSenderTransactionSigner, getTransactionParams, getTransactionWithSigner, performAtomicTransactionComposerDryrun, populateAppCallResources, sendAtomicTransactionComposer, sendGroupOfTransactions, sendTransaction, signTransaction, waitForConfirmation };\n//# sourceMappingURL=transaction.mjs.map\n","/** The name of the TEAL template variable for deploy-time immutability control */\nconst UPDATABLE_TEMPLATE_NAME = 'TMPL_UPDATABLE';\n/** The name of the TEAL template variable for deploy-time permanence control */\nconst DELETABLE_TEMPLATE_NAME = 'TMPL_DELETABLE';\n/** The app create/update ARC-2 transaction note prefix */\nconst APP_DEPLOY_NOTE_DAPP = 'ALGOKIT_DEPLOYER';\n/** The maximum number of bytes in a single app code page */\nconst APP_PAGE_MAX_SIZE = 2048;\n/** First 4 bytes of SHA-512/256 hash of \"return\" for retrieving ABI return values */\nconst ABI_RETURN_PREFIX = new Uint8Array([21, 31, 124, 117]);\n/** What action to perform when deploying an app and an update is detected in the TEAL code */\nvar OnUpdate;\n(function (OnUpdate) {\n    /** Fail the deployment */\n    OnUpdate[OnUpdate[\"Fail\"] = 0] = \"Fail\";\n    /** Update the app */\n    OnUpdate[OnUpdate[\"UpdateApp\"] = 1] = \"UpdateApp\";\n    /** Delete the app and create a new one in its place */\n    OnUpdate[OnUpdate[\"ReplaceApp\"] = 2] = \"ReplaceApp\";\n    /** Create a new app */\n    OnUpdate[OnUpdate[\"AppendApp\"] = 3] = \"AppendApp\";\n})(OnUpdate || (OnUpdate = {}));\n/** What action to perform when deploying an app and a breaking schema change is detected */\nvar OnSchemaBreak;\n(function (OnSchemaBreak) {\n    /** Fail the deployment */\n    OnSchemaBreak[OnSchemaBreak[\"Fail\"] = 0] = \"Fail\";\n    /** Delete the app and create a new one in its place */\n    OnSchemaBreak[OnSchemaBreak[\"ReplaceApp\"] = 1] = \"ReplaceApp\";\n    /** Create a new app */\n    OnSchemaBreak[OnSchemaBreak[\"AppendApp\"] = 2] = \"AppendApp\";\n})(OnSchemaBreak || (OnSchemaBreak = {}));\n\nexport { ABI_RETURN_PREFIX, APP_DEPLOY_NOTE_DAPP, APP_PAGE_MAX_SIZE, DELETABLE_TEMPLATE_NAME, OnSchemaBreak, OnUpdate, UPDATABLE_TEMPLATE_NAME };\n//# sourceMappingURL=app.mjs.map\n","import algosdk from 'algosdk';\nimport { Buffer } from 'buffer';\nimport { Config } from './config.mjs';\nimport { getAtomicTransactionComposerTransactions, controlFees, getTransactionParams, encodeTransactionNote, sendAtomicTransactionComposer, getSenderAddress, sendTransaction, encodeLease, getSenderTransactionSigner } from './transaction/transaction.mjs';\nimport { APP_PAGE_MAX_SIZE } from './types/app.mjs';\nimport { toNumber } from './util.mjs';\n\nvar ABIMethod = algosdk.ABIMethod;\nvar AtomicTransactionComposer = algosdk.AtomicTransactionComposer;\nvar modelsv2 = algosdk.modelsv2;\nvar OnApplicationComplete = algosdk.OnApplicationComplete;\nvar SourceMap = algosdk.SourceMap;\n/**\n * Creates a smart contract app, returns the details of the created app.\n * @param create The parameters to create the app with\n * @param algod An algod client\n * @returns The details of the created app, or the transaction to create it if `skipSending` and the compilation result\n */\nasync function createApp(create, algod) {\n    const { from, approvalProgram: approval, clearStateProgram: clear, schema, note, transactionParams, args, onCompleteAction, ...sendParams } = create;\n    const compiledApproval = typeof approval === 'string' ? await compileTeal(approval, algod) : undefined;\n    const approvalProgram = compiledApproval ? compiledApproval.compiledBase64ToBytes : approval;\n    const compiledClear = typeof clear === 'string' ? await compileTeal(clear, algod) : undefined;\n    const clearProgram = compiledClear ? compiledClear.compiledBase64ToBytes : clear;\n    if (args && args.method) {\n        const atc = attachATC(sendParams);\n        const before = getAtomicTransactionComposerTransactions(atc);\n        atc.addMethodCall({\n            appID: 0,\n            approvalProgram: approvalProgram,\n            clearProgram: clearProgram,\n            numLocalInts: schema.localInts,\n            numLocalByteSlices: schema.localByteSlices,\n            numGlobalInts: schema.globalInts,\n            numGlobalByteSlices: schema.globalByteSlices,\n            extraPages: schema.extraPages ?? Math.floor((approvalProgram.length + clearProgram.length) / APP_PAGE_MAX_SIZE),\n            onComplete: getAppOnCompleteAction(onCompleteAction),\n            suggestedParams: controlFees(await getTransactionParams(transactionParams, algod), sendParams),\n            note: encodeTransactionNote(note),\n            ...(await getAppArgsForABICall(args, from)),\n        });\n        if (sendParams.skipSending) {\n            const after = atc.clone().buildGroup();\n            return {\n                transaction: after[after.length - 1].txn,\n                transactions: after.slice(before.length).map((t) => t.txn),\n                appId: 0,\n                appAddress: '',\n                compiledApproval,\n                compiledClear,\n            };\n        }\n        const result = await sendAtomicTransactionComposer({ atc, sendParams }, algod);\n        const confirmation = result.confirmations ? result.confirmations[result.confirmations?.length - 1] : undefined;\n        if (confirmation) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const appId = confirmation.applicationIndex;\n            Config.getLogger(sendParams.suppressLog).debug(`Created app ${appId} from creator ${getSenderAddress(from)}`);\n            return {\n                transactions: result.transactions,\n                confirmations: result.confirmations,\n                return: confirmation ? getABIReturn(args, confirmation) : undefined,\n                transaction: result.transactions[result.transactions.length - 1],\n                confirmation: confirmation,\n                appId,\n                appAddress: algosdk.getApplicationAddress(appId),\n                compiledApproval,\n                compiledClear,\n            };\n        }\n        else {\n            return {\n                transactions: result.transactions,\n                confirmations: result.confirmations,\n                return: confirmation ? getABIReturn(args, confirmation) : undefined,\n                transaction: result.transactions[result.transactions.length - 1],\n                confirmation: confirmation,\n                appId: 0,\n                appAddress: '',\n                compiledApproval,\n                compiledClear,\n            };\n        }\n    }\n    else {\n        const transaction = algosdk.makeApplicationCreateTxnFromObject({\n            approvalProgram: approvalProgram,\n            clearProgram: clearProgram,\n            numLocalInts: schema.localInts,\n            numLocalByteSlices: schema.localByteSlices,\n            numGlobalInts: schema.globalInts,\n            numGlobalByteSlices: schema.globalByteSlices,\n            extraPages: schema.extraPages ?? Math.floor((approvalProgram.length + clearProgram.length) / APP_PAGE_MAX_SIZE),\n            onComplete: getAppOnCompleteAction(onCompleteAction),\n            suggestedParams: await getTransactionParams(transactionParams, algod),\n            from: getSenderAddress(from),\n            note: encodeTransactionNote(note),\n            ...getAppArgsForTransaction(args),\n            rekeyTo: args?.rekeyTo ? (typeof args.rekeyTo === 'string' ? args.rekeyTo : getSenderAddress(args.rekeyTo)) : undefined,\n        });\n        const { confirmation } = await sendTransaction({ transaction, from, sendParams }, algod);\n        if (confirmation) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const appId = confirmation.applicationIndex;\n            Config.getLogger(sendParams.suppressLog).debug(`Created app ${appId} from creator ${getSenderAddress(from)}`);\n            return {\n                transaction,\n                transactions: [transaction],\n                confirmation,\n                confirmations: confirmation ? [confirmation] : undefined,\n                appId,\n                appAddress: algosdk.getApplicationAddress(appId),\n                return: getABIReturn(args, confirmation),\n                compiledApproval,\n                compiledClear,\n            };\n        }\n        else {\n            return { transaction, transactions: [transaction], appId: 0, appAddress: '', compiledApproval, compiledClear };\n        }\n    }\n}\n/**\n * Updates a smart contract app.\n * @param update The parameters to update the app with\n * @param algod An algod client\n * @returns The transaction send result and the compilation result\n */\nasync function updateApp(update, algod) {\n    const { appId, from, approvalProgram: approval, clearStateProgram: clear, note, transactionParams, args, ...sendParams } = update;\n    const compiledApproval = typeof approval === 'string' ? await compileTeal(approval, algod) : undefined;\n    const approvalProgram = compiledApproval ? compiledApproval.compiledBase64ToBytes : approval;\n    const compiledClear = typeof clear === 'string' ? await compileTeal(clear, algod) : undefined;\n    const clearProgram = compiledClear ? compiledClear.compiledBase64ToBytes : clear;\n    Config.getLogger(sendParams.suppressLog).debug(`Updating app ${appId}`);\n    if (args && args.method) {\n        const atc = attachATC(sendParams);\n        const before = getAtomicTransactionComposerTransactions(atc);\n        atc.addMethodCall({\n            appID: toNumber(appId),\n            onComplete: OnApplicationComplete.UpdateApplicationOC,\n            approvalProgram: approvalProgram,\n            clearProgram: clearProgram,\n            suggestedParams: controlFees(await getTransactionParams(transactionParams, algod), sendParams),\n            note: encodeTransactionNote(note),\n            ...(await getAppArgsForABICall(args, from)),\n        });\n        if (sendParams.skipSending) {\n            const after = atc.clone().buildGroup();\n            return {\n                transaction: after[after.length - 1].txn,\n                transactions: after.slice(before.length).map((t) => t.txn),\n            };\n        }\n        const result = await sendAtomicTransactionComposer({ atc, sendParams }, algod);\n        const confirmation = result.confirmations ? result.confirmations[result.confirmations?.length - 1] : undefined;\n        return {\n            transactions: result.transactions,\n            confirmations: result.confirmations,\n            return: confirmation ? getABIReturn(args, confirmation) : undefined,\n            transaction: result.transactions[result.transactions.length - 1],\n            confirmation: confirmation,\n        };\n    }\n    else {\n        const transaction = algosdk.makeApplicationUpdateTxnFromObject({\n            appIndex: toNumber(appId),\n            approvalProgram: approvalProgram,\n            clearProgram: clearProgram,\n            suggestedParams: await getTransactionParams(transactionParams, algod),\n            from: getSenderAddress(from),\n            note: encodeTransactionNote(note),\n            ...getAppArgsForTransaction(args),\n            rekeyTo: args?.rekeyTo ? (typeof args.rekeyTo === 'string' ? args.rekeyTo : getSenderAddress(args.rekeyTo)) : undefined,\n        });\n        const result = await sendTransaction({ transaction, from, sendParams }, algod);\n        return {\n            ...result,\n            transactions: [result.transaction],\n            confirmations: result.confirmation ? [result.confirmation] : undefined,\n            return: getABIReturn(args, result.confirmation),\n            compiledApproval,\n            compiledClear,\n        };\n    }\n}\nfunction attachATC(sendParams) {\n    if (sendParams.atc) {\n        sendParams.skipSending = true;\n    }\n    sendParams.atc = sendParams.atc ?? new AtomicTransactionComposer();\n    return sendParams.atc;\n}\n/** Returns an `algosdk.OnApplicationComplete` for the given onCompleteAction.\n *\n * If given `undefined` will return `OnApplicationComplete.NoOpOC`.\n *\n * If given an `AppCallType` will convert the string enum to the correct underlying `algosdk.OnApplicationComplete`.\n *\n * @param onCompletionAction The on completion action\n * @returns The `algosdk.OnApplicationComplete`\n */\nfunction getAppOnCompleteAction(onCompletionAction) {\n    switch (onCompletionAction) {\n        case undefined:\n        case 'no_op':\n        case OnApplicationComplete.NoOpOC:\n            return OnApplicationComplete.NoOpOC;\n        case 'opt_in':\n        case OnApplicationComplete.OptInOC:\n            return OnApplicationComplete.OptInOC;\n        case 'close_out':\n        case OnApplicationComplete.CloseOutOC:\n            return OnApplicationComplete.CloseOutOC;\n        case 'clear_state':\n        case OnApplicationComplete.ClearStateOC:\n            return OnApplicationComplete.ClearStateOC;\n        case 'update_application':\n        case OnApplicationComplete.UpdateApplicationOC:\n            return OnApplicationComplete.UpdateApplicationOC;\n        case 'delete_application':\n        case OnApplicationComplete.DeleteApplicationOC:\n            return OnApplicationComplete.DeleteApplicationOC;\n    }\n}\n/**\n * Issues a call to a given app.\n * @param call The call details.\n * @param algod An algod client\n * @returns The result of the call\n */\nasync function callApp(call, algod) {\n    const { appId, callType, from, args, note, transactionParams, ...sendParams } = call;\n    if (args && args.method) {\n        const atc = attachATC(sendParams);\n        const before = getAtomicTransactionComposerTransactions(atc);\n        atc.addMethodCall({\n            appID: toNumber(appId),\n            suggestedParams: controlFees(await getTransactionParams(transactionParams, algod), sendParams),\n            note: encodeTransactionNote(note),\n            onComplete: getAppOnCompleteAction(callType),\n            ...(await getAppArgsForABICall(args, from)),\n        });\n        if (sendParams.skipSending) {\n            const after = atc.clone().buildGroup();\n            return {\n                transaction: after[after.length - 1].txn,\n                transactions: after.slice(before.length).map((t) => t.txn),\n            };\n        }\n        const result = await sendAtomicTransactionComposer({ atc, sendParams }, algod);\n        const confirmation = result.confirmations ? result.confirmations[result.confirmations?.length - 1] : undefined;\n        return {\n            transactions: result.transactions,\n            confirmations: result.confirmations,\n            return: confirmation ? getABIReturn(args, confirmation) : undefined,\n            transaction: result.transactions[result.transactions.length - 1],\n            confirmation: confirmation,\n        };\n    }\n    const appCallParams = {\n        appIndex: toNumber(appId),\n        from: getSenderAddress(from),\n        suggestedParams: await getTransactionParams(transactionParams, algod),\n        ...getAppArgsForTransaction(args),\n        note: encodeTransactionNote(note),\n        rekeyTo: args?.rekeyTo ? (typeof args.rekeyTo === 'string' ? args.rekeyTo : getSenderAddress(args.rekeyTo)) : undefined,\n    };\n    let transaction;\n    switch (getAppOnCompleteAction(callType)) {\n        case OnApplicationComplete.OptInOC:\n            transaction = algosdk.makeApplicationOptInTxnFromObject(appCallParams);\n            break;\n        case OnApplicationComplete.ClearStateOC:\n            transaction = algosdk.makeApplicationClearStateTxnFromObject(appCallParams);\n            break;\n        case OnApplicationComplete.CloseOutOC:\n            transaction = algosdk.makeApplicationCloseOutTxnFromObject(appCallParams);\n            break;\n        case OnApplicationComplete.DeleteApplicationOC:\n            transaction = algosdk.makeApplicationDeleteTxnFromObject(appCallParams);\n            break;\n        case OnApplicationComplete.NoOpOC:\n            transaction = algosdk.makeApplicationNoOpTxnFromObject(appCallParams);\n            break;\n        default:\n            throw new Error(`Received unexpected call type ${callType}`);\n    }\n    const result = await sendTransaction({ transaction, from, sendParams }, algod);\n    return {\n        ...result,\n        transactions: [result.transaction],\n        confirmations: result.confirmation ? [result.confirmation] : undefined,\n        return: getABIReturn(args, result.confirmation),\n    };\n}\n/**\n * Returns any ABI return values for the given app call arguments and transaction confirmation.\n * @param args The arguments that were used for the call\n * @param confirmation The transaction confirmation from algod\n * @returns The return value for the method call\n */\nfunction getABIReturn(args, confirmation) {\n    if (!args || !args.method) {\n        return undefined;\n    }\n    const method = 'txnCount' in args.method ? args.method : new ABIMethod(args.method);\n    if (method.returns.type !== 'void' && confirmation) {\n        // The parseMethodResponse method mutates the second parameter :(\n        const resultDummy = {\n            txID: '',\n            method,\n            rawReturnValue: new Uint8Array(),\n        };\n        const response = AtomicTransactionComposer.parseMethodResponse(method, resultDummy, confirmation);\n        return !response.decodeError\n            ? {\n                rawReturnValue: response.rawReturnValue,\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                returnValue: response.returnValue,\n                decodeError: undefined,\n            }\n            : {\n                rawReturnValue: undefined,\n                returnValue: undefined,\n                decodeError: response.decodeError,\n            };\n    }\n    return undefined;\n}\n/**\n * Returns the current global state values for the given app ID\n * @param appId The ID of the app return global state for\n * @param algod An algod client instance\n * @returns The current global state\n */\nasync function getAppGlobalState(appId, algod) {\n    const appInfo = await getAppById(appId, algod);\n    if (!appInfo.params || !appInfo.params.globalState) {\n        throw new Error(\"Couldn't find global state\");\n    }\n    return decodeAppState(appInfo.params.globalState);\n}\n/**\n * Returns the current global state values for the given app ID and account\n * @param appId The ID of the app return global state for\n * @param account Either the string address of an account or an account object for the account to get local state for the given app\n * @param algod An algod client instance\n * @returns The current local state for the given (app, account) combination\n */\nasync function getAppLocalState(appId, account, algod) {\n    const accountAddress = typeof account === 'string' ? account : getSenderAddress(account);\n    const appInfo = modelsv2.AccountApplicationResponse.from_obj_for_encoding(await algod.accountApplicationInformation(accountAddress, toNumber(appId)).do());\n    if (!appInfo.appLocalState?.keyValue) {\n        throw new Error(\"Couldn't find local state\");\n    }\n    return decodeAppState(appInfo.appLocalState.keyValue);\n}\n/**\n * Returns the names of the boxes for the given app.\n * @param appId The ID of the app return box names for\n * @param algod An algod client instance\n * @returns The current box names\n */\nasync function getAppBoxNames(appId, algod) {\n    const boxResult = await algod.getApplicationBoxes(toNumber(appId)).do();\n    return boxResult.boxes.map((b) => {\n        return {\n            nameRaw: b.name,\n            nameBase64: Buffer.from(b.name).toString('base64'),\n            name: Buffer.from(b.name).toString('utf-8'),\n        };\n    });\n}\n/**\n * Returns the value of the given box name for the given app.\n * @param appId The ID of the app return box names for\n * @param boxName The name of the box to return either as a string, binary array or `BoxName`\n * @param algod An algod client instance\n * @returns The current box value as a byte array\n */\nasync function getAppBoxValue(appId, boxName, algod) {\n    const name = typeof boxName === 'string' ? new Uint8Array(Buffer.from(boxName, 'utf-8')) : 'name' in boxName ? boxName.nameRaw : boxName;\n    const boxResult = await algod.getApplicationBoxByName(toNumber(appId), name).do();\n    return boxResult.value;\n}\n/**\n * Returns the value of the given box names for the given app.\n * @param appId The ID of the app return box names for\n * @param boxNames The names of the boxes to return either as a string, binary array or `BoxName`\n * @param algod An algod client instance\n * @returns The current box values as a byte array in the same order as the passed in box names\n */\nasync function getAppBoxValues(appId, boxNames, algod) {\n    return await Promise.all(boxNames.map(async (boxName) => await getAppBoxValue(appId, boxName, algod)));\n}\n/**\n * Returns the value of the given box name for the given app decoded based on the given ABI type.\n * @param request The parameters for the box value request\n * @param algod An algod client instance\n * @returns The current box value as an ABI value\n */\nasync function getAppBoxValueFromABIType(request, algod) {\n    const { appId, boxName, type } = request;\n    const value = await getAppBoxValue(appId, boxName, algod);\n    return type.decode(value);\n}\n/**\n * Returns the value of the given box names for the given app decoded based on the given ABI type.\n * @param request The parameters for the box value request\n * @param algod An algod client instance\n * @returns The current box values as an ABI value in the same order as the passed in box names\n */\nasync function getAppBoxValuesFromABIType(request, algod) {\n    const { appId, boxNames, type } = request;\n    return await Promise.all(boxNames.map(async (boxName) => await getAppBoxValueFromABIType({ appId, boxName, type }, algod)));\n}\n/**\n * Converts an array of global/local state values from the algod api to a more friendly\n * generic object keyed by the UTF-8 value of the key.\n * @param state A `global-state`, `local-state`, `global-state-deltas` or `local-state-deltas`\n * @returns An object keyeed by the UTF-8 representation of the key with various parsings of the values\n */\nfunction decodeAppState(state) {\n    const stateValues = {};\n    // Start with empty set\n    for (const stateVal of state) {\n        const keyBase64 = stateVal.key;\n        const keyRaw = Buffer.from(keyBase64, 'base64');\n        const key = keyRaw.toString('utf-8');\n        const tealValue = stateVal.value;\n        const dataTypeFlag = 'action' in tealValue ? tealValue.action : tealValue.type;\n        let valueBase64;\n        let valueRaw;\n        switch (dataTypeFlag) {\n            case 1:\n                valueBase64 = tealValue.bytes ?? '';\n                valueRaw = Buffer.from(valueBase64, 'base64');\n                stateValues[key] = {\n                    keyRaw,\n                    keyBase64,\n                    valueRaw: new Uint8Array(valueRaw),\n                    valueBase64: valueBase64,\n                    value: valueRaw.toString('utf-8'),\n                };\n                break;\n            case 2: {\n                const value = tealValue.uint ?? 0;\n                stateValues[key] = {\n                    keyRaw,\n                    keyBase64,\n                    value,\n                };\n                break;\n            }\n            default:\n                throw new Error(`Received unknown state data type of ${dataTypeFlag}`);\n        }\n    }\n    return stateValues;\n}\n/**\n * Returns the app args ready to load onto an app `Transaction` object\n * @param args The app call args\n * @returns The args ready to load into a `Transaction`\n */\nfunction getAppArgsForTransaction(args) {\n    if (!args)\n        return undefined;\n    const encoder = new TextEncoder();\n    return {\n        accounts: args?.accounts?.map(_getAccountAddress),\n        appArgs: args?.appArgs?.map((a) => (typeof a === 'string' ? encoder.encode(a) : a)),\n        boxes: args.boxes?.map(getBoxReference),\n        foreignApps: args?.apps,\n        foreignAssets: args?.assets,\n        lease: encodeLease(args?.lease),\n    };\n}\n/**\n * Returns the app args ready to load onto an ABI method call in `AtomicTransactionComposer`\n * @param args The ABI app call args\n * @param from The transaction signer\n * @returns The parameters ready to pass into `addMethodCall` within AtomicTransactionComposer\n */\nasync function getAppArgsForABICall(args, from) {\n    const signer = getSenderTransactionSigner(from);\n    const methodArgs = await Promise.all(('methodArgs' in args ? args.methodArgs : args)?.map(async (a, index) => {\n        if (a === undefined) {\n            throw new Error(`Argument at position ${index} does not have a value`);\n        }\n        if (typeof a !== 'object') {\n            return a;\n        }\n        // Handle the various forms of transactions to wrangle them for ATC\n        return 'txn' in a\n            ? a\n            : a instanceof Promise\n                ? { txn: (await a).transaction, signer }\n                : 'transaction' in a\n                    ? { txn: a.transaction, signer: 'signer' in a ? getSenderTransactionSigner(a.signer) : signer }\n                    : 'txID' in a\n                        ? { txn: a, signer }\n                        : a;\n    }));\n    return {\n        method: 'txnCount' in args.method ? args.method : new ABIMethod(args.method),\n        sender: getSenderAddress(from),\n        signer: signer,\n        boxes: args.boxes?.map(getBoxReference),\n        lease: encodeLease(args.lease),\n        appForeignApps: args.apps,\n        appForeignAssets: args.assets,\n        appAccounts: args.accounts?.map(_getAccountAddress),\n        methodArgs: methodArgs,\n        rekeyTo: args?.rekeyTo ? (typeof args.rekeyTo === 'string' ? args.rekeyTo : getSenderAddress(args.rekeyTo)) : undefined,\n    };\n}\n/**\n * Returns a `algosdk.BoxReference` given a `BoxIdentifier` or `BoxReference`.\n * @param box The box to return a reference for\n * @returns The box reference ready to pass into a `Transaction`\n */\nfunction getBoxReference(box) {\n    const encoder = new TextEncoder();\n    if (typeof box === 'object' && 'appIndex' in box) {\n        return box;\n    }\n    const ref = typeof box === 'object' && 'appId' in box ? box : { appId: 0, name: box };\n    return {\n        appIndex: ref.appId,\n        name: typeof ref.name === 'string'\n            ? encoder.encode(ref.name)\n            : 'length' in ref.name\n                ? ref.name\n                : algosdk.decodeAddress(getSenderAddress(ref.name)).publicKey,\n    };\n}\nfunction _getAccountAddress(account) {\n    return typeof account === 'string' ? account : algosdk.encodeAddress(account.publicKey);\n}\n/**\n * Gets the current data for the given app from algod.\n *\n * @param appId The id of the app\n * @param algod An algod client\n * @returns The data about the app\n */\nasync function getAppById(appId, algod) {\n    return modelsv2.Application.from_obj_for_encoding(await algod.getApplicationByID(toNumber(appId)).do());\n}\n/**\n * Compiles the given TEAL using algod and returns the result, including source map.\n *\n * @param algod An algod client\n * @param tealCode The TEAL code\n * @returns The information about the compiled file\n */\nasync function compileTeal(tealCode, algod) {\n    const compiled = await algod.compile(tealCode).sourcemap(true).do();\n    return {\n        teal: tealCode,\n        compiled: compiled.result,\n        compiledHash: compiled.hash,\n        compiledBase64ToBytes: new Uint8Array(Buffer.from(compiled.result, 'base64')),\n        sourceMap: new SourceMap(compiled['sourcemap']),\n    };\n}\n/**\n * Returns the encoded ABI spec for a given ABI Method\n * @param method The method to return a signature for\n * @returns The encoded ABI method spec e.g. `method_name(uint64,string)string`\n */\nconst getABIMethodSignature = (method) => {\n    return 'getSignature' in method ? method.getSignature() : new ABIMethod(method).getSignature();\n};\n\nexport { callApp, compileTeal, createApp, decodeAppState, getABIMethodSignature, getABIReturn, getAppArgsForABICall, getAppArgsForTransaction, getAppBoxNames, getAppBoxValue, getAppBoxValueFromABIType, getAppBoxValues, getAppBoxValuesFromABIType, getAppById, getAppGlobalState, getAppLocalState, getAppOnCompleteAction, getBoxReference, updateApp };\n//# sourceMappingURL=app.mjs.map\n","const DEFAULT_INDEXER_MAX_API_RESOURCES_PER_ACCOUNT = 1000; //MaxAPIResourcesPerAccount: This is the default maximum, though may be provider specific\n/**\n * Looks up a transaction by ID using Indexer.\n * @param transactionId The ID of the transaction to look up\n * @param indexer An indexer client\n * @returns The result of the look-up\n */\nasync function lookupTransactionById(transactionId, indexer) {\n    return (await indexer.lookupTransactionByID(transactionId).do());\n}\n/**\n * Looks up an account by address using Indexer.\n * @param accountAddress The address of the account to look up\n * @param indexer An indexer client\n * @returns The result of the look-up\n */\nasync function lookupAccountByAddress(accountAddress, indexer) {\n    return (await indexer.lookupAccountByID(accountAddress).do());\n}\n/**\n * Looks up applications that were created by the given address; will automatically paginate through all data.\n * @param indexer An indexer instance\n * @param address The address of the creator to look up\n * @param getAll Whether or not to include deleted applications\n * @param paginationLimit The number of records to return per paginated request, default 1000\n * @returns The list of application results\n */\nasync function lookupAccountCreatedApplicationByAddress(indexer, address, getAll = undefined, paginationLimit) {\n    return await executePaginatedRequest((response) => {\n        if ('message' in response) {\n            throw { status: 404, ...response };\n        }\n        return response.applications;\n    }, (nextToken) => {\n        let s = indexer\n            .lookupAccountCreatedApplications(address)\n            .includeAll(getAll)\n            .limit(paginationLimit ?? DEFAULT_INDEXER_MAX_API_RESOURCES_PER_ACCOUNT);\n        if (nextToken) {\n            s = s.nextToken(nextToken);\n        }\n        return s;\n    });\n}\n/**\n * Looks up asset holdings for the given asset; will automatically paginate through all data.\n * @param indexer An indexer instance\n * @param assetId The ID of the asset to look up holdings for\n * @param options Optional options to control the lookup\n * @param paginationLimit The number of records to return per paginated request, default 1000\n * @returns The list of application results\n */\nasync function lookupAssetHoldings(indexer, assetId, options, paginationLimit) {\n    return await executePaginatedRequest((response) => {\n        if ('message' in response) {\n            throw { status: 404, ...response };\n        }\n        return response.balances;\n    }, (nextToken) => {\n        let s = indexer.lookupAssetBalances(Number(assetId)).limit(paginationLimit ?? DEFAULT_INDEXER_MAX_API_RESOURCES_PER_ACCOUNT);\n        if (options?.currencyGreaterThan !== undefined) {\n            s = s.currencyGreaterThan(options.currencyGreaterThan);\n        }\n        if (options?.currencyLessThan !== undefined) {\n            s = s.currencyLessThan(options.currencyLessThan);\n        }\n        if (options?.includeAll !== undefined) {\n            s = s.includeAll(options.includeAll);\n        }\n        if (nextToken) {\n            s = s.nextToken(nextToken);\n        }\n        return s;\n    });\n}\n/**\n * Allows transactions to be searched for the given criteria.\n * @param indexer An indexer client\n * @param searchCriteria The criteria to search for\n * @param paginationLimit The number of records to return per paginated request, default 1000\n * @returns The search results\n */\nasync function searchTransactions(indexer, searchCriteria, paginationLimit) {\n    let currentRound = 0;\n    const transactions = await executePaginatedRequest((response) => {\n        if ('message' in response) {\n            throw { status: 404, ...response };\n        }\n        if (response['current-round'] > currentRound) {\n            currentRound = response['current-round'];\n        }\n        return response.transactions;\n    }, (nextToken) => {\n        let s = searchCriteria(indexer.searchForTransactions()).limit(paginationLimit ?? DEFAULT_INDEXER_MAX_API_RESOURCES_PER_ACCOUNT);\n        if (nextToken) {\n            s = s.nextToken(nextToken);\n        }\n        return s;\n    });\n    return {\n        'current-round': currentRound,\n        'next-token': '',\n        transactions: transactions,\n    };\n}\n// https://developer.algorand.org/docs/get-details/indexer/#paginated-results\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function executePaginatedRequest(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nextractItems, buildRequest) {\n    const results = [];\n    let nextToken = undefined;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const request = buildRequest(nextToken);\n        const response = await request.do();\n        const items = extractItems(response);\n        if (items == null || items.length === 0) {\n            break;\n        }\n        results.push(...items);\n        nextToken = response['next-token'];\n        if (!nextToken) {\n            break;\n        }\n    }\n    return results;\n}\n\nexport { executePaginatedRequest, lookupAccountByAddress, lookupAccountCreatedApplicationByAddress, lookupAssetHoldings, lookupTransactionById, searchTransactions };\n//# sourceMappingURL=indexer-lookup.mjs.map\n","import algosdk from 'algosdk';\nimport { getAppById, compileTeal, createApp, callApp, updateApp } from './app.mjs';\nimport { Config } from './config.mjs';\nimport { lookupAccountCreatedApplicationByAddress, searchTransactions } from './indexer-lookup.mjs';\nimport { getSenderAddress, sendAtomicTransactionComposer } from './transaction/transaction.mjs';\nimport { OnSchemaBreak, OnUpdate, APP_DEPLOY_NOTE_DAPP, UPDATABLE_TEMPLATE_NAME, DELETABLE_TEMPLATE_NAME } from './types/app.mjs';\n\nvar AtomicTransactionComposer = algosdk.AtomicTransactionComposer;\nvar getApplicationAddress = algosdk.getApplicationAddress;\nvar modelsv2 = algosdk.modelsv2;\nvar TransactionType = algosdk.TransactionType;\n/**\n * Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator account, including deploy-time template placeholder substitutions.\n *\n * To understand the architecture decisions behind this functionality please see https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md\n *\n * **Note:** When using the return from this function be sure to check `operationPerformed` to get access to various return properties like `transaction`, `confirmation` and `deleteResult`.\n *\n * **Note:** if there is a breaking state schema change to an existing app (and `onSchemaBreak` is set to `'replace'`) the existing app will be deleted and re-created.\n *\n * **Note:** if there is an update (different TEAL code) to an existing app (and `onUpdate` is set to `'replace'`) the existing app will be deleted and re-created.\n * @param deployment The arguments to control the app deployment\n * @param algod An algod client\n * @param indexer An indexer client, needed if `existingDeployments` not passed in\n * @returns The app reference of the new/existing app\n */\nasync function deployApp(deployment, algod, indexer) {\n    const { metadata, deployTimeParams: deployTimeParameters, onSchemaBreak, onUpdate, existingDeployments, createArgs, updateArgs, deleteArgs, createOnCompleteAction, ...appParams } = deployment;\n    if (existingDeployments && existingDeployments.creator !== getSenderAddress(appParams.from)) {\n        throw new Error(`Received invalid existingDeployments value for creator ${existingDeployments.creator} when attempting to deploy for creator ${appParams.from}`);\n    }\n    if (!existingDeployments && !indexer) {\n        throw new Error(`Didn't receive an indexer client, but also didn't receive an existingDeployments cache - one of them must be provided`);\n    }\n    Config.getLogger(appParams.suppressLog).info(`Idempotently deploying app \"${metadata.name}\" from creator ${getSenderAddress(appParams.from)} using ${appParams.approvalProgram.length} bytes of teal code and ${appParams.clearStateProgram.length} bytes of teal code`);\n    const compiledApproval = typeof appParams.approvalProgram === 'string'\n        ? await performTemplateSubstitutionAndCompile(appParams.approvalProgram, algod, deployTimeParameters, metadata)\n        : undefined;\n    appParams.approvalProgram = compiledApproval ? compiledApproval.compiledBase64ToBytes : appParams.approvalProgram;\n    const compiledClear = typeof appParams.clearStateProgram === 'string'\n        ? await performTemplateSubstitutionAndCompile(appParams.clearStateProgram, algod, deployTimeParameters)\n        : undefined;\n    appParams.clearStateProgram = compiledClear ? compiledClear.compiledBase64ToBytes : appParams.clearStateProgram;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const apps = existingDeployments ?? (await getCreatorAppsByName(appParams.from, indexer));\n    const create = async (atc) => {\n        const result = await createApp({\n            ...appParams,\n            onCompleteAction: createOnCompleteAction,\n            args: createArgs,\n            note: getAppDeploymentTransactionNote(metadata),\n            atc,\n            skipWaiting: false,\n        }, algod);\n        return {\n            transaction: result.transaction,\n            transactions: result.transactions,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            confirmation: result.confirmation,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            confirmations: result.confirmations,\n            return: result.return,\n            appId: result.appId,\n            appAddress: result.appAddress,\n            createdMetadata: metadata,\n            createdRound: Number(result.confirmation?.confirmedRound),\n            updatedRound: Number(result.confirmation?.confirmedRound),\n            ...metadata,\n            deleted: false,\n            operationPerformed: 'create',\n            compiledApproval,\n            compiledClear,\n        };\n    };\n    const existingApp = apps.apps[metadata.name];\n    if (!existingApp || existingApp.deleted) {\n        Config.getLogger(appParams.suppressLog).info(`App ${metadata.name} not found in apps created by ${getSenderAddress(appParams.from)}; deploying app with version ${metadata.version}.`);\n        return await create();\n    }\n    Config.getLogger(appParams.suppressLog).info(`Existing app ${metadata.name} found by creator ${getSenderAddress(appParams.from)}, with app id ${existingApp.appId} and version ${existingApp.version}.`);\n    const existingAppRecord = await getAppById(existingApp.appId, algod);\n    const existingApproval = Buffer.from(existingAppRecord.params.approvalProgram).toString('base64');\n    const existingClear = Buffer.from(existingAppRecord.params.clearStateProgram).toString('base64');\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const existingGlobalSchema = existingAppRecord.params.globalStateSchema;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const existingLocalSchema = existingAppRecord.params.localStateSchema;\n    const newGlobalSchema = new modelsv2.ApplicationStateSchema({\n        numByteSlice: appParams.schema.globalByteSlices,\n        numUint: appParams.schema.globalInts,\n    });\n    const newLocalSchema = new modelsv2.ApplicationStateSchema({\n        numByteSlice: appParams.schema.localByteSlices,\n        numUint: appParams.schema.localInts,\n    });\n    const newApproval = Buffer.from(appParams.approvalProgram).toString('base64');\n    const newClear = Buffer.from(appParams.clearStateProgram).toString('base64');\n    const isUpdate = newApproval !== existingApproval || newClear !== existingClear;\n    const isSchemaBreak = isSchemaIsBroken(existingGlobalSchema, newGlobalSchema) || isSchemaIsBroken(existingLocalSchema, newLocalSchema);\n    const replace = async () => {\n        const atc = new AtomicTransactionComposer();\n        // Create\n        Config.getLogger(appParams.suppressLog).info(`Deploying a new ${metadata.name} app for ${getSenderAddress(appParams.from)}; deploying app with version ${metadata.version}.`);\n        const { transaction: createTransaction } = await create(atc);\n        const createTransactions = atc.clone().buildGroup();\n        // Delete\n        Config.getLogger(appParams.suppressLog).warn(`Deleting existing ${metadata.name} app with id ${existingApp.appId} from ${getSenderAddress(appParams.from)} account.`);\n        const { transaction: deleteTransaction } = await callApp({\n            appId: existingApp.appId,\n            callType: 'delete_application',\n            from: appParams.from,\n            args: deleteArgs,\n            transactionParams: appParams.transactionParams,\n            suppressLog: appParams.suppressLog,\n            skipSending: true,\n            atc,\n        }, algod);\n        // Ensure create and delete happen atomically\n        const { transactions, confirmations, returns } = await sendAtomicTransactionComposer({\n            atc,\n            sendParams: {\n                maxRoundsToWaitForConfirmation: appParams.maxRoundsToWaitForConfirmation,\n                skipWaiting: false,\n                suppressLog: true,\n            },\n        }, algod);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const createConfirmation = confirmations[createTransactions.length - 1];\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const deleteConfirmation = confirmations[confirmations.length - 1];\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const newAppIndex = createConfirmation.applicationIndex;\n        Config.getLogger(appParams.suppressLog).warn(`Sent transactions ${createTransaction.txID()} to create app with id ${newAppIndex} and ${deleteTransaction.txID()} to delete app with id ${existingApp.appId} from ${getSenderAddress(appParams.from)} account.`);\n        return {\n            transaction: createTransaction,\n            transactions: transactions,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            confirmation: createConfirmation,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            confirmations: confirmations,\n            return: returns?.[0],\n            deleteReturn: returns?.[1],\n            appId: newAppIndex,\n            appAddress: getApplicationAddress(newAppIndex),\n            createdMetadata: metadata,\n            createdRound: Number(createConfirmation.confirmedRound),\n            updatedRound: Number(createConfirmation.confirmedRound),\n            ...metadata,\n            deleted: false,\n            deleteResult: { transaction: deleteTransaction, confirmation: deleteConfirmation },\n            operationPerformed: 'replace',\n            compiledApproval,\n            compiledClear,\n        };\n    };\n    const update = async () => {\n        Config.getLogger(appParams.suppressLog).info(`Updating existing ${metadata.name} app for ${getSenderAddress(appParams.from)} to version ${metadata.version}.`);\n        const result = await updateApp({\n            appId: existingApp.appId,\n            from: appParams.from,\n            args: updateArgs,\n            note: getAppDeploymentTransactionNote(metadata),\n            approvalProgram: appParams.approvalProgram,\n            clearStateProgram: appParams.clearStateProgram,\n            transactionParams: appParams.transactionParams,\n            suppressLog: appParams.suppressLog,\n            skipSending: false,\n            skipWaiting: false,\n        }, algod);\n        return {\n            transaction: result.transaction,\n            transactions: result.transactions,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            confirmation: result.confirmation,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            confirmations: result.confirmations,\n            return: result.return,\n            appId: existingApp.appId,\n            appAddress: existingApp.appAddress,\n            createdMetadata: existingApp.createdMetadata,\n            createdRound: existingApp.createdRound,\n            updatedRound: Number(result.confirmation?.confirmedRound),\n            ...metadata,\n            deleted: false,\n            operationPerformed: 'update',\n            compiledApproval,\n            compiledClear,\n        };\n    };\n    if (isSchemaBreak) {\n        Config.getLogger(appParams.suppressLog).warn(`Detected a breaking app schema change in app ${existingApp.appId}:`, {\n            from: {\n                global: existingGlobalSchema,\n                local: existingLocalSchema,\n            },\n            to: {\n                global: newGlobalSchema,\n                local: newLocalSchema,\n            },\n        });\n        if (onSchemaBreak === undefined || onSchemaBreak === 'fail' || onSchemaBreak === OnSchemaBreak.Fail) {\n            throw new Error('Schema break detected and onSchemaBreak=OnSchemaBreak.Fail, stopping deployment. ' +\n                'If you want to try deleting and recreating the app then ' +\n                're-run with onSchemaBreak=OnSchemaBreak.ReplaceApp');\n        }\n        if (onSchemaBreak === 'append' || onSchemaBreak === OnSchemaBreak.AppendApp) {\n            Config.getLogger(appParams.suppressLog).info('onSchemaBreak=AppendApp, will attempt to create a new app');\n            return await create();\n        }\n        if (existingApp.deletable) {\n            Config.getLogger(appParams.suppressLog).info('App is deletable and onSchemaBreak=ReplaceApp, will attempt to create new app and delete old app');\n        }\n        else {\n            Config.getLogger(appParams.suppressLog).info('App is not deletable but onSchemaBreak=ReplaceApp, will attempt to delete app, delete will most likely fail');\n        }\n        return await replace();\n    }\n    if (isUpdate) {\n        Config.getLogger(appParams.suppressLog).info(`Detected a TEAL update in app ${existingApp.appId} for creator ${getSenderAddress(appParams.from)}`);\n        if (onUpdate === undefined || onUpdate === 'fail' || onUpdate === OnUpdate.Fail) {\n            throw new Error('Update detected and onUpdate=Fail, stopping deployment. ' +\n                'If you want to try deleting and recreating the app then ' +\n                're-run with onUpdate=UpdateApp');\n        }\n        if (onUpdate === 'append' || onUpdate === OnUpdate.AppendApp) {\n            Config.getLogger(appParams.suppressLog).info('onUpdate=AppendApp, will attempt to create a new app');\n            return await create();\n        }\n        if (onUpdate === 'update' || onUpdate === OnUpdate.UpdateApp) {\n            if (existingApp.updatable) {\n                Config.getLogger(appParams.suppressLog).info(`App is updatable and onUpdate=UpdateApp, updating app...`);\n            }\n            else {\n                Config.getLogger(appParams.suppressLog).warn(`App is not updatable but onUpdate=UpdateApp, will attempt to update app, update will most likely fail`);\n            }\n            return await update();\n        }\n        if (onUpdate === 'replace' || onUpdate === OnUpdate.ReplaceApp) {\n            if (existingApp.deletable) {\n                Config.getLogger(appParams.suppressLog).warn('App is deletable and onUpdate=ReplaceApp, creating new app and deleting old app...');\n            }\n            else {\n                Config.getLogger(appParams.suppressLog).warn('App is not deletable and onUpdate=ReplaceApp, will attempt to create new app and delete old app, delete will most likely fail');\n            }\n            return await replace();\n        }\n    }\n    Config.getLogger(appParams.suppressLog).debug('No detected changes in app, nothing to do.');\n    return { ...existingApp, operationPerformed: 'nothing', compiledApproval, compiledClear };\n}\n/** Returns true is there is a breaking change in the application state schema from before to after.\n *  i.e. if the schema becomes larger, since applications can't ask for more schema after creation.\n *  Otherwise, there is no error, the app just doesn't store data in the extra schema :(\n *\n * @param before The existing schema\n * @param after The new schema\n * @returns Whether or not there is a breaking change\n */\nfunction isSchemaIsBroken(before, after) {\n    return before.numByteSlice < after.numByteSlice || before.numUint < after.numUint;\n}\n/**\n * Returns a lookup of name => app metadata (id, address, ...metadata) for all apps created by the given account that have an `AppDeployNote` in the transaction note of the creation transaction.\n *\n * **Note:** It's recommended this is only called once and then stored since it's a somewhat expensive operation (multiple indexer calls).\n *\n * @param creatorAccount The account (with private key loaded) or string address of an account that is the creator of the apps you want to search for\n * @param indexer An indexer client\n * @returns A name-based lookup of the app information (id, address)\n */\nasync function getCreatorAppsByName(creatorAccount, indexer) {\n    const appLookup = {};\n    const creatorAddress = typeof creatorAccount !== 'string' ? getSenderAddress(creatorAccount) : creatorAccount;\n    // Extract all apps that account created\n    const createdApps = (await lookupAccountCreatedApplicationByAddress(indexer, creatorAddress))\n        .map((a) => {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return { id: a.id, createdAtRound: a['created-at-round'], deleted: a.deleted };\n    })\n        .sort((a, b) => a.createdAtRound - b.createdAtRound);\n    // For each app that account created (in parallel)...\n    const apps = await Promise.all(createdApps.map(async (createdApp) => {\n        // Find any app transactions for that app in the round it was created (should always just be a single creation transaction)\n        const appTransactions = await searchTransactions(indexer, (s) => s\n            .minRound(createdApp.createdAtRound)\n            .txType(TransactionType.appl)\n            .applicationID(createdApp.id)\n            .address(creatorAddress)\n            .addressRole('sender')\n            .notePrefix(Buffer.from(APP_DEPLOY_NOTE_DAPP).toString('base64')));\n        // Triple check the transaction is intact by filtering for the one we want:\n        //  * application-id is 0 when the app is first created\n        //  * also verify the sender to prevent a potential security risk\n        const appCreationTransaction = appTransactions.transactions.filter(\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        (t) => t['application-transaction']['application-id'] === 0 && t.sender === creatorAddress)[0];\n        const latestAppUpdateTransaction = appTransactions.transactions\n            .filter((t) => t.sender === creatorAddress)\n            .sort((a, b) => a['confirmed-round'] === b['confirmed-round']\n            ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                (b['intra-round-offset'] - a['intra-round-offset']) / 10\n            : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                b['confirmed-round'] - a['confirmed-round'])[0];\n        if (!appCreationTransaction?.note)\n            // No note; ignoring\n            return null;\n        return { createdApp, appCreationTransaction, latestAppUpdateTransaction };\n    }));\n    apps\n        .filter((a) => a !== null)\n        .forEach((a) => {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const { createdApp, appCreationTransaction, latestAppUpdateTransaction } = a;\n        const parseNote = (note) => {\n            if (!note) {\n                // No note; ignoring...\n                return;\n            }\n            const decoder = new TextDecoder();\n            const noteAsBase64 = decoder.decode(Buffer.from(note));\n            const noteAsString = Buffer.from(noteAsBase64, 'base64').toString('utf-8');\n            if (!noteAsString.startsWith(`${APP_DEPLOY_NOTE_DAPP}:j{`))\n                // Clearly not APP_DEPLOY JSON; ignoring...\n                return;\n            return JSON.parse(noteAsString.substring(APP_DEPLOY_NOTE_DAPP.length + 2));\n        };\n        try {\n            const creationNote = parseNote(appCreationTransaction.note);\n            const updateNote = parseNote(latestAppUpdateTransaction.note);\n            if (creationNote?.name) {\n                appLookup[creationNote.name] = {\n                    appId: createdApp.id,\n                    appAddress: getApplicationAddress(createdApp.id),\n                    createdMetadata: creationNote,\n                    createdRound: Number(appCreationTransaction['confirmed-round']),\n                    ...(updateNote ?? creationNote),\n                    updatedRound: Number(latestAppUpdateTransaction?.['confirmed-round']),\n                    deleted: createdApp.deleted ?? false,\n                };\n            }\n        }\n        catch (e) {\n            Config.logger.warn(`Received error trying to retrieve app with ${createdApp.id} for creator ${creatorAddress}; failing silently`, e);\n            return;\n        }\n    });\n    return {\n        creator: creatorAddress,\n        apps: appLookup,\n    };\n}\n/**\n * Return the transaction note for an app deployment.\n * @param metadata The metadata of the deployment\n * @returns The transaction note as a utf-8 string\n */\nfunction getAppDeploymentTransactionNote(metadata) {\n    return {\n        dAppName: APP_DEPLOY_NOTE_DAPP,\n        data: metadata,\n        format: 'j',\n    };\n}\n/**\n * Replaces deploy-time deployment control parameters within the given teal code.\n *\n * * `TMPL_UPDATABLE` for updatability / immutability control\n * * `TMPL_DELETABLE` for deletability / permanence control\n *\n * Note: If these values are not undefined, but the corresponding `TMPL_*` value\n *  isn't in the teal code it will throw an exception.\n *\n * @param tealCode The TEAL code to substitute\n * @param params The deploy-time deployment control parameter value to replace\n * @returns The replaced TEAL code\n */\nfunction replaceDeployTimeControlParams(tealCode, params) {\n    if (params.updatable !== undefined) {\n        if (!tealCode.includes(UPDATABLE_TEMPLATE_NAME)) {\n            throw new Error(`Deploy-time updatability control requested for app deployment, but ${UPDATABLE_TEMPLATE_NAME} not present in TEAL code`);\n        }\n        tealCode = tealCode.replace(new RegExp(UPDATABLE_TEMPLATE_NAME, 'g'), (params.updatable ? 1 : 0).toString());\n    }\n    if (params.deletable !== undefined) {\n        if (!tealCode.includes(DELETABLE_TEMPLATE_NAME)) {\n            throw new Error(`Deploy-time deletability control requested for app deployment, but ${DELETABLE_TEMPLATE_NAME} not present in TEAL code`);\n        }\n        tealCode = tealCode.replace(new RegExp(DELETABLE_TEMPLATE_NAME, 'g'), (params.deletable ? 1 : 0).toString());\n    }\n    return tealCode;\n}\n/**\n * Performs template substitution of a teal file.\n *\n * Looks for `TMPL_{parameter}` for template replacements.\n *\n * @param tealCode The TEAL logic to compile\n * @param templateParams Any parameters to replace in the .teal file before compiling\n * @returns The TEAL code with replacements\n */\nfunction performTemplateSubstitution(tealCode, templateParams) {\n    if (templateParams !== undefined) {\n        for (const key in templateParams) {\n            const value = templateParams[key];\n            const token = `TMPL_${key.replace(/^TMPL_/, '')}`;\n            // If this is a number, first replace any byte representations of the number\n            // These may appear in the TEAL in order to circumvent int compression and preserve PC values\n            if (typeof value === 'number' || typeof value === 'boolean') {\n                tealCode = tealCode.replace(new RegExp(`(?<=bytes )${token}`, 'g'), `0x${value.toString(16).padStart(16, '0')}`);\n                // We could probably return here since mixing pushint and pushbytes is likely not going to happen, but might as well do both\n            }\n            tealCode = tealCode.replace(new RegExp(token, 'g'), typeof value === 'string'\n                ? `0x${Buffer.from(value, 'utf-8').toString('hex')}`\n                : ArrayBuffer.isView(value)\n                    ? `0x${Buffer.from(value).toString('hex')}`\n                    : value.toString());\n        }\n    }\n    return tealCode;\n}\n/**\n * Performs template substitution of a teal file and compiles it, returning the compiled result.\n *\n * Looks for `TMPL_{parameter}` for template replacements.\n *\n * @param tealCode The TEAL logic to compile\n * @param algod An algod client\n * @param templateParams Any parameters to replace in the .teal file before compiling\n * @param deploymentMetadata The deployment metadata the app will be deployed with\n * @returns The information about the compiled code\n */\nasync function performTemplateSubstitutionAndCompile(tealCode, algod, templateParams, deploymentMetadata) {\n    tealCode = stripTealComments(tealCode);\n    tealCode = performTemplateSubstitution(tealCode, templateParams);\n    if (deploymentMetadata) {\n        tealCode = replaceDeployTimeControlParams(tealCode, deploymentMetadata);\n    }\n    return await compileTeal(tealCode, algod);\n}\n/**\n * Remove comments from TEAL Code\n *\n * @param tealCode The TEAL logic to compile\n * @returns The TEAL without comments\n */\nfunction stripTealComments(tealCode) {\n    // find // outside quotes, i.e. won't pick up \"//not a comment\"\n    const regex = /\\/\\/(?=([^\"\\\\]*(\\\\.|\"([^\"\\\\]*\\\\.)*[^\"\\\\]*\"))*[^\"]*$)/;\n    tealCode = tealCode\n        .split('\\n')\n        .map((tealCodeLine) => {\n        return tealCodeLine.split(regex)[0].trim();\n    })\n        .join('\\n');\n    return tealCode;\n}\n\nexport { deployApp, getAppDeploymentTransactionNote, getCreatorAppsByName, isSchemaIsBroken, performTemplateSubstitution, performTemplateSubstitutionAndCompile, replaceDeployTimeControlParams, stripTealComments };\n//# sourceMappingURL=app-deploy.mjs.map\n","/**\n * AVM debugger source map entry class.\n */\nclass AVMDebuggerSourceMapEntry {\n    /**\n     * Create an AVM debugger source map entry.\n     * @param location The location of the file the source map is for.\n     * @param programHash The hash of the TEAL binary.\n     */\n    constructor(location, programHash) {\n        this.location = location;\n        this.programHash = programHash;\n    }\n    equals(other) {\n        return this.location === other.location && this.programHash === other.programHash;\n    }\n    toString() {\n        return JSON.stringify({ 'sourcemap-location': this.location, hash: this.programHash });\n    }\n}\n/**\n * AVM debugger source map class.\n */\nclass AVMDebuggerSourceMap {\n    /**\n     *\n     * @param txnGroupSources\n     */\n    constructor(txnGroupSources) {\n        this.txnGroupSources = txnGroupSources;\n    }\n    /**\n     * Creates a source map from a dictionary of source map data.\n     * @param data The data\n     * @returns The source map\n     */\n    static fromDict(data) {\n        return new AVMDebuggerSourceMap(data['txn-group-sources'].map((item) => new AVMDebuggerSourceMapEntry(item['sourcemap-location'], item['hash'])));\n    }\n    /**\n     * Converts the source map to a dictionary that can be passed around and then parsed back using `AVMDebuggerSourceMap.fromDict`.\n     * @returns The dictionary\n     */\n    toDict() {\n        return { 'txn-group-sources': this.txnGroupSources.map((item) => JSON.parse(item.toString())) };\n    }\n}\n/**\n * Class representing a debugger source maps input for persistence.\n *\n * Note: rawTeal and compiledTeal are mutually exclusive. Only one of them should be provided.\n */\nclass PersistSourceMapInput {\n    constructor(appName, fileName, rawTeal, compiledTeal) {\n        this.compiledTeal = compiledTeal;\n        this.appName = appName;\n        this._rawTeal = rawTeal;\n        this._fileName = this.stripTealExtension(fileName);\n    }\n    /**\n     * Returns debugger source maps input from raw TEAL code.\n     * @param rawTeal The raw TEAL code\n     * @param appName The name of the app\n     * @param fileName The name of the file to persist to\n     * @returns The persist source map input\n     */\n    static fromRawTeal(rawTeal, appName, fileName) {\n        return new PersistSourceMapInput(appName, fileName, rawTeal);\n    }\n    /**\n     * Returns debugger source maps input from compiled TEAL code.\n     * @param compiledTeal The compiled TEAL code\n     * @param appName The name of the app\n     * @param fileName The name of the file to persist to\n     * @returns The persist source map input\n     */\n    static fromCompiledTeal(compiledTeal, appName, fileName) {\n        return new PersistSourceMapInput(appName, fileName, undefined, compiledTeal);\n    }\n    /** Get the underlying raw teal */\n    get rawTeal() {\n        if (this._rawTeal) {\n            return this._rawTeal;\n        }\n        else if (this.compiledTeal) {\n            return this.compiledTeal.teal;\n        }\n        else {\n            throw new Error('No teal content found');\n        }\n    }\n    /** Get the file name */\n    get fileName() {\n        return this._fileName;\n    }\n    /**\n     * Strips the '.teal' extension from a filename, if present.\n     *\n     * @param fileName - The filename to strip the extension from.\n     * @returns The filename without the '.teal' extension.\n     */\n    stripTealExtension(fileName) {\n        if (fileName.endsWith('.teal')) {\n            return fileName.slice(0, -5);\n        }\n        return fileName;\n    }\n}\n\nexport { AVMDebuggerSourceMap, AVMDebuggerSourceMapEntry, PersistSourceMapInput };\n//# sourceMappingURL=debugging.mjs.map\n","import * as crypto from 'crypto';\nimport { compileTeal } from '../app.mjs';\nimport { Config } from '../config.mjs';\nimport { AVMDebuggerSourceMapEntry, AVMDebuggerSourceMap } from '../types/debugging.mjs';\nimport { isNode } from '../util.mjs';\n\nconst ALGOKIT_DIR = '.algokit';\nconst SOURCES_DIR = 'sources';\nconst SOURCES_FILE = 'sources.avm.json';\nconst TEAL_FILE_EXT = '.teal';\nconst TEAL_SOURCEMAP_EXT = '.teal.tok.map';\n// === Internal methods ===\nasync function loadOrCreateSources(sourcesPath) {\n    try {\n        const fs = await import('fs');\n        const data = JSON.parse(await fs.promises.readFile(sourcesPath, 'utf8'));\n        return AVMDebuggerSourceMap.fromDict(data);\n    }\n    catch (error) {\n        const err = error;\n        if (err.code === 'ENOENT') {\n            return new AVMDebuggerSourceMap([]);\n        }\n        else {\n            throw error;\n        }\n    }\n}\nasync function upsertDebugSourcemaps(sourceMaps, projectRoot) {\n    const path = await import('path');\n    const fs = await import('fs');\n    const sourcesPath = path.join(projectRoot, ALGOKIT_DIR, SOURCES_DIR, SOURCES_FILE);\n    const sources = await loadOrCreateSources(sourcesPath);\n    for (const sourcemap of sourceMaps) {\n        const sourceFilePath = path.resolve(sourcemap.location);\n        try {\n            await fs.promises.access(sourceFilePath);\n            const index = sources.txnGroupSources.findIndex((item) => item.equals(sourcemap));\n            if (index === -1) {\n                sources.txnGroupSources.push(sourcemap);\n            }\n            else {\n                sources.txnGroupSources[index] = sourcemap;\n            }\n        }\n        catch (error) {\n            const err = error;\n            if (err.code === 'ENOENT') {\n                const index = sources.txnGroupSources.findIndex((item) => item.equals(sourcemap));\n                if (index !== -1) {\n                    sources.txnGroupSources.splice(index, 1);\n                }\n            }\n            else {\n                throw error;\n            }\n        }\n    }\n    await fs.promises.writeFile(sourcesPath, JSON.stringify(sources.toDict()), 'utf8');\n}\nasync function writeToFile(filePath, content) {\n    const path = await import('path');\n    const fs = await import('fs');\n    await fs.promises.mkdir(path.dirname(filePath), { recursive: true });\n    await fs.promises.writeFile(filePath, content, 'utf8');\n}\nasync function buildAVMSourcemap({ rawTeal, compiledTeal, appName, fileName, outputPath, client, withSources = true, }) {\n    if (!rawTeal && !compiledTeal) {\n        throw new Error('Either rawTeal or compiledTeal must be provided.');\n    }\n    const path = await import('path');\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const result = rawTeal ? await compileTeal(rawTeal, client) : compiledTeal;\n    const programHash = crypto.createHash('SHA-512/256').update(Buffer.from(result.compiled, 'base64')).digest('base64');\n    const sourceMap = result.sourceMap;\n    sourceMap.sources = withSources ? [`${fileName}${TEAL_FILE_EXT}`] : [];\n    const outputDirPath = path.join(outputPath, ALGOKIT_DIR, SOURCES_DIR, appName);\n    const sourceMapOutputPath = path.join(outputDirPath, `${fileName}${TEAL_SOURCEMAP_EXT}`);\n    const tealOutputPath = path.join(outputDirPath, `${fileName}${TEAL_FILE_EXT}`);\n    await writeToFile(sourceMapOutputPath, JSON.stringify(sourceMap));\n    if (withSources && result) {\n        await writeToFile(tealOutputPath, result.teal);\n    }\n    return new AVMDebuggerSourceMapEntry(sourceMapOutputPath, programHash);\n}\n// === Public facing methods ===\n/**\n * This function persists the source maps for the given sources.\n *\n * @param param0 The parameters to define the persistence\n *\n * @returns A promise that resolves when the source maps have been persisted.\n */\nasync function persistSourceMaps({ sources, projectRoot, client, withSources }) {\n    if (!isNode()) {\n        throw new Error('Sourcemaps can only be persisted in Node.js environment.');\n    }\n    try {\n        const sourceMaps = await Promise.all(sources.map((source) => buildAVMSourcemap({\n            rawTeal: source.rawTeal,\n            compiledTeal: source.compiledTeal,\n            appName: source.appName,\n            fileName: source.fileName,\n            outputPath: projectRoot,\n            client: client,\n            withSources: withSources,\n        })));\n        await upsertDebugSourcemaps(sourceMaps, projectRoot);\n    }\n    catch (error) {\n        const err = error instanceof Error ? error : new Error(String(error));\n        Config.getLogger().error(`Failed to persist avm sourceMaps: ${err.stack ?? err.message ?? err}.`);\n        throw err;\n    }\n}\n\nexport { persistSourceMaps };\n//# sourceMappingURL=debugging.mjs.map\n","import algosdk from 'algosdk';\nimport { Config } from '../config.mjs';\nimport { getSenderAddress, encodeTransactionNote, getTransactionParams, encodeLease, sendTransaction } from '../transaction/transaction.mjs';\n\n/**\n * Transfer ALGOs between two accounts.\n * @param transfer The transfer definition\n * @param algod An algod client\n * @returns The transaction object and optionally the confirmation if it was sent to the chain (`skipSending` is `false` or unset)\n *\n * @example Usage example\n * ```typescript\n * await algokit.transferAlgos({ from, to, amount: algokit.algos(1) }, algod)\n * ```\n */\nasync function transferAlgos(transfer, algod) {\n    const { from, to, amount, note, transactionParams, lease, ...sendParams } = transfer;\n    const transaction = algosdk.makePaymentTxnWithSuggestedParamsFromObject({\n        from: getSenderAddress(from),\n        to: getSenderAddress(to),\n        amount: amount.microAlgos,\n        note: encodeTransactionNote(note),\n        suggestedParams: await getTransactionParams(transactionParams, algod),\n        closeRemainderTo: undefined,\n        rekeyTo: undefined,\n    });\n    const encodedLease = encodeLease(lease);\n    if (encodedLease) {\n        transaction.addLease(encodedLease);\n    }\n    if (!sendParams.skipSending) {\n        Config.getLogger(sendParams.suppressLog).debug(`Transferring ${amount.microAlgos}µALGOs from ${getSenderAddress(from)} to ${getSenderAddress(to)}`);\n    }\n    return sendTransaction({ transaction, from, sendParams }, algod);\n}\n\nexport { transferAlgos };\n//# sourceMappingURL=transfer-algos.mjs.map\n","const LOGIC_ERROR = /transaction ([A-Z0-9]+): logic eval error: (.*). Details: .*pc=([0-9]+).*/;\n/** Wraps key functionality around processing logic errors */\nclass LogicError extends Error {\n    /** Takes an error message and parses out the details of any logic errors in there.\n     * @param error The error message to parse\n     * @returns The logic error details if any, or undefined\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static parseLogicError(error) {\n        const errorMessage = error.message;\n        const res = LOGIC_ERROR.exec(errorMessage);\n        if (res === null || res.length <= 3)\n            return undefined;\n        return {\n            txId: res[1],\n            msg: res[2],\n            desc: errorMessage,\n            pc: parseInt(res[3] ? res[3] : '0'),\n            traces: error.traces,\n        };\n    }\n    /**\n     * Create a new logic error object.\n     * @param errorDetails The details of the logic error\n     * @param program The TEAL source code, split by line\n     * @param map The source map of the TEAL source code\n     */\n    constructor(errorDetails, program, map) {\n        super();\n        this.lines = 5;\n        this.teal_line = 0;\n        this.led = errorDetails;\n        this.program = program;\n        const line = map.getLineForPc(errorDetails.pc);\n        this.teal_line = line === undefined ? 0 : line;\n        this.message = `${this.led.msg}. at:${line}. ${this.led.desc}`;\n        if (this.teal_line > 0) {\n            const start = this.teal_line > this.lines ? this.teal_line - this.lines : 0;\n            const stop = program.length > this.teal_line + this.lines ? this.teal_line + this.lines : program.length;\n            const stack_lines = program.slice(start, stop);\n            stack_lines[stack_lines.length / 2] += ' <--- Error';\n            this.stack = stack_lines.join('\\n');\n        }\n    }\n}\n\nexport { LogicError };\n//# sourceMappingURL=logic-error.mjs.map\n","import algosdk from 'algosdk';\nimport { Buffer } from 'buffer';\nimport { compileTeal, createApp, updateApp, getABIMethodSignature, callApp, getAppGlobalState, getAppLocalState, getAppBoxNames, getAppBoxValue, getAppBoxValueFromABIType } from '../app.mjs';\nimport { replaceDeployTimeControlParams, performTemplateSubstitution, deployApp, getCreatorAppsByName } from '../app-deploy.mjs';\nimport { Config } from '../config.mjs';\nimport { persistSourceMaps } from '../debugging/debugging.mjs';\nimport { getSenderAddress } from '../transaction/transaction.mjs';\nimport { transferAlgos } from '../transfer/transfer-algos.mjs';\nimport { UPDATABLE_TEMPLATE_NAME, DELETABLE_TEMPLATE_NAME } from './app.mjs';\nimport { PersistSourceMapInput } from './debugging.mjs';\nimport { LogicError } from './logic-error.mjs';\n\nvar ABIMethod = algosdk.ABIMethod;\nvar AtomicTransactionComposer = algosdk.AtomicTransactionComposer;\nvar getApplicationAddress = algosdk.getApplicationAddress;\nvar Indexer = algosdk.Indexer;\nvar SourceMap = algosdk.SourceMap;\n/**\n * Determines deploy time control (UPDATABLE, DELETABLE) value by inspecting application specification\n * @param approval TEAL Approval program, not the base64 version found on the appSpec\n * @param appSpec Application Specification\n * @param templateVariableName Template variable\n * @param callConfigKey Call config type\n * @returns true if applicable call config is found, false if not found or undefined if variable not present\n */\nfunction getDeployTimeControl(approval, appSpec, templateVariableName, callConfigKey) {\n    // variable not present, so unknown control value\n    if (!approval.includes(templateVariableName))\n        return undefined;\n    // a bare call for specified CallConfig is present and configured\n    const bareCallConfig = appSpec.bare_call_config[callConfigKey];\n    if (!!bareCallConfig && bareCallConfig !== 'NEVER')\n        return true;\n    // an ABI call for specified CallConfig is present and configured\n    return Object.values(appSpec.hints).some((h) => {\n        const abiCallConfig = h.call_config[callConfigKey];\n        return !!abiCallConfig && abiCallConfig !== 'NEVER';\n    });\n}\n/** Application client - a class that wraps an ARC-0032 app spec and provides high productivity methods to deploy and call the app */\nclass ApplicationClient {\n    // todo: process ABI args as needed to make them nicer to deal with like beaker-ts\n    // todo: support readonly, noop method calls\n    // todo: find create, update, delete, etc. methods from app spec and call them by default\n    // todo: intelligent version management when deploying\n    /**\n     * Create a new ApplicationClient instance\n     * @param appDetails The details of the app\n     * @param algod An algod instance\n     */\n    constructor(appDetails, algod) {\n        const { app, sender, params, deployTimeParams, ...appIdentifier } = appDetails;\n        this.algod = algod;\n        this.appSpec = typeof app == 'string' ? JSON.parse(app) : app;\n        this._appName = appIdentifier.name ?? this.appSpec.contract.name;\n        this.deployTimeParams = deployTimeParams;\n        if (appIdentifier.resolveBy === 'id') {\n            if (appIdentifier.id < 0) {\n                throw new Error(`Attempt to create application client with invalid app id of ${appIdentifier.id}`);\n            }\n            this._appId = appIdentifier.id;\n        }\n        else {\n            this._appId = 0;\n            this._creator = appIdentifier.creatorAddress;\n            if (appIdentifier.findExistingUsing instanceof Indexer) {\n                this.indexer = appIdentifier.findExistingUsing;\n            }\n            else {\n                if (appIdentifier.findExistingUsing.creator !== this._creator) {\n                    throw new Error(`Attempt to create application client with invalid existingDeployments against a different creator (${appIdentifier.findExistingUsing.creator}) instead of expected creator ${this._creator}`);\n                }\n                this.existingDeployments = appIdentifier.findExistingUsing;\n            }\n        }\n        this._appAddress = algosdk.getApplicationAddress(this._appId);\n        this.sender = sender;\n        this.params = params;\n    }\n    /**\n     * Compiles the approval and clear programs and sets up the source map.\n     * @param compilation The deploy-time parameters for the compilation\n     * @returns The compiled approval and clear programs\n     */\n    async compile(compilation) {\n        const { deployTimeParams, updatable, deletable } = compilation ?? {};\n        const approvalTemplate = Buffer.from(this.appSpec.source.approval, 'base64').toString('utf-8');\n        const approval = replaceDeployTimeControlParams(performTemplateSubstitution(approvalTemplate, deployTimeParams ?? this.deployTimeParams), {\n            updatable,\n            deletable,\n        });\n        const approvalCompiled = await compileTeal(approval, this.algod);\n        this._approvalSourceMap = approvalCompiled?.sourceMap;\n        const clearTemplate = Buffer.from(this.appSpec.source.clear, 'base64').toString('utf-8');\n        const clear = performTemplateSubstitution(clearTemplate, deployTimeParams ?? this.deployTimeParams);\n        const clearCompiled = await compileTeal(clear, this.algod);\n        this._clearSourceMap = clearCompiled?.sourceMap;\n        if (Config.debug && Config.projectRoot) {\n            persistSourceMaps({\n                sources: [\n                    PersistSourceMapInput.fromCompiledTeal(approvalCompiled, this._appName, 'approval.teal'),\n                    PersistSourceMapInput.fromCompiledTeal(clearCompiled, this._appName, 'clear.teal'),\n                ],\n                projectRoot: Config.projectRoot,\n                client: this.algod,\n                withSources: true,\n            });\n        }\n        return { approvalCompiled, clearCompiled };\n    }\n    /**\n     * Export the current source maps for the app.\n     * @returns The source maps\n     */\n    exportSourceMaps() {\n        if (!this._approvalSourceMap || !this._clearSourceMap) {\n            throw new Error(\"Unable to export source maps; they haven't been loaded into this client - you need to call create, update, or deploy first\");\n        }\n        return {\n            approvalSourceMap: this._approvalSourceMap,\n            clearSourceMap: this._clearSourceMap,\n        };\n    }\n    /**\n     * Import source maps for the app.\n     * @param sourceMaps The source maps to import\n     */\n    importSourceMaps(sourceMaps) {\n        this._approvalSourceMap = new SourceMap(sourceMaps.approvalSourceMap);\n        this._clearSourceMap = new SourceMap(sourceMaps.clearSourceMap);\n    }\n    /**\n     * Idempotently deploy (create, update/delete if changed) an app against the given name via the given creator account, including deploy-time template placeholder substitutions.\n     *\n     * To understand the architecture decisions behind this functionality please see https://github.com/algorandfoundation/algokit-cli/blob/main/docs/architecture-decisions/2023-01-12_smart-contract-deployment.md\n     *\n     * **Note:** if there is a breaking state schema change to an existing app (and `onSchemaBreak` is set to `'replace'`) the existing app will be deleted and re-created.\n     *\n     * **Note:** if there is an update (different TEAL code) to an existing app (and `onUpdate` is set to `'replace'`) the existing app will be deleted and re-created.\n     * @param deploy Deployment details\n     * @returns The metadata and transaction result(s) of the deployment, or just the metadata if it didn't need to issue transactions\n     */\n    async deploy(deploy) {\n        const { schema, sender: deploySender, version, allowUpdate, allowDelete, sendParams, createArgs, createOnCompleteAction, updateArgs, deleteArgs, ...deployArgs } = deploy ?? {};\n        if (this._appId !== 0) {\n            throw new Error(`Attempt to deploy app which already has an app id of ${this._appId}`);\n        }\n        const sender = deploySender ?? this.sender;\n        if (!sender) {\n            throw new Error('No sender provided, unable to deploy app');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const from = sender ?? this.sender;\n        if (!this._creator) {\n            throw new Error(\"Attempt to `deploy` a contract without specifying `resolveBy: 'creatorAndName'` in the constructor\");\n        }\n        if (this._creator !== getSenderAddress(from)) {\n            throw new Error(`Attempt to deploy contract with a sender address (${getSenderAddress(from)}) that differs from the given creator address for this application client: ${this._creator}`);\n        }\n        const approval = Buffer.from(this.appSpec.source.approval, 'base64').toString('utf-8');\n        const compilation = {\n            deployTimeParams: deployArgs.deployTimeParams,\n            updatable: allowUpdate !== undefined\n                ? allowUpdate\n                : getDeployTimeControl(approval, this.appSpec, UPDATABLE_TEMPLATE_NAME, 'update_application'),\n            deletable: allowDelete !== undefined\n                ? allowDelete\n                : getDeployTimeControl(approval, this.appSpec, DELETABLE_TEMPLATE_NAME, 'delete_application'),\n        };\n        const { approvalCompiled, clearCompiled } = await this.compile(compilation);\n        try {\n            await this.getAppReference();\n            const result = await deployApp({\n                from: sender,\n                approvalProgram: approvalCompiled.compiledBase64ToBytes,\n                clearStateProgram: clearCompiled.compiledBase64ToBytes,\n                metadata: {\n                    name: this._appName,\n                    version: version ?? '1.0',\n                    updatable: compilation.updatable,\n                    deletable: compilation.deletable,\n                },\n                schema: {\n                    globalByteSlices: this.appSpec.state.global.num_byte_slices,\n                    globalInts: this.appSpec.state.global.num_uints,\n                    localByteSlices: this.appSpec.state.local.num_byte_slices,\n                    localInts: this.appSpec.state.local.num_uints,\n                    ...schema,\n                },\n                transactionParams: this.params,\n                ...(sendParams ?? {}),\n                existingDeployments: this.existingDeployments,\n                createArgs: await this.getCallArgs(createArgs, sender),\n                createOnCompleteAction: createOnCompleteAction,\n                updateArgs: await this.getCallArgs(updateArgs, sender),\n                deleteArgs: await this.getCallArgs(deleteArgs, sender),\n                ...deployArgs,\n            }, this.algod, this.indexer);\n            // Nothing needed to happen\n            if (result.operationPerformed === 'nothing') {\n                return result;\n            }\n            if (!this.existingDeployments) {\n                throw new Error('Expected existingDeployments to be present');\n            }\n            const { transaction, confirmation, operationPerformed, ...appMetadata } = result;\n            this.existingDeployments = {\n                creator: this.existingDeployments.creator,\n                apps: { ...this.existingDeployments.apps, [this._appName]: appMetadata },\n            };\n            return { ...result, ...{ compiledApproval: approvalCompiled, compiledClear: clearCompiled } };\n        }\n        catch (e) {\n            throw this.exposeLogicError(e);\n        }\n    }\n    /**\n     * Creates a smart contract app, returns the details of the created app.\n     * @param create The parameters to create the app with\n     * @returns The details of the created app, or the transaction to create it if `skipSending` and the compilation result\n     */\n    async create(create) {\n        const { sender: createSender, note, sendParams, deployTimeParams, updatable, deletable, onCompleteAction, schema, ...args } = create ?? {};\n        if (this._appId !== 0) {\n            throw new Error(`Attempt to create app which already has an app id of ${this._appId}`);\n        }\n        const sender = createSender ?? this.sender;\n        if (!sender) {\n            throw new Error('No sender provided, unable to create app');\n        }\n        const { approvalCompiled, clearCompiled } = await this.compile(create);\n        try {\n            const result = await createApp({\n                from: sender,\n                approvalProgram: approvalCompiled.compiledBase64ToBytes,\n                clearStateProgram: clearCompiled.compiledBase64ToBytes,\n                schema: {\n                    globalByteSlices: this.appSpec.state.global.num_byte_slices,\n                    globalInts: this.appSpec.state.global.num_uints,\n                    localByteSlices: this.appSpec.state.local.num_byte_slices,\n                    localInts: this.appSpec.state.local.num_uints,\n                    ...schema,\n                },\n                onCompleteAction,\n                args: await this.getCallArgs(args, sender),\n                note: note,\n                transactionParams: this.params,\n                ...(sendParams ?? {}),\n            }, this.algod);\n            if (result.confirmation) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this._appId = result.confirmation.applicationIndex;\n                this._appAddress = getApplicationAddress(this._appId);\n            }\n            return { ...result, ...{ compiledApproval: approvalCompiled, compiledClear: clearCompiled } };\n        }\n        catch (e) {\n            throw this.exposeLogicError(e);\n        }\n    }\n    /**\n     * Updates the smart contract app.\n     * @param update The parameters to update the app with\n     * @returns The transaction send result and the compilation result\n     */\n    async update(update) {\n        const { sender: updateSender, note, sendParams, deployTimeParams, updatable, deletable, ...args } = update ?? {};\n        if (this._appId === 0) {\n            throw new Error(`Attempt to update app which doesn't have an app id defined`);\n        }\n        const sender = updateSender ?? this.sender;\n        if (!sender) {\n            throw new Error('No sender provided, unable to create app');\n        }\n        const { approvalCompiled, clearCompiled } = await this.compile(update);\n        try {\n            const result = await updateApp({\n                appId: this._appId,\n                from: sender,\n                approvalProgram: approvalCompiled.compiledBase64ToBytes,\n                clearStateProgram: clearCompiled.compiledBase64ToBytes,\n                args: await this.getCallArgs(args, sender),\n                note: note,\n                transactionParams: this.params,\n                ...(sendParams ?? {}),\n            }, this.algod);\n            return { ...result, ...{ compiledApproval: approvalCompiled, compiledClear: clearCompiled } };\n        }\n        catch (e) {\n            throw this.exposeLogicError(e);\n        }\n    }\n    /**\n     * Issues a no_op (normal) call to the app.\n     * @param call The call details.\n     * @returns The result of the call\n     */\n    async call(call) {\n        if (\n        // ABI call\n        call?.method &&\n            // We aren't skipping the send\n            !call.sendParams?.skipSending &&\n            // There isn't an ATC passed in\n            !call.sendParams?.atc &&\n            // The method is readonly\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.appSpec.hints[getABIMethodSignature(this.getABIMethod(call.method))].read_only) {\n            const atc = new AtomicTransactionComposer();\n            await this.callOfType({ ...call, sendParams: { ...call.sendParams, atc } }, 'no_op');\n            const result = await atc.simulate(this.algod);\n            if (result.simulateResponse.txnGroups.some((group) => group.failureMessage)) {\n                throw new Error(result.simulateResponse.txnGroups.find((x) => x.failureMessage)?.failureMessage);\n            }\n            const txns = atc.buildGroup();\n            return {\n                transaction: txns[txns.length - 1].txn,\n                confirmation: result.simulateResponse.txnGroups[0].txnResults.at(-1)?.txnResult,\n                confirmations: result.simulateResponse.txnGroups[0].txnResults.map((t) => t.txnResult),\n                transactions: txns.map((t) => t.txn),\n                return: (result.methodResults?.length ?? 0 > 0) ? result.methodResults[result.methodResults.length - 1] : undefined,\n            };\n        }\n        return await this.callOfType(call, 'no_op');\n    }\n    /**\n     * Issues a opt_in call to the app.\n     * @param call The call details.\n     * @returns The result of the call\n     */\n    async optIn(call) {\n        return await this.callOfType(call, 'opt_in');\n    }\n    /**\n     * Issues a close_out call to the app.\n     * @param call The call details.\n     * @returns The result of the call\n     */\n    async closeOut(call) {\n        return await this.callOfType(call, 'close_out');\n    }\n    /**\n     * Issues a clear_state call to the app.\n     * @param call The call details.\n     * @returns The result of the call\n     */\n    async clearState(call) {\n        return await this.callOfType(call, 'clear_state');\n    }\n    /**\n     * Issues a delete_application call to the app.\n     * @param call The call details.\n     * @returns The result of the call\n     */\n    async delete(call) {\n        return await this.callOfType(call, 'delete_application');\n    }\n    /**\n     * Issues a call to the app with the given call type.\n     * @param call The call details.\n     * @param callType The call type\n     * @returns The result of the call\n     */\n    async callOfType(call = {}, callType) {\n        const { sender: callSender, note, sendParams, ...args } = call;\n        const sender = callSender ?? this.sender;\n        if (!sender) {\n            throw new Error('No sender provided, unable to call app');\n        }\n        const appMetadata = await this.getAppReference();\n        if (appMetadata.appId === 0) {\n            throw new Error(`Attempt to call an app that can't be found '${this._appName}' for creator '${this._creator}'.`);\n        }\n        try {\n            return await callApp({\n                appId: appMetadata.appId,\n                callType: callType,\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                from: sender,\n                args: await this.getCallArgs(args, sender),\n                note: note,\n                transactionParams: this.params,\n                ...(sendParams ?? {}),\n            }, this.algod);\n        }\n        catch (e) {\n            throw this.exposeLogicError(e);\n        }\n    }\n    /**\n     * Funds ALGOs into the app account for this app.\n     * @param fund The parameters for the funding or the funding amount\n     * @returns The result of the funding\n     */\n    async fundAppAccount(fund) {\n        const { amount, sender, note, sendParams } = 'microAlgos' in fund ? { amount: fund } : fund;\n        if (!sender && !this.sender) {\n            throw new Error('No sender provided, unable to call app');\n        }\n        const ref = await this.getAppReference();\n        return await transferAlgos({\n            to: ref.appAddress,\n            amount: amount,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            from: sender ?? this.sender,\n            note: note,\n            transactionParams: this.params,\n            ...(sendParams ?? {}),\n        }, this.algod);\n    }\n    /**\n     * Returns global state for the current app.\n     * @returns The global state\n     */\n    async getGlobalState() {\n        const appRef = await this.getAppReference();\n        if (appRef.appId === 0) {\n            throw new Error('No app has been created yet, unable to get global state');\n        }\n        return getAppGlobalState(appRef.appId, this.algod);\n    }\n    /**\n     * Returns local state for the given account / account address.\n     * @returns The global state\n     */\n    async getLocalState(account) {\n        const appRef = await this.getAppReference();\n        if (appRef.appId === 0) {\n            throw new Error('No app has been created yet, unable to get global state');\n        }\n        return getAppLocalState(appRef.appId, account, this.algod);\n    }\n    /**\n     * Returns the names of all current boxes for the current app.\n     * @returns The names of the boxes\n     */\n    async getBoxNames() {\n        const appRef = await this.getAppReference();\n        if (appRef.appId === 0) {\n            throw new Error('No app has been created yet, unable to get global state');\n        }\n        return await getAppBoxNames(appRef.appId, this.algod);\n    }\n    /**\n     * Returns the value of the given box for the current app.\n     * @param name The name of the box to return either as a string, binary array or `BoxName`\n     * @returns The current box value as a byte array\n     */\n    async getBoxValue(name) {\n        const appRef = await this.getAppReference();\n        if (appRef.appId === 0) {\n            throw new Error('No app has been created yet, unable to get global state');\n        }\n        return await getAppBoxValue(appRef.appId, name, this.algod);\n    }\n    /**\n     * Returns the value of the given box for the current app.\n     * @param name The name of the box to return either as a string, binary array or `BoxName`\n     * @param type\n     * @returns The current box value as a byte array\n     */\n    async getBoxValueFromABIType(name, type) {\n        const appRef = await this.getAppReference();\n        if (appRef.appId === 0) {\n            throw new Error('No app has been created yet, unable to get global state');\n        }\n        return await getAppBoxValueFromABIType({ appId: appRef.appId, boxName: name, type }, this.algod);\n    }\n    /**\n     * Returns the values of all current boxes for the current app.\n     * Note: This will issue multiple HTTP requests (one per box) and it's not an atomic operation so values may be out of sync.\n     * @param filter Optional filter to filter which boxes' values are returned\n     * @returns The (name, value) pair of the boxes with values as raw byte arrays\n     */\n    async getBoxValues(filter) {\n        const appRef = await this.getAppReference();\n        if (appRef.appId === 0) {\n            throw new Error('No app has been created yet, unable to get global state');\n        }\n        const names = await this.getBoxNames();\n        return await Promise.all(names\n            .filter(filter ?? ((_) => true))\n            .map(async (boxName) => ({ name: boxName, value: await getAppBoxValue(appRef.appId, boxName, this.algod) })));\n    }\n    /**\n     * Returns the values of all current boxes for the current app decoded using an ABI Type.\n     * Note: This will issue multiple HTTP requests (one per box) and it's not an atomic operation so values may be out of sync.\n     * @param type The ABI type to decode the values with\n     * @param filter Optional filter to filter which boxes' values are returned\n     * @returns The (name, value) pair of the boxes with values as the ABI Value\n     */\n    async getBoxValuesFromABIType(type, filter) {\n        const appRef = await this.getAppReference();\n        if (appRef.appId === 0) {\n            throw new Error('No app has been created yet, unable to get global state');\n        }\n        const names = await this.getBoxNames();\n        return await Promise.all(names.filter(filter ?? ((_) => true)).map(async (boxName) => ({\n            name: boxName,\n            value: await getAppBoxValueFromABIType({ appId: appRef.appId, boxName, type }, this.algod),\n        })));\n    }\n    /**\n     * Returns the arguments for an app call for the given ABI method or raw method specification.\n     * @param args The call args specific to this application client\n     * @param sender The sender of this call. Will be used to fetch any default argument values if applicable\n     * @returns The call args ready to pass into an app call\n     */\n    async getCallArgs(args, sender) {\n        if (!args) {\n            return undefined;\n        }\n        if (args.method) {\n            const abiMethod = this.getABIMethodParams(args.method);\n            if (!abiMethod) {\n                throw new Error(`Attempt to call ABI method ${args.method}, but it wasn't found`);\n            }\n            const methodSignature = getABIMethodSignature(abiMethod);\n            return {\n                ...args,\n                method: abiMethod,\n                methodArgs: await Promise.all(args.methodArgs.map(async (arg, index) => {\n                    if (arg !== undefined)\n                        return arg;\n                    const argName = abiMethod.args[index].name;\n                    const defaultValueStrategy = argName && this.appSpec.hints?.[methodSignature]?.default_arguments?.[argName];\n                    if (!defaultValueStrategy)\n                        throw new Error(`Argument at position ${index} with the name ${argName} is undefined and does not have a default value strategy`);\n                    switch (defaultValueStrategy.source) {\n                        case 'constant':\n                            return defaultValueStrategy.data;\n                        case 'abi-method': {\n                            const method = defaultValueStrategy.data;\n                            const result = await this.callOfType({\n                                method: getABIMethodSignature(method),\n                                methodArgs: method.args.map(() => undefined),\n                                sender,\n                            }, 'no_op');\n                            return result.return?.returnValue;\n                        }\n                        case 'local-state':\n                        case 'global-state': {\n                            const state = defaultValueStrategy.source === 'global-state' ? await this.getGlobalState() : await this.getLocalState(sender);\n                            const key = defaultValueStrategy.data;\n                            if (key in state) {\n                                return state[key].value;\n                            }\n                            else {\n                                throw new Error(`Preparing default value for argument at position ${index} with the name ${argName} resulted in the failure: The key '${key}' could not be found in ${defaultValueStrategy.source}`);\n                            }\n                        }\n                    }\n                })),\n            };\n        }\n        else {\n            return args;\n        }\n    }\n    /**\n     * Returns the ABI Method parameters for the given method name string for the app represented by this application client instance\n     * @param method Either the name of the method or the ABI method spec definition string\n     * @returns The ABI method params for the given method\n     */\n    getABIMethodParams(method) {\n        if (!method.includes('(')) {\n            const methods = this.appSpec.contract.methods.filter((m) => m.name === method);\n            if (methods.length > 1) {\n                throw new Error(`Received a call to method ${method} in contract ${this._appName}, but this resolved to multiple methods; please pass in an ABI signature instead: ${methods\n                    .map(getABIMethodSignature)\n                    .join(', ')}`);\n            }\n            return methods[0];\n        }\n        return this.appSpec.contract.methods.find((m) => getABIMethodSignature(m) === method);\n    }\n    /**\n     * Returns the ABI Method for the given method name string for the app represented by this application client instance\n     * @param method Either the name of the method or the ABI method spec definition string\n     * @returns The ABI method for the given method\n     */\n    getABIMethod(method) {\n        const methodParams = this.getABIMethodParams(method);\n        return methodParams ? new ABIMethod(methodParams) : undefined;\n    }\n    /**\n     * Gets the reference information for the current application instance.\n     * `appId` will be 0 if it can't find an app.\n     * @returns The app reference, or if deployed using the `deploy` method, the app metadata too\n     */\n    async getAppReference() {\n        if (!this.existingDeployments && this._creator) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.existingDeployments = await getCreatorAppsByName(this._creator, this.indexer);\n        }\n        if (this.existingDeployments && this._appId === 0) {\n            const app = this.existingDeployments.apps[this._appName];\n            if (!app) {\n                return {\n                    appId: 0,\n                    appAddress: getApplicationAddress(0),\n                };\n            }\n            return app;\n        }\n        return {\n            appId: this._appId,\n            appAddress: this._appAddress,\n        };\n    }\n    /**\n     * Takes an error that may include a logic error from a smart contract call and re-exposes the error to include source code information via the source map.\n     * This is automatically used within `ApplicationClient` but if you pass `skipSending: true` e.g. if doing a group transaction\n     *  then you can use this in a try/catch block to get better debugging information.\n     * @param e The error to parse\n     * @param isClear Whether or not the code was running the clear state program\n     * @returns The new error, or if there was no logic error or source map then the wrapped error with source details\n     */\n    exposeLogicError(e, isClear) {\n        if ((!isClear && this._approvalSourceMap == undefined) || (isClear && this._clearSourceMap == undefined))\n            return e;\n        const errorDetails = LogicError.parseLogicError(e);\n        if (errorDetails !== undefined)\n            return new LogicError(errorDetails, Buffer.from(isClear ? this.appSpec.source.clear : this.appSpec.source.approval, 'base64')\n                .toString()\n                .split('\\n'), \n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            isClear ? this._clearSourceMap : this._approvalSourceMap);\n        else\n            return e;\n    }\n}\n\nexport { ApplicationClient };\n//# sourceMappingURL=app-client.mjs.map\n","import algosdk from 'algosdk';\nimport { Config } from './config.mjs';\nimport { getSenderAddress, getTransactionParams, encodeTransactionNote, encodeLease, sendTransaction, sendGroupOfTransactions, MAX_TRANSACTION_GROUP_SIZE } from './transaction/transaction.mjs';\n\nvar ValidationType;\n(function (ValidationType) {\n    ValidationType[ValidationType[\"OptIn\"] = 0] = \"OptIn\";\n    ValidationType[ValidationType[\"OptOut\"] = 1] = \"OptOut\";\n})(ValidationType || (ValidationType = {}));\nfunction* chunks(arr, n) {\n    for (let i = 0; i < arr.length; i += n)\n        yield arr.slice(i, i + n);\n}\nasync function ensureAssetBalanceConditions(account, assetIds, validationType, algod) {\n    const accountAddress = getSenderAddress(account);\n    const accountInfo = await algod.accountInformation(accountAddress).do();\n    const assetPromises = assetIds.map(async (assetId) => {\n        if (validationType === ValidationType.OptIn) {\n            if (accountInfo.assets.find((a) => a['asset-id'] === assetId)) {\n                Config.logger.debug(`Account ${accountAddress} has already opted-in to asset ${assetId}`);\n                return assetId;\n            }\n        }\n        else if (validationType === ValidationType.OptOut) {\n            try {\n                const accountAssetInfo = await algod.accountAssetInformation(accountAddress, assetId).do();\n                if (accountAssetInfo['asset-holding']['amount'] !== 0) {\n                    Config.logger.debug(`Asset ${assetId} is not with zero balance`);\n                    return assetId;\n                }\n            }\n            catch (e) {\n                Config.logger.debug(`Account ${accountAddress} does not have asset ${assetId}`);\n                return assetId;\n            }\n        }\n        return null;\n    });\n    const invalidAssets = (await Promise.all(assetPromises)).filter((assetId) => assetId !== null);\n    if (invalidAssets.length > 0) {\n        let errorMessage = '';\n        if (validationType === ValidationType.OptIn) {\n            errorMessage = `Asset${invalidAssets.length === 1 ? '' : 's'} ${invalidAssets.join(', ')} cannot be opted in. Ensure that they are valid and that the account has not previously opted into them.`;\n        }\n        else if (validationType === ValidationType.OptOut) {\n            errorMessage = `Asset${invalidAssets.length === 1 ? '' : 's'} ${invalidAssets.join(', ')} cannot be opted out. Ensure that they are valid and that the account has previously opted into them and holds zero balance.`;\n        }\n        throw new Error(errorMessage);\n    }\n}\n/**\n * Create an Algorand Standard Asset (ASA).\n * @param create The asset creation definition\n * @param algod An algod client\n * @returns The transaction object and optionally the confirmation if it was sent to the chain (`skipSending` is `false` or unset)\n *\n * @example Usage example\n * ```typescript\n * await algokit.createAsset({ creator: account, total: 1, decimals: 0, name: 'My asset' }, algod)\n * ```\n */\nasync function createAsset(create, algod) {\n    const { creator, total, decimals, name, unit, url, metadataHash, manager, reserveAccount, freezeAccount, clawbackAccount, frozenByDefault, note, transactionParams, lease, ...sendParams } = create;\n    const transaction = algosdk.makeAssetCreateTxnWithSuggestedParamsFromObject({\n        from: getSenderAddress(creator),\n        total,\n        decimals,\n        assetName: name,\n        unitName: unit,\n        assetURL: url,\n        defaultFrozen: frozenByDefault ?? false,\n        assetMetadataHash: metadataHash,\n        manager: manager ? getSenderAddress(manager) : undefined,\n        reserve: reserveAccount ? getSenderAddress(reserveAccount) : undefined,\n        freeze: freezeAccount ? getSenderAddress(freezeAccount) : undefined,\n        clawback: clawbackAccount ? getSenderAddress(clawbackAccount) : undefined,\n        rekeyTo: undefined,\n        suggestedParams: await getTransactionParams(transactionParams, algod),\n        note: encodeTransactionNote(note),\n    });\n    const encodedLease = encodeLease(lease);\n    if (encodedLease) {\n        transaction.addLease(encodedLease);\n    }\n    const result = await sendTransaction({ transaction, from: creator, sendParams }, algod);\n    if (!sendParams.skipSending) {\n        Config.getLogger(sendParams.suppressLog).info(`Successfully created asset ${name ? `${name} ` : ''}${unit ? `(${unit}) ` : ''} with ${total} units and ${decimals} decimals via transaction ${transaction.txID()} with asset index ${result.confirmation?.assetIndex} and creator ${getSenderAddress(creator)}.`);\n        return result;\n    }\n    return { transaction: result.transaction };\n}\n/**\n * Opt-in an account to an asset.\n * @param optIn The opt-in definition\n * @param algod An algod client\n * @returns The transaction object and optionally the confirmation if it was sent to the chain (`skipSending` is `false` or unset)\n *\n * @example Usage example\n * ```typescript\n * await algokit.assetOptIn({ account, assetId }, algod)\n * ```\n */\nasync function assetOptIn(optIn, algod) {\n    const { account, assetId, note, transactionParams, lease, ...sendParams } = optIn;\n    const transaction = algosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({\n        from: getSenderAddress(account),\n        to: getSenderAddress(account),\n        assetIndex: assetId,\n        amount: 0,\n        rekeyTo: undefined,\n        revocationTarget: undefined,\n        closeRemainderTo: undefined,\n        suggestedParams: await getTransactionParams(transactionParams, algod),\n        note: encodeTransactionNote(note),\n    });\n    const encodedLease = encodeLease(lease);\n    if (encodedLease) {\n        transaction.addLease(encodedLease);\n    }\n    if (!sendParams.skipSending) {\n        Config.getLogger(sendParams.suppressLog).debug(`Opted-in ${getSenderAddress(account)} to asset ${assetId}`);\n    }\n    return sendTransaction({ transaction, from: account, sendParams }, algod);\n}\n/**\n * Opt-out an account from an asset.\n * @param optOut The opt-in definition\n * @param algod An algod client\n * @returns The transaction object and optionally the confirmation if it was sent to the chain (`skipSending` is `false` or unset)\n *\n * @example Usage example\n * ```typescript\n * await algokit.assetOptOut({ account, assetId, assetCreatorAddress }, algod)\n * ```\n */\nasync function assetOptOut(optOut, algod) {\n    const { account, assetId, note, transactionParams, lease, assetCreatorAddress: _assetCreatorAddress, ensureZeroBalance, ...sendParams } = optOut;\n    if (ensureZeroBalance === undefined || ensureZeroBalance) {\n        await ensureAssetBalanceConditions(account, [assetId], ValidationType.OptOut, algod);\n    }\n    const assetCreatorAddress = _assetCreatorAddress ?? (await algod.getAssetByID(assetId).do()).params.creator;\n    const transaction = algosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({\n        from: getSenderAddress(account),\n        to: getSenderAddress(account),\n        assetIndex: assetId,\n        amount: 0,\n        rekeyTo: undefined,\n        revocationTarget: undefined,\n        closeRemainderTo: assetCreatorAddress,\n        suggestedParams: await getTransactionParams(transactionParams, algod),\n        note: encodeTransactionNote(note),\n    });\n    const encodedLease = encodeLease(lease);\n    if (encodedLease) {\n        transaction.addLease(encodedLease);\n    }\n    if (!sendParams.skipSending) {\n        Config.getLogger(sendParams.suppressLog).debug(`Opted-out ${getSenderAddress(account)} from asset ${assetId}`);\n    }\n    return sendTransaction({ transaction, from: account, sendParams }, algod);\n}\n/**\n * Opt in to a list of assets on the Algorand blockchain.\n *\n * @param optIn - The bulk opt-in request.\n * @param algod - An instance of the Algodv2 class from the `algosdk` library.\n * @returns A record object where the keys are the asset IDs and the values are the corresponding transaction IDs for successful opt-ins.\n * @throws If there is an error during the opt-in process.\n * @example algokit.bulkOptIn({ account: account, assetIds: [12345, 67890] }, algod)\n */\nasync function assetBulkOptIn(optIn, algod) {\n    const { account, assetIds, validateBalances, transactionParams, note, maxFee, suppressLog } = optIn;\n    const result = {};\n    if (validateBalances === undefined || validateBalances) {\n        await ensureAssetBalanceConditions(account, assetIds, ValidationType.OptIn, algod);\n    }\n    const suggestedParams = await getTransactionParams(transactionParams, algod);\n    for (const assetGroup of chunks(assetIds, MAX_TRANSACTION_GROUP_SIZE)) {\n        try {\n            const transactionsToSign = await Promise.all(assetGroup.map(async (assetId) => ({\n                transaction: (await assetOptIn({\n                    account,\n                    assetId,\n                    transactionParams: suggestedParams,\n                    note,\n                    maxFee,\n                    skipSending: true,\n                    suppressLog: true,\n                }, algod)).transaction,\n                signer: account,\n            })));\n            const txnGrp = {\n                transactions: transactionsToSign,\n                signer: account,\n                sendParams: {\n                    suppressLog: true,\n                },\n            };\n            const sendGroupOfTransactionsResult = await sendGroupOfTransactions(txnGrp, algod);\n            assetGroup.map((assetId, index) => {\n                result[assetId] = sendGroupOfTransactionsResult.txIds[index];\n                Config.getLogger(suppressLog).info(`Successfully opted in ${getSenderAddress(account)} for asset ${assetId} with transaction ID ${sendGroupOfTransactionsResult.txIds[index]},\n          grouped under ${sendGroupOfTransactionsResult.groupId} round ${sendGroupOfTransactionsResult.confirmations?.[0]?.confirmedRound}.`);\n            });\n        }\n        catch (e) {\n            throw new Error(`Received error trying to opt in ${e}`);\n        }\n    }\n    return result;\n}\n/**\n * Opt out of multiple assets in Algorand blockchain.\n *\n * @param optOut The bulk opt-out request.\n * @param algod - An instance of the Algodv2 client used to interact with the Algorand blockchain.\n * @returns A record object containing asset IDs as keys and their corresponding transaction IDs as values.\n * @throws If there is an error during the opt-out process.\n * @example algokit.bulkOptOut({ account: account, assetIds: [12345, 67890] }, algod)\n */\nasync function assetBulkOptOut(optOut, algod) {\n    const { account, validateBalances, transactionParams, note, assetIds, maxFee, suppressLog } = optOut;\n    const result = {};\n    if (validateBalances === undefined || validateBalances) {\n        await ensureAssetBalanceConditions(account, assetIds, ValidationType.OptOut, algod);\n    }\n    const suggestedParams = await getTransactionParams(transactionParams, algod);\n    const assetDetails = await Promise.all(assetIds.map((assetId) => algod.getAssetByID(assetId).do()));\n    for (const assetGroup of chunks(assetDetails, MAX_TRANSACTION_GROUP_SIZE)) {\n        try {\n            const transactionToSign = await Promise.all(assetGroup.map(async (asset) => ({\n                transaction: (await assetOptOut({\n                    account,\n                    assetId: asset.index,\n                    assetCreatorAddress: asset.params.creator,\n                    transactionParams: suggestedParams,\n                    note,\n                    maxFee,\n                    skipSending: true,\n                    suppressLog: true,\n                }, algod)).transaction,\n                signer: account,\n            })));\n            const txnGrp = {\n                transactions: transactionToSign,\n                signer: account,\n                sendParams: {\n                    suppressLog: true,\n                },\n            };\n            const sendGroupOfTransactionsResult = await sendGroupOfTransactions(txnGrp, algod);\n            assetGroup.map((asset, index) => {\n                result[asset.index] = sendGroupOfTransactionsResult.txIds[index];\n                Config.getLogger(suppressLog).info(`Successfully opted out ${getSenderAddress(account)} from asset ${asset.index} with transaction ID ${sendGroupOfTransactionsResult.txIds[index]},\n          grouped under ${sendGroupOfTransactionsResult.groupId} round ${sendGroupOfTransactionsResult.confirmations?.[0]?.confirmedRound}.`);\n            });\n        }\n        catch (e) {\n            throw new Error(`Received error trying to opt out ${e}`);\n        }\n    }\n    return result;\n}\n\nexport { assetBulkOptIn, assetBulkOptOut, assetOptIn, assetOptOut, createAsset };\n//# sourceMappingURL=asset.mjs.map\n","import { ApplicationClient } from './types/app-client.mjs';\n\n/**\n * Create a new ApplicationClient instance\n * @param appDetails The details of the app\n * @param algod An algod instance\n *\n * @example Resolve by creator and name\n * const client = algokit.getAppClient(\n *     {\n *       resolveBy: 'creatorAndName',\n *       app: {appSpec},\n *       sender: {account},\n *       creatorAddress: {creator},\n *       findExistingUsing: indexerClient,\n *     },\n *     algodClient,\n *   )\n *\n * @example Resolve by id:\n * const client = algokit.getAppClient(\n *     {\n *       resolveBy: 'id',\n *       app: {appSpec},\n *       sender: {account},\n *       id: {id},\n *     },\n *    algodClient,\n * )\n *\n * @returns The application client\n */\nfunction getAppClient(appDetails, algod) {\n    return new ApplicationClient(appDetails, algod);\n}\n/**\n * Create a new ApplicationClient instance by id\n * @param appDetails The details of the app\n * @param algod An algod instance\n *\n * @example\n * const client = algokit.getAppClientById(\n *     {\n *       app: {appSpec},\n *       sender: {account},\n *       id: {id},\n *     },\n *     algodClient,\n *   )\n *\n * @returns The application client\n */\nfunction getAppClientById(appDetails, algod) {\n    return new ApplicationClient({ ...appDetails, resolveBy: 'id' }, algod);\n}\n/**\n * Create a new ApplicationClient instance by creator and name\n * @param appDetails The details of the app by creator and name\n * @param algod An algod instance\n *\n * @example\n * const client = algokit.getAppClientByCreatorAndName(\n *     {\n *       app: {appSpec},\n *       sender: {account},\n *       creatorAddress: {account.addr},\n *       findExistingUsing: {indexerClient},\n *     },\n *     algodClient,\n *   )\n *\n * @returns The application client\n */\nfunction getAppClientByCreatorAndName(appDetails, algod) {\n    return new ApplicationClient({ ...appDetails, resolveBy: 'creatorAndName' }, algod);\n}\n\nexport { getAppClient, getAppClientByCreatorAndName, getAppClientById };\n//# sourceMappingURL=app-client.mjs.map\n","const baseUrl = 'https://api.dispenser.algorandfoundation.tools';\nconst dispenserRequestTimeout = 15;\nconst dispenserAccessTokenKey = 'ALGOKIT_DISPENSER_ACCESS_TOKEN';\nvar DispenserAssetName;\n(function (DispenserAssetName) {\n    DispenserAssetName[DispenserAssetName[\"Algo\"] = 0] = \"Algo\";\n})(DispenserAssetName || (DispenserAssetName = {}));\nconst dispenserAssets = {\n    [DispenserAssetName.Algo]: {\n        assetId: 0,\n        decimals: 6,\n        description: 'Algo',\n    },\n};\n/**\n * `TestNetDispenserApiClient` is a class that provides methods to interact with the [Algorand TestNet Dispenser API](https://github.com/algorandfoundation/algokit/blob/main/docs/testnet_api.md).\n * It allows you to fund an address with Algos, refund a transaction, and get the funding limit for the Algo asset.\n *\n * The class requires an authentication token and a request timeout to be initialized. The authentication token can be provided\n * either directly as a parameter or through an `ALGOKIT_DISPENSER_ACCESS_TOKEN` environment variable. If neither is provided, an error is thrown.\n *\n * The request timeout can be provided as a parameter. If not provided, a default value is used.\n *\n * @property {string} authToken - The authentication token used for API requests.\n * @property {number} requestTimeout - The timeout for API requests, in seconds.\n *\n * @method fund - Sends a funding request to the dispenser API to fund the specified address with the given amount of Algo.\n * @method refund - Sends a refund request to the dispenser API for the specified refundTxnId.\n * @method limit - Sends a request to the dispenser API to get the funding limit for the Algo asset.\n *\n * @example\n * ```typescript\n * const client = new TestNetDispenserApiClient({ authToken: 'your_auth_token', requestTimeout: 30 });\n * const fundResponse = await client.fund('your_address', 100);\n * const limitResponse = await client.getLimit();\n * await client.refund('your_transaction_id');\n * ```\n *\n * @throws {Error} If neither the environment variable 'ALGOKIT_DISPENSER_ACCESS_TOKEN' nor the authToken parameter were provided.\n */\nclass TestNetDispenserApiClient {\n    constructor(params) {\n        const authTokenFromEnv = process.env[dispenserAccessTokenKey];\n        if (params?.authToken) {\n            this._authToken = params.authToken;\n        }\n        else if (authTokenFromEnv) {\n            this._authToken = authTokenFromEnv;\n        }\n        else {\n            throw new Error(`Can't init AlgoKit TestNet Dispenser API client because neither environment variable ${dispenserAccessTokenKey} or the authToken were provided.`);\n        }\n        this._requestTimeout = params?.requestTimeout || dispenserRequestTimeout;\n    }\n    get authToken() {\n        return this._authToken;\n    }\n    get requestTimeout() {\n        return this._requestTimeout;\n    }\n    /**\n     * Processes a dispenser API request.\n     *\n     * @param authToken - The authentication token.\n     * @param urlSuffix - The URL suffix for the API request.\n     * @param body - The request body.\n     * @param method - The HTTP method.\n     *\n     * @returns The API response.\n     */\n    async processDispenserRequest(authToken, urlSuffix, body = null, method = 'POST') {\n        const headers = { Authorization: `Bearer ${authToken}` };\n        const requestArgs = {\n            method: method,\n            headers: headers,\n            signal: AbortSignal.timeout(this.requestTimeout * 1000),\n        };\n        if (body) {\n            requestArgs.body = JSON.stringify(body);\n        }\n        const response = await fetch(`${baseUrl}/${urlSuffix}`, requestArgs);\n        if (!response.ok) {\n            let error_message = `Error processing dispenser API request: ${response.status}`;\n            let error_response = null;\n            try {\n                error_response = await response.json();\n            }\n            catch (err) {\n                // suppress exception\n            }\n            if (error_response && error_response.code) {\n                error_message = error_response.code;\n            }\n            else if (response.status === 400) {\n                error_message = (await response.json()).message;\n            }\n            throw new Error(error_message);\n        }\n        return response;\n    }\n    /**\n     * Sends a funding request to the dispenser API to fund the specified address with the given amount of Algo.\n     *\n     * @param address - The address to fund.\n     * @param amount - The amount of Algo to fund.\n     *\n     * @returns DispenserFundResponse: An object containing the transaction ID and funded amount.\n     */\n    async fund(address, amount) {\n        const response = await this.processDispenserRequest(this.authToken, `fund/${dispenserAssets[DispenserAssetName.Algo].assetId}`, { receiver: address, amount: amount, assetID: dispenserAssets[DispenserAssetName.Algo].assetId }, 'POST');\n        const content = await response.json();\n        return { txId: content.txID, amount: content.amount };\n    }\n    /**\n     * Sends a refund request to the dispenser API for the specified refundTxnId.\n     *\n     * @param refundTxnId - The transaction ID to refund.\n     */\n    async refund(refundTxnId) {\n        await this.processDispenserRequest(this.authToken, 'refund', { refundTransactionID: refundTxnId }, 'POST');\n    }\n    /**\n     * Sends a request to the dispenser API to get the funding limit for the Algo asset.\n     *\n     * @returns DispenserLimitResponse: An object containing the funding limit amount.\n     */\n    async getLimit() {\n        const response = await this.processDispenserRequest(this.authToken, `fund/${dispenserAssets[DispenserAssetName.Algo].assetId}/limit`, null, 'GET');\n        const content = await response.json();\n        return { amount: content.amount };\n    }\n}\n\nexport { TestNetDispenserApiClient };\n//# sourceMappingURL=dispenser-client.mjs.map\n","import { Buffer } from 'buffer';\n\nclass URLTokenBaseHTTPError extends Error {\n    constructor(message, response) {\n        super(message);\n        this.response = response;\n        this.name = 'URLTokenBaseHTTPError';\n        this.response = response;\n    }\n}\n/**\n * Implementation of BaseHTTPClient that uses a URL and a token\n * and make the REST queries using fetch.\n * This is the default implementation of BaseHTTPClient.\n */\nclass URLTokenBaseHTTPClient {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(tokenHeader, baseServer, port, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    defaultHeaders = {}) {\n        this.defaultHeaders = defaultHeaders;\n        // Append a trailing slash so we can use relative paths. Without the trailing\n        // slash, the last path segment will be replaced by the relative path. See\n        // usage in `addressWithPath`.\n        const fixedBaseServer = baseServer.endsWith('/') ? baseServer : `${baseServer}/`;\n        const baseServerURL = new URL(fixedBaseServer);\n        if (typeof port !== 'undefined') {\n            baseServerURL.port = port.toString();\n        }\n        if (baseServerURL.protocol.length === 0) {\n            throw new Error('Invalid base server URL, protocol must be defined.');\n        }\n        this.baseURL = baseServerURL;\n        this.tokenHeader = tokenHeader;\n    }\n    /**\n     * Compute the URL for a path relative to the instance's address\n     * @param relativePath - A path string\n     * @param query - An optional key-value object of query parameters to add to the URL. If the\n     *   relativePath already has query parameters on it, the additional parameters defined here will\n     *   be added to the URL without modifying those (unless a key collision occurs).\n     * @returns A URL string\n     */\n    getURL(relativePath, query) {\n        let fixedRelativePath;\n        if (relativePath.startsWith('./')) {\n            fixedRelativePath = relativePath;\n        }\n        else if (relativePath.startsWith('/')) {\n            fixedRelativePath = `.${relativePath}`;\n        }\n        else {\n            fixedRelativePath = `./${relativePath}`;\n        }\n        const address = new URL(fixedRelativePath, this.baseURL);\n        if (query) {\n            for (const [key, value] of Object.entries(query)) {\n                address.searchParams.set(key, value);\n            }\n        }\n        return address.toString();\n    }\n    static formatFetchResponseHeaders(headers) {\n        const headersObj = {};\n        headers.forEach((key, value) => {\n            headersObj[key] = value;\n        });\n        return headersObj;\n    }\n    static async checkHttpError(res) {\n        if (res.ok) {\n            return;\n        }\n        let body = null;\n        let bodyErrorMessage = null;\n        try {\n            body = new Uint8Array(await res.arrayBuffer());\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const decoded = JSON.parse(Buffer.from(body).toString());\n            if (decoded.message) {\n                bodyErrorMessage = decoded.message;\n            }\n        }\n        catch (_) {\n            // ignore any error that happened while we are parsing the error response\n        }\n        let message = `Network request error. Received status ${res.status} (${res.statusText})`;\n        if (bodyErrorMessage) {\n            message += `: ${bodyErrorMessage}`;\n        }\n        throw new URLTokenBaseHTTPError(message, {\n            body: body !== null ? body : new Uint8Array(),\n            status: res.status,\n            headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers),\n        });\n    }\n    static async formatFetchResponse(res) {\n        await this.checkHttpError(res);\n        return {\n            body: new Uint8Array(await res.arrayBuffer()),\n            status: res.status,\n            headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers),\n        };\n    }\n    async get(relativePath, query, requestHeaders = {}) {\n        // Expand headers for use in fetch\n        const headers = {\n            ...this.tokenHeader,\n            ...this.defaultHeaders,\n            ...requestHeaders,\n        };\n        const res = await fetch(this.getURL(relativePath, query), {\n            mode: 'cors',\n            headers,\n        });\n        return URLTokenBaseHTTPClient.formatFetchResponse(res);\n    }\n    async post(relativePath, data, query, requestHeaders = {}) {\n        // Expand headers for use in fetch\n        const headers = {\n            ...this.tokenHeader,\n            ...this.defaultHeaders,\n            ...requestHeaders,\n        };\n        const res = await fetch(this.getURL(relativePath, query), {\n            method: 'POST',\n            mode: 'cors',\n            body: data,\n            headers,\n        });\n        return URLTokenBaseHTTPClient.formatFetchResponse(res);\n    }\n    async delete(relativePath, data, query, requestHeaders = {}) {\n        // Expand headers for use in fetch\n        const headers = {\n            ...this.tokenHeader,\n            ...this.defaultHeaders,\n            ...requestHeaders,\n        };\n        const res = await fetch(this.getURL(relativePath, query), {\n            method: 'DELETE',\n            mode: 'cors',\n            body: data,\n            headers,\n        });\n        return URLTokenBaseHTTPClient.formatFetchResponse(res);\n    }\n}\n\nexport { URLTokenBaseHTTPClient };\n//# sourceMappingURL=urlTokenBaseHTTPClient.mjs.map\n","import { Config } from '../config.mjs';\nimport { URLTokenBaseHTTPClient } from './urlTokenBaseHTTPClient.mjs';\n\n/** A HTTP Client that wraps the Algorand SDK HTTP Client with retries */\nclass AlgoHttpClientWithRetry extends URLTokenBaseHTTPClient {\n    async callWithRetry(func) {\n        let response;\n        let numTries = 1;\n        do {\n            try {\n                response = await func();\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }\n            catch (err) {\n                if (numTries >= AlgoHttpClientWithRetry.MAX_TRIES) {\n                    throw err;\n                }\n                // Only retry for one of the hardcoded conditions\n                if (!(AlgoHttpClientWithRetry.RETRY_ERROR_CODES.includes(err.code) ||\n                    AlgoHttpClientWithRetry.RETRY_STATUS_CODES.includes(Number(err.status)) ||\n                    ('response' in err && AlgoHttpClientWithRetry.RETRY_STATUS_CODES.includes(Number(err.response.status))))) {\n                    throw err;\n                }\n                // Retry immediately the first time, then exponentially backoff.\n                const delayTimeMs = numTries == 1 ? 0 : Math.min(1000 * Math.pow(2, numTries - 1), AlgoHttpClientWithRetry.MAX_BACKOFF_MS);\n                if (delayTimeMs > 0) {\n                    await new Promise((r) => setTimeout(r, delayTimeMs));\n                }\n                Config.logger.warn(`algosdk request failed ${numTries} times. Retrying in ${delayTimeMs}ms: ${err}`);\n            }\n        } while (!response && ++numTries <= AlgoHttpClientWithRetry.MAX_TRIES);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return response;\n    }\n    async get(relativePath, query, requestHeaders = {}) {\n        return await this.callWithRetry(() => super.get(relativePath, query, requestHeaders));\n    }\n    async post(relativePath, data, query, requestHeaders = {}) {\n        return await this.callWithRetry(() => super.post(relativePath, data, query, requestHeaders));\n    }\n    async delete(relativePath, data, query, requestHeaders = {}) {\n        return await this.callWithRetry(() => super.delete(relativePath, data, query, requestHeaders));\n    }\n}\nAlgoHttpClientWithRetry.MAX_TRIES = 5;\nAlgoHttpClientWithRetry.MAX_BACKOFF_MS = 10000;\n// These lists come from https://visionmedia.github.io/superagent/#retrying-requests\n// which is the underlying library used by algosdk - but the CloudFlare specific 52X status codes have been removed\nAlgoHttpClientWithRetry.RETRY_STATUS_CODES = [408, 413, 429, 500, 502, 503, 504];\nAlgoHttpClientWithRetry.RETRY_ERROR_CODES = [\n    'ETIMEDOUT',\n    'ECONNRESET',\n    'EADDRINUSE',\n    'ECONNREFUSED',\n    'EPIPE',\n    'ENOTFOUND',\n    'ENETUNREACH',\n    'EAI_AGAIN',\n    'EPROTO', // We get this intermittently with AlgoNode API\n];\n\nexport { AlgoHttpClientWithRetry };\n//# sourceMappingURL=algo-http-client-with-retry.mjs.map\n","import algosdk from 'algosdk';\nimport { AlgoHttpClientWithRetry } from './algo-http-client-with-retry.mjs';\nimport { ApplicationClient } from './app-client.mjs';\nimport { TestNetDispenserApiClient } from './dispenser-client.mjs';\n\nvar Kmd = algosdk.Kmd;\nvar Indexer = algosdk.Indexer;\nvar IntDecoding = algosdk.IntDecoding;\n/** Exposes access to various API clients. */\nclass ClientManager {\n    /**\n     * algosdk clients or config for interacting with the official Algorand APIs.\n     * @param clientsOrConfig The clients or config to use\n     * @example Algod client only\n     * ```typescript\n     * const clientManager = new ClientManager({ algod: algodClient })\n     * ```\n     * @example All clients\n     * ```typescript\n     * const clientManager = new ClientManager({ algod: algodClient, indexer: indexerClient, kmd: kmdClient })\n     * ```\n     * @example Algod config only\n     * ```typescript\n     * const clientManager = new ClientManager({ algodConfig })\n     * ```\n     * @example All client configs\n     * ```typescript\n     * const clientManager = new ClientManager({ algodConfig, indexerConfig, kmdConfig })\n     * ```\n     */\n    constructor(clientsOrConfig) {\n        const _clients = 'algod' in clientsOrConfig\n            ? clientsOrConfig\n            : {\n                algod: ClientManager.getAlgodClient(clientsOrConfig.algodConfig),\n                indexer: clientsOrConfig.indexerConfig ? ClientManager.getIndexerClient(clientsOrConfig.indexerConfig) : undefined,\n                kmd: clientsOrConfig.kmdConfig ? ClientManager.getKmdClient(clientsOrConfig.kmdConfig) : undefined,\n            };\n        this._algod = _clients.algod;\n        this._indexer = _clients.indexer;\n        this._kmd = _clients.kmd;\n    }\n    /** Returns an algosdk Algod API client. */\n    get algod() {\n        return this._algod;\n    }\n    /** Returns an algosdk Indexer API client or throws an error if it's not been provided. */\n    get indexer() {\n        if (!this._indexer)\n            throw new Error('Attempt to use Indexer client in AlgoKit instance with no Indexer configured');\n        return this._indexer;\n    }\n    /** Returns an algosdk KMD API client or throws an error if it's not been provided. */\n    get kmd() {\n        if (!this._kmd)\n            throw new Error('Attempt to use Kmd client in AlgoKit instance with no Kmd configured');\n        return this._kmd;\n    }\n    /**\n     * Get details about the current network.\n     * @example Getting genesis ID\n     * ```typescript\n     * const network = await networkClient.network()\n     * const genesisId = network.genesisId\n     * ```\n     * @returns The current network details\n     */\n    async network() {\n        if (!this._getNetworkPromise) {\n            this._getNetworkPromise = this._algod.getTransactionParams().do();\n        }\n        const params = await this._getNetworkPromise;\n        return {\n            isTestNet: ['testnet-v1.0', 'testnet-v1', 'testnet'].includes(params.genesisID),\n            isMainNet: ['mainnet-v1.0', 'mainnet-v1', 'mainnet'].includes(params.genesisID),\n            isLocalNet: ClientManager.genesisIdIsLocalNet(params.genesisID),\n            genesisId: params.genesisID,\n            genesisHash: params.genesisHash,\n        };\n    }\n    /**\n     * Returns true if the given network genesisId is associated with a LocalNet network.\n     * @param genesisId The network genesis ID\n     * @returns Whether the given genesis ID is associated with a LocalNet network\n     */\n    static genesisIdIsLocalNet(genesisId) {\n        return genesisId === 'devnet-v1' || genesisId === 'sandnet-v1' || genesisId === 'dockernet-v1';\n    }\n    /**\n     * Returns true if the current network is LocalNet.\n     * @returns True if the current network is LocalNet.\n     */\n    async isLocalNet() {\n        return (await this.network()).isLocalNet;\n    }\n    /**\n     * Returns true if the current network is TestNet.\n     * @returns True if the current network is TestNet.\n     */\n    async isTestNet() {\n        return (await this.network()).isTestNet;\n    }\n    /**\n     * Returns true if the current network is MainNet.\n     * @returns True if the current network is MainNet.\n     */\n    async isMainNet() {\n        return (await this.network()).isMainNet;\n    }\n    /**\n     * Returns a TestNet Dispenser API client.\n     * Refer to [docs](https://github.com/algorandfoundation/algokit/blob/main/docs/testnet_api.md) on guidance to obtain an access token.\n     *\n     * @param params An object containing parameters for the TestNetDispenserApiClient class.\n     *  Or null if you want the client to load the access token from the environment variable `ALGOKIT_DISPENSER_ACCESS_TOKEN`.\n     * @example\n     * const client = clientManager.getTestNetDispenser(\n     *     {\n     *       authToken: 'your_auth_token',\n     *       requestTimeout: 15,\n     *     }\n     * )\n     *\n     * @returns An instance of the TestNetDispenserApiClient class.\n     */\n    getTestNetDispenser(params = null) {\n        return new TestNetDispenserApiClient(params);\n    }\n    /**\n     * Returns a new `ApplicationClient` client, resolving the app by creator address and name.\n     * @param details The details to resolve the app by creator address and name\n     * @param cachedAppLookup A cached app lookup that matches a name to on-chain details; either this is needed or indexer is required to be passed in to this manager on construction.\n     * @returns The `ApplicationClient`\n     */\n    getAppClientByCreatorAndName(details, cachedAppLookup) {\n        return new ApplicationClient({ ...details, resolveBy: 'creatorAndName', findExistingUsing: cachedAppLookup ?? this.indexer }, this._algod);\n    }\n    /**\n     * Returns a new `ApplicationClient` client, resolving the app by app ID.\n     * @param details The details to resolve the app by ID\n     * @returns The `ApplicationClient`\n     */\n    getAppClientById(details) {\n        return new ApplicationClient({ ...details, resolveBy: 'id' }, this._algod);\n    }\n    /**\n     * Returns a new typed client, resolving the app by creator address and name.\n     * @param typedClient The typed client type to use\n     * @param details The details to resolve the app by creator address and name\n     * @param cachedAppLookup A cached app lookup that matches a name to on-chain details; either this is needed or indexer is required to be passed in to this manager on construction.\n     * @returns The typed client instance\n     */\n    getTypedAppClientByCreatorAndName(typedClient, details, cachedAppLookup) {\n        return new typedClient({ ...details, resolveBy: 'creatorAndName', findExistingUsing: cachedAppLookup ?? this.indexer }, this._algod);\n    }\n    /**\n     * Returns a new typed client, resolving the app by app ID.\n     * @param typedClient The typed client type to use\n     * @param details The details to resolve the app by ID\n     * @returns The typed client instance\n     */\n    getTypedAppClientById(typedClient, details) {\n        return new typedClient({ ...details, resolveBy: 'id' }, this._algod);\n    }\n    /**\n     * Retrieve client configurations from environment variables when defined or get defaults (expects to be called from a Node.js environment)\n     *\n     * If both `process.env.INDEXER_SERVER` and `process.env.ALGOD_SERVER` is defined it will use both along with optional `process.env.ALGOD_PORT`, `process.env.ALGOD_TOKEN`, `process.env.INDEXER_PORT` and `process.env.INDEXER_TOKEN`.\n     *\n     * If only `process.env.ALGOD_SERVER` is defined it will use this along with optional `process.env.ALGOD_PORT` and `process.env.ALGOD_TOKEN` and leave indexer as `undefined`.\n     *\n     * If only `process.env.INDEXER_SERVER` is defined it will use the default (LocalNet) configuration for both algod and indexer.\n     *\n     * It will return a KMD configuration that uses `process.env.KMD_PORT` (or port 4002) if `process.env.ALGOD_SERVER` is defined,\n     * otherwise it will use the default LocalNet config unless it detects testnet or mainnet.\n     * @example\n     * ```typescript\n     * const config = ClientManager.getConfigFromEnvironmentOrLocalNet()\n     * ```\n     * @returns The config for algod, indexer and kmd\n     */\n    static getConfigFromEnvironmentOrLocalNet() {\n        if (!process || !process.env) {\n            throw new Error('Attempt to get default client configuration from a non Node.js context; supply the config instead');\n        }\n        const [algodConfig, indexerConfig, kmdConfig] = process.env.ALGOD_SERVER\n            ? [\n                ClientManager.getAlgodConfigFromEnvironment(),\n                process.env.INDEXER_SERVER ? ClientManager.getIndexerConfigFromEnvironment() : undefined,\n                !process.env.ALGOD_SERVER.includes('mainnet') && !process.env.ALGOD_SERVER.includes('testnet')\n                    ? { ...ClientManager.getAlgodConfigFromEnvironment(), port: process?.env?.KMD_PORT ?? '4002' }\n                    : undefined,\n            ]\n            : [\n                ClientManager.getDefaultLocalNetConfig('algod'),\n                ClientManager.getDefaultLocalNetConfig('indexer'),\n                ClientManager.getDefaultLocalNetConfig('kmd'),\n            ];\n        return {\n            algodConfig,\n            indexerConfig,\n            kmdConfig,\n        };\n    }\n    /** Retrieve the algod configuration from environment variables (expects to be called from a Node.js environment)\n     *\n     * Expects `process.env.ALGOD_SERVER` to be defined, and you can also specify `process.env.ALGOD_PORT` and `process.env.ALGOD_TOKEN`.\n     */\n    static getAlgodConfigFromEnvironment() {\n        if (!process || !process.env) {\n            throw new Error('Attempt to get default algod configuration from a non Node.js context; supply the config instead');\n        }\n        if (!process.env.ALGOD_SERVER) {\n            throw new Error('Attempt to get default algod configuration without specifying ALGOD_SERVER in the environment variables');\n        }\n        return {\n            server: process.env.ALGOD_SERVER,\n            port: process.env.ALGOD_PORT,\n            token: process.env.ALGOD_TOKEN,\n        };\n    }\n    /**\n     * Retrieve the indexer configuration from environment variables (expects to be called from a Node.js environment).\n     *\n     * Expects `process.env.INDEXER_SERVER` to be defined, and you can also specify `process.env.INDEXER_PORT` and `process.env.INDEXER_TOKEN`.\n     */\n    static getIndexerConfigFromEnvironment() {\n        if (!process || !process.env) {\n            throw new Error('Attempt to get default indexer configuration from a non Node.js context; supply the config instead');\n        }\n        if (!process.env.INDEXER_SERVER) {\n            throw new Error('Attempt to get default indexer configuration without specifying INDEXER_SERVER in the environment variables');\n        }\n        return {\n            server: process.env.INDEXER_SERVER,\n            port: process.env.INDEXER_PORT,\n            token: process.env.INDEXER_TOKEN,\n        };\n    }\n    /** Returns the Algorand configuration to point to the free tier of the AlgoNode service.\n     *\n     * @param network Which network to connect to - TestNet or MainNet\n     * @param config Which algod config to return - Algod or Indexer\n     */\n    static getAlgoNodeConfig(network, config) {\n        return {\n            server: `https://${network}-${config === 'algod' ? 'api' : 'idx'}.algonode.cloud/`,\n            port: 443,\n        };\n    }\n    /** Returns the Algorand configuration to point to the default LocalNet.\n     *\n     * @param configOrPort Which algod config to return - algod, kmd, or indexer OR a port number\n     */\n    static getDefaultLocalNetConfig(configOrPort) {\n        return {\n            server: `http://localhost`,\n            port: configOrPort === 'algod' ? 4001 : configOrPort === 'indexer' ? 8980 : configOrPort === 'kmd' ? 4002 : configOrPort,\n            token: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n        };\n    }\n    /**\n     * Returns an algod SDK client that automatically retries on idempotent calls.\n     *\n     * @param config The config of the client\n     * @example AlgoNode (testnet)\n     * ```typescript\n     *  const algod = ClientManager.getAlgodClient(ClientManager.getAlgoNodeConfig('testnet', 'algod'))\n     *  await algod.healthCheck().do()\n     * ```\n     * @example AlgoNode (mainnet)\n     * ```typescript\n     *  const algod = ClientManager.getAlgodClient(ClientManager.getAlgoNodeConfig('mainnet', 'algod'))\n     *  await algod.healthCheck().do()\n     * ```\n     * @example Custom (e.g. default LocalNet)\n     * ```typescript\n     *  const algod = ClientManager.getAlgodClient({server: 'http://localhost', port: '4001', token: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'})\n     *  await algod.healthCheck().do()\n     * ```\n     */\n    static getAlgodClient(config) {\n        const { token, server, port } = config;\n        const tokenHeader = typeof token === 'string' ? { 'X-Algo-API-Token': token } : token ?? {};\n        const httpClientWithRetry = new AlgoHttpClientWithRetry(tokenHeader, server, port);\n        return new algosdk.Algodv2(httpClientWithRetry, server);\n    }\n    /**\n     * Returns an algod SDK client that automatically retries on idempotent calls loaded from environment variables (expects to be called from a Node.js environment).\n     *\n     * @example\n     *  ```typescript\n     *  // Uses process.env.ALGOD_SERVER, process.env.ALGOD_PORT and process.env.ALGOD_TOKEN\n     *  const algod = ClientManager.getAlgodClientFromEnvironment()\n     *  await algod.healthCheck().do()\n     *  ```\n     */\n    static getAlgodClientFromEnvironment() {\n        return ClientManager.getAlgodClient(ClientManager.getAlgodConfigFromEnvironment());\n    }\n    /**\n     * Returns an indexer SDK client that automatically retries on idempotent calls\n     *\n     * @param config The config of the client\n     * @param overrideIntDecoding Override the default int decoding for responses, uses MIXED by default to avoid lost precision for big integers\n     * @example AlgoNode (testnet)\n     * ```typescript\n     *  const indexer = ClientManager.getIndexerClient(ClientManager.getAlgoNodeConfig('testnet', 'indexer'))\n     *  await indexer.makeHealthCheck().do()\n     * ```\n     * @example AlgoNode (mainnet)\n     * ```typescript\n     *  const indexer = ClientManager.getIndexerClient(ClientManager.getAlgoNodeConfig('mainnet', 'indexer'))\n     *  await indexer.makeHealthCheck().do()\n     * ```\n     * @example Custom (e.g. default LocalNet, although we recommend loading this into a .env and using the Default option instead)\n     * ```typescript\n     *  const indexer = ClientManager.getIndexerClient({server: 'http://localhost', port: '8980', token: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'})\n     *  await indexer.makeHealthCheck().do()\n     * ```\n     * @example Override int decoding for responses\n     * ```typescript\n     *  const indexer = ClientManager.getIndexerClient(config, IntDecoding.BIGINT)\n     * ```\n     */\n    static getIndexerClient(config, overrideIntDecoding) {\n        const { token, server, port } = config;\n        const tokenHeader = typeof token === 'string' ? { 'X-Indexer-API-Token': token } : token ?? {};\n        const httpClientWithRetry = new AlgoHttpClientWithRetry(tokenHeader, server, port);\n        const indexer = new Indexer(httpClientWithRetry);\n        // Use mixed int decoding by default so bigints don't have lost precision\n        indexer.setIntEncoding(overrideIntDecoding ?? IntDecoding.MIXED);\n        return indexer;\n    }\n    /**\n     * Returns an indexer SDK client that automatically retries on idempotent calls loaded from environment variables (expects to be called from a Node.js environment).\n     *\n     * @param overrideIntDecoding Override the default int decoding for responses, uses MIXED by default to avoid lost precision for big integers\n     * @example\n     *\n     *  ```typescript\n     *  // Uses process.env.INDEXER_SERVER, process.env.INDEXER_PORT and process.env.INDEXER_TOKEN\n     *  const indexer = ClientManager.getIndexerClientFromEnvironment()\n     *  await indexer.makeHealthCheck().do()\n     *  ```\n     */\n    static getIndexerClientFromEnvironment(overrideIntDecoding) {\n        return ClientManager.getIndexerClient(ClientManager.getIndexerConfigFromEnvironment(), overrideIntDecoding);\n    }\n    /**\n     * Returns a KMD SDK client.\n     *\n     * KMD client allows you to export private keys, which is useful to (for instance) get the default account in a LocalNet network.\n     *\n     * @param config The config for the client\n     * @example Custom (e.g. default LocalNet, although we recommend loading this into a .env and using the Default option instead)\n     * ```typescript\n     *  const kmd = ClientManager.getKmdClient({server: 'http://localhost', port: '4002', token: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'})\n     * ```\n     */\n    static getKmdClient(config) {\n        const { token, server, port } = config;\n        return new Kmd(token, server, port);\n    }\n    /**\n     * Returns a KMD SDK client that automatically retries on idempotent calls loaded from environment variables (expects to be called from a Node.js environment).\n     *\n     * @example\n     *  ```typescript\n     *  // Uses process.env.ALGOD_SERVER, process.env.KMD_PORT (or if not specified: port 4002) and process.env.ALGOD_TOKEN\n     *  const kmd = ClientManager.getKmdClientFromEnvironment()\n     *  ```\n     */\n    static getKmdClientFromEnvironment() {\n        // We can only use Kmd on the LocalNet otherwise it's not exposed so this makes some assumptions\n        // (e.g. same token and server as algod and port 4002 by default)\n        return ClientManager.getKmdClient({ ...ClientManager.getAlgodConfigFromEnvironment(), port: process?.env?.KMD_PORT ?? '4002' });\n    }\n}\n\nexport { ClientManager };\n//# sourceMappingURL=client-manager.mjs.map\n","import algosdk from 'algosdk';\n\n/** Wrapper class to ensure safe, explicit conversion between µAlgos, Algos and numbers */\nclass AlgoAmount {\n    /** Return the amount as a number in µAlgos */\n    get microAlgos() {\n        return this.amountInMicroAlgos;\n    }\n    /** Return the amount as a number in Algos */\n    get algos() {\n        return algosdk.microalgosToAlgos(this.amountInMicroAlgos);\n    }\n    constructor(amount) {\n        this.amountInMicroAlgos = 'microAlgos' in amount ? amount.microAlgos : algosdk.algosToMicroalgos(amount.algos);\n    }\n    toString() {\n        return `${this.microAlgos.toLocaleString('en-US')} µALGO${this.microAlgos === 1 ? '' : 's'}`;\n    }\n    /** valueOf allows you to use `AlgoAmount` in comparison operations such as `<` and `>=` etc.,\n     * but it's not recommended to use this to convert to a number, it's much safer to explicitly call\n     * the algos or microAlgos properties\n     */\n    valueOf() {\n        return this.microAlgos;\n    }\n    /** Create a `AlgoAmount` object representing the given number of Algos */\n    static Algos(amount) {\n        return new AlgoAmount({ algos: amount });\n    }\n    /** Create a `AlgoAmount` object representing the given number of µAlgos */\n    static MicroAlgos(amount) {\n        return new AlgoAmount({ microAlgos: amount });\n    }\n}\n\nexport { AlgoAmount };\n//# sourceMappingURL=amount.mjs.map\n","import algosdk from 'algosdk';\nimport { AlgoAmount } from './types/amount.mjs';\n\nNumber.prototype.microAlgos = function () {\n    return AlgoAmount.MicroAlgos(this);\n};\nNumber.prototype.algos = function () {\n    return AlgoAmount.Algos(this);\n};\n/** Returns an amount of Algos using AlgoAmount\n * @param algos The amount in Algos\n */\nconst algos = (algos) => {\n    return AlgoAmount.Algos(algos);\n};\n/** Returns an amount of µAlgos using AlgoAmount\n * @param microAlgos The amount in µAlgos\n */\nconst microAlgos = (microAlgos) => {\n    return AlgoAmount.MicroAlgos(microAlgos);\n};\n/** Returns an amount of µAlgos to cover standard fees for the given number of transactions using AlgoAmount\n * @param numberOfTransactions The of standard transaction fees to return the amount of ALGOs\n */\nconst transactionFees = (numberOfTransactions) => {\n    return AlgoAmount.MicroAlgos(numberOfTransactions * algosdk.ALGORAND_MIN_TX_FEE);\n};\n\nexport { algos, microAlgos, transactionFees };\n//# sourceMappingURL=amount.mjs.map\n","import algosdk from 'algosdk';\nimport { encodeLease, encodeTransactionNote, sendAtomicTransactionComposer } from '../transaction/transaction.mjs';\nimport { ClientManager } from './client-manager.mjs';\n\nvar isTransactionWithSigner = algosdk.isTransactionWithSigner;\nvar encodeAddress = algosdk.encodeAddress;\n/** AlgoKit Composer helps you compose and execute transactions as a transaction group.\n *\n * Note: this class is a new Beta feature and may be subject to change.\n *\n * @beta\n */\nclass AlgokitComposer {\n    /**\n     * Create an `AlgoKitComposer`.\n     * @param params The configuration for this composer\n     */\n    constructor(params) {\n        /** The ATC used to compose the group */\n        this.atc = new algosdk.AtomicTransactionComposer();\n        /** Map of txid to ABI method */\n        this.txnMethodMap = new Map();\n        /** Transactions that have not yet been composed */\n        this.txns = [];\n        /** The default transaction validity window */\n        this.defaultValidityWindow = 10;\n        /** Whether the validity window was explicitly set on construction */\n        this.defaultValidityWindowIsExplicit = false;\n        this.algod = params.algod;\n        const defaultGetSuggestedParams = () => params.algod.getTransactionParams().do();\n        this.getSuggestedParams = params.getSuggestedParams ?? defaultGetSuggestedParams;\n        this.getSigner = params.getSigner;\n        this.defaultValidityWindow = params.defaultValidityWindow ?? this.defaultValidityWindow;\n        this.defaultValidityWindowIsExplicit = params.defaultValidityWindow !== undefined;\n    }\n    /**\n     * Add a payment transaction to the transaction group.\n     * @param params The payment transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addPayment(params) {\n        this.txns.push({ ...params, type: 'pay' });\n        return this;\n    }\n    /**\n     * Add an asset create transaction to the transaction group.\n     * @param params The asset create transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addAssetCreate(params) {\n        this.txns.push({ ...params, type: 'assetCreate' });\n        return this;\n    }\n    /**\n     * Add an asset config transaction to the transaction group.\n     * @param params The asset config transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addAssetConfig(params) {\n        this.txns.push({ ...params, type: 'assetConfig' });\n        return this;\n    }\n    /**\n     * Add an asset freeze transaction to the transaction group.\n     * @param params The asset freeze transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addAssetFreeze(params) {\n        this.txns.push({ ...params, type: 'assetFreeze' });\n        return this;\n    }\n    /**\n     * Add an asset destroy transaction to the transaction group.\n     * @param params The asset destroy transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addAssetDestroy(params) {\n        this.txns.push({ ...params, type: 'assetDestroy' });\n        return this;\n    }\n    /**\n     * Add an asset transfer transaction to the transaction group.\n     * @param params The asset transfer transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addAssetTransfer(params) {\n        this.txns.push({ ...params, type: 'assetTransfer' });\n        return this;\n    }\n    /**\n     * Add an asset opt-in transaction to the transaction group.\n     * @param params The asset opt-in transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addAssetOptIn(params) {\n        this.txns.push({ ...params, type: 'assetOptIn' });\n        return this;\n    }\n    /**\n     * Add an application call transaction to the transaction group.\n     *\n     * Note: we recommend using app clients to make it easier to make app calls.\n     * @param params The application call transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addAppCall(params) {\n        this.txns.push({ ...params, type: 'appCall' });\n        return this;\n    }\n    /**\n     * Add an ABI method application call transaction to the transaction group.\n     *\n     * Note: we recommend using app clients to make it easier to make app calls.\n     * @param params The ABI method application call transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addMethodCall(params) {\n        this.txns.push({ ...params, type: 'methodCall' });\n        return this;\n    }\n    /**\n     * Add an online key registration transaction to the transaction group.\n     * @param params The online key registration transaction parameters\n     * @returns The composer so you can chain method calls\n     */\n    addOnlineKeyRegistration(params) {\n        this.txns.push({ ...params, type: 'keyReg' });\n        return this;\n    }\n    /**\n     * Add the transactions within an `AtomicTransactionComposer` to the transaction group.\n     * @param atc The `AtomicTransactionComposer` to build transactions from and add to the group\n     * @returns The composer so you can chain method calls\n     */\n    addAtc(atc) {\n        this.txns.push({ atc, type: 'atc' });\n        return this;\n    }\n    buildAtc(atc) {\n        const group = atc.buildGroup();\n        const txnWithSigners = group.map((ts) => {\n            ts.txn.group = undefined;\n            return ts;\n        });\n        const method = atc['methodCalls'].get(group.length - 1);\n        if (method)\n            this.txnMethodMap.set(txnWithSigners.at(-1).txn.txID(), method);\n        return txnWithSigners;\n    }\n    commonTxnBuildStep(params, txn, suggestedParams) {\n        if (params.lease)\n            txn.addLease(encodeLease(params.lease));\n        if (params.rekeyTo)\n            txn.addRekey(params.rekeyTo);\n        if (params.note)\n            txn.note = encodeTransactionNote(params.note);\n        if (params.firstValidRound) {\n            txn.firstRound = Number(params.firstValidRound);\n        }\n        if (params.lastValidRound) {\n            txn.lastRound = Number(params.lastValidRound);\n        }\n        else {\n            // If the validity window isn't set in this transaction or by default and we are pointing at\n            //  LocalNet set a bigger window to avoid dead transactions\n            const window = params.validityWindow ??\n                (!this.defaultValidityWindowIsExplicit && ClientManager.genesisIdIsLocalNet(suggestedParams.genesisID)\n                    ? 1000\n                    : this.defaultValidityWindow);\n            txn.lastRound = txn.firstRound + window;\n        }\n        if (params.staticFee !== undefined && params.extraFee !== undefined) {\n            throw Error('Cannot set both staticFee and extraFee');\n        }\n        if (params.staticFee !== undefined) {\n            txn.fee = params.staticFee.microAlgos;\n        }\n        else {\n            txn.fee = txn.estimateSize() * suggestedParams.fee || algosdk.ALGORAND_MIN_TX_FEE;\n            if (params.extraFee)\n                txn.fee += params.extraFee.microAlgos;\n        }\n        txn.flatFee = true;\n        if (params.maxFee !== undefined && txn.fee > params.maxFee.microAlgos) {\n            throw Error(`Transaction fee ${txn.fee} is greater than maxFee ${params.maxFee}`);\n        }\n        return txn;\n    }\n    async buildMethodCall(params, suggestedParams) {\n        const methodArgs = [];\n        const isAbiValue = (x) => {\n            if (Array.isArray(x))\n                return x.length == 0 || x.every(isAbiValue);\n            return ['boolean', 'number', 'bigint', 'string', 'Uint8Array'].includes(typeof x);\n        };\n        for (const arg of params.args ?? []) {\n            if (isAbiValue(arg)) {\n                methodArgs.push(arg);\n                continue;\n            }\n            if (isTransactionWithSigner(arg)) {\n                methodArgs.push(arg);\n                continue;\n            }\n            if ('method' in arg) {\n                const tempTxnWithSigners = await this.buildMethodCall(arg, suggestedParams);\n                methodArgs.push(...tempTxnWithSigners);\n                continue;\n            }\n            const txn = await arg;\n            methodArgs.push({\n                txn,\n                signer: params.signer\n                    ? 'signer' in params.signer\n                        ? params.signer.signer\n                        : params.signer\n                    : this.getSigner(encodeAddress(txn.from.publicKey)),\n            });\n        }\n        const methodAtc = new algosdk.AtomicTransactionComposer();\n        const appID = Number(params.appId || 0);\n        methodAtc.addMethodCall({\n            appID,\n            sender: params.sender,\n            suggestedParams,\n            onComplete: params.onComplete,\n            appAccounts: params.accountReferences,\n            appForeignApps: params.appReferences?.map((x) => Number(x)),\n            appForeignAssets: params.assetReferences?.map((x) => Number(x)),\n            approvalProgram: params.approvalProgram,\n            clearProgram: params.clearProgram,\n            extraPages: params.extraPages,\n            numLocalInts: params.schema?.localUints || (appID === 0 ? 0 : undefined),\n            numLocalByteSlices: params.schema?.localByteSlices || (appID === 0 ? 0 : undefined),\n            numGlobalInts: params.schema?.globalUints || (appID === 0 ? 0 : undefined),\n            numGlobalByteSlices: params.schema?.globalByteSlices || (appID === 0 ? 0 : undefined),\n            method: params.method,\n            signer: params.signer ? ('signer' in params.signer ? params.signer.signer : params.signer) : this.getSigner(params.sender),\n            methodArgs: methodArgs,\n            // note, lease, and rekeyTo are set in the common build step\n            note: undefined,\n            lease: undefined,\n            rekeyTo: undefined,\n        });\n        // Run the actual method call txn through the common build step to set fees and validity rounds\n        const group = methodAtc.buildGroup();\n        const methodIdx = group.length - 1;\n        group[methodIdx].txn = this.commonTxnBuildStep(params, group[methodIdx].txn, suggestedParams);\n        return this.buildAtc(methodAtc);\n    }\n    buildPayment(params, suggestedParams) {\n        const txn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({\n            from: params.sender,\n            to: params.receiver,\n            amount: params.amount.microAlgos,\n            closeRemainderTo: params.closeRemainderTo,\n            suggestedParams,\n        });\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    buildAssetCreate(params, suggestedParams) {\n        const txn = algosdk.makeAssetCreateTxnWithSuggestedParamsFromObject({\n            from: params.sender,\n            total: params.total,\n            decimals: params.decimals ?? 0,\n            assetName: params.assetName,\n            unitName: params.unitName,\n            assetURL: params.url,\n            defaultFrozen: params.defaultFrozen ?? false,\n            assetMetadataHash: params.metadataHash,\n            manager: params.manager,\n            reserve: params.reserve,\n            freeze: params.freeze,\n            clawback: params.clawback,\n            suggestedParams,\n        });\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    buildAssetConfig(params, suggestedParams) {\n        const txn = algosdk.makeAssetConfigTxnWithSuggestedParamsFromObject({\n            from: params.sender,\n            assetIndex: Number(params.assetId),\n            suggestedParams,\n            manager: params.manager,\n            reserve: params.reserve,\n            freeze: params.freeze,\n            clawback: params.clawback,\n            strictEmptyAddressChecking: false,\n        });\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    buildAssetDestroy(params, suggestedParams) {\n        const txn = algosdk.makeAssetDestroyTxnWithSuggestedParamsFromObject({\n            from: params.sender,\n            assetIndex: Number(params.assetId),\n            suggestedParams,\n        });\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    buildAssetFreeze(params, suggestedParams) {\n        const txn = algosdk.makeAssetFreezeTxnWithSuggestedParamsFromObject({\n            from: params.sender,\n            assetIndex: Number(params.assetId),\n            freezeTarget: params.account,\n            freezeState: params.frozen,\n            suggestedParams,\n        });\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    buildAssetTransfer(params, suggestedParams) {\n        const txn = algosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({\n            from: params.sender,\n            to: params.receiver,\n            assetIndex: Number(params.assetId),\n            amount: params.amount,\n            suggestedParams,\n            closeRemainderTo: params.closeAssetTo,\n            revocationTarget: params.clawbackTarget,\n        });\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    buildAppCall(params, suggestedParams) {\n        const sdkParams = {\n            from: params.sender,\n            suggestedParams,\n            onComplete: params.onComplete,\n            approvalProgram: params.approvalProgram,\n            clearProgram: params.clearProgram,\n            appArgs: params.args,\n            accounts: params.accountReferences,\n            foreignApps: params.appReferences?.map((x) => Number(x)),\n            foreignAssets: params.assetReferences?.map((x) => Number(x)),\n            extraPages: params.extraPages,\n            numLocalInts: params.schema?.localUints || 0,\n            numLocalByteSlices: params.schema?.localByteSlices || 0,\n            numGlobalInts: params.schema?.globalUints || 0,\n            numGlobalByteSlices: params.schema?.globalByteSlices || 0,\n        };\n        let txn;\n        const onComplete = params.onComplete || algosdk.OnApplicationComplete.NoOpOC;\n        if (!params.appId) {\n            if (params.approvalProgram === undefined || params.clearProgram === undefined) {\n                throw new Error('approvalProgram and clearProgram are required for application creation');\n            }\n            txn = algosdk.makeApplicationCreateTxnFromObject({\n                ...sdkParams,\n                onComplete,\n                approvalProgram: params.approvalProgram,\n                clearProgram: params.clearProgram,\n            });\n        }\n        txn = algosdk.makeApplicationCallTxnFromObject({ ...sdkParams, onComplete, appIndex: Number(params.appId || 0) });\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    buildKeyReg(params, suggestedParams) {\n        const txn = algosdk.makeKeyRegistrationTxnWithSuggestedParams(params.sender, undefined, params.voteKey, params.selectionKey, Number(params.voteFirst), Number(params.voteLast), Number(params.voteKeyDilution), suggestedParams, undefined, false, params.stateProofKey);\n        return this.commonTxnBuildStep(params, txn, suggestedParams);\n    }\n    async buildTxn(txn, suggestedParams) {\n        if (txn.type === 'txnWithSigner') {\n            return [txn];\n        }\n        if (txn.type === 'atc') {\n            return this.buildAtc(txn.atc);\n        }\n        if (txn.type === 'methodCall') {\n            return await this.buildMethodCall(txn, suggestedParams);\n        }\n        const signer = txn.signer ? ('signer' in txn.signer ? txn.signer.signer : txn.signer) : this.getSigner(txn.sender);\n        switch (txn.type) {\n            case 'pay': {\n                const payment = this.buildPayment(txn, suggestedParams);\n                return [{ txn: payment, signer }];\n            }\n            case 'assetCreate': {\n                const assetCreate = this.buildAssetCreate(txn, suggestedParams);\n                return [{ txn: assetCreate, signer }];\n            }\n            case 'appCall': {\n                const appCall = this.buildAppCall(txn, suggestedParams);\n                return [{ txn: appCall, signer }];\n            }\n            case 'assetConfig': {\n                const assetConfig = this.buildAssetConfig(txn, suggestedParams);\n                return [{ txn: assetConfig, signer }];\n            }\n            case 'assetDestroy': {\n                const assetDestroy = this.buildAssetDestroy(txn, suggestedParams);\n                return [{ txn: assetDestroy, signer }];\n            }\n            case 'assetFreeze': {\n                const assetFreeze = this.buildAssetFreeze(txn, suggestedParams);\n                return [{ txn: assetFreeze, signer }];\n            }\n            case 'assetTransfer': {\n                const assetTransfer = this.buildAssetTransfer(txn, suggestedParams);\n                return [{ txn: assetTransfer, signer }];\n            }\n            case 'assetOptIn': {\n                const assetTransfer = this.buildAssetTransfer({ ...txn, receiver: txn.sender, amount: 0n }, suggestedParams);\n                return [{ txn: assetTransfer, signer }];\n            }\n            case 'keyReg': {\n                const keyReg = this.buildKeyReg(txn, suggestedParams);\n                return [{ txn: keyReg, signer }];\n            }\n            default:\n                throw Error(`Unsupported txn type`);\n        }\n    }\n    /**\n     * Compose all of the transactions in a single atomic transaction group and an atomic transaction composer.\n     *\n     * You can then use the transactions standalone, or use the composer to execute or simulate the transactions.\n     * @returns The built atomic transaction composer and the transactions\n     */\n    async build() {\n        if (this.atc.getStatus() === algosdk.AtomicTransactionComposerStatus.BUILDING) {\n            const suggestedParams = await this.getSuggestedParams();\n            const txnWithSigners = [];\n            for (const txn of this.txns) {\n                txnWithSigners.push(...(await this.buildTxn(txn, suggestedParams)));\n            }\n            txnWithSigners.forEach((ts) => {\n                this.atc.addTransaction(ts);\n            });\n            const methodCalls = new Map();\n            txnWithSigners.forEach((ts, idx) => {\n                const method = this.txnMethodMap.get(ts.txn.txID());\n                if (method)\n                    methodCalls.set(idx, method);\n            });\n            this.atc['methodCalls'] = methodCalls;\n        }\n        return { atc: this.atc, transactions: this.atc.buildGroup() };\n    }\n    /**\n     * Rebuild the group, discarding any previously built transactions.\n     * This will potentially cause new signers and suggested params to be used if the callbacks return a new value compared to the first build.\n     * @returns The newly built atomic transaction composer and the transactions\n     */\n    async rebuild() {\n        this.atc = new algosdk.AtomicTransactionComposer();\n        return await this.build();\n    }\n    /**\n     * Compose the atomic transaction group and send it to the network\n     * @param params The parameters to control execution with\n     * @returns The execution result\n     */\n    async execute(params) {\n        const group = (await this.build()).transactions;\n        let waitRounds = params?.maxRoundsToWaitForConfirmation;\n        if (waitRounds === undefined) {\n            const lastRound = group.reduce((max, txn) => Math.max(txn.txn.lastRound, max), 0);\n            const { firstRound } = await this.getSuggestedParams();\n            waitRounds = lastRound - firstRound + 1;\n        }\n        return await sendAtomicTransactionComposer({\n            atc: this.atc,\n            sendParams: { suppressLog: params?.suppressLog, maxRoundsToWaitForConfirmation: waitRounds },\n        }, this.algod);\n    }\n}\n\nexport { AlgokitComposer as default };\n//# sourceMappingURL=composer.mjs.map\n","import algosdk from 'algosdk';\nimport { SigningAccount, MultisigAccount, DISPENSER_ACCOUNT } from './account.mjs';\nimport { KmdAccountManager } from './kmd-account-manager.mjs';\n\nvar LogicSigAccount = algosdk.LogicSigAccount;\nvar AccountInformationModel = algosdk.modelsv2.Account;\nconst memoize = (fn) => {\n    const cache = new Map();\n    const cached = function (val) {\n        return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);\n    };\n    cached.cache = cache;\n    return cached;\n};\n/**\n * Returns a `TransactionSigner` for the given account that can sign a transaction.\n * This function has memoization, so will return the same transaction signer for a given account.\n * @param account An account that can sign a transaction\n * @returns A transaction signer\n */\nconst getAccountTransactionSigner = memoize(function (account) {\n    return 'signer' in account\n        ? account.signer\n        : 'lsig' in account\n            ? algosdk.makeLogicSigAccountTransactionSigner(account)\n            : algosdk.makeBasicAccountTransactionSigner(account);\n});\n/** Creates and keeps track of signing accounts that can sign transactions for a sending address. */\nclass AccountManager {\n    /**\n     * Create a new account manager.\n     * @param clientManager The ClientManager client to use for algod and kmd clients\n     * @example Create a new account manager\n     * ```typescript\n     * const accountManager = new AccountManager(clientManager)\n     * ```\n     */\n    constructor(clientManager) {\n        this._accounts = {};\n        this._clientManager = clientManager;\n        this._kmdAccountManager = new KmdAccountManager(clientManager);\n    }\n    /** KMD account manager that allows you to easily get and create accounts using KMD. */\n    get kmd() {\n        return this._kmdAccountManager;\n    }\n    /**\n     * Sets the default signer to use if no other signer is specified.\n     *\n     * If this isn't set an a transaction needs signing for a given sender\n     * then an error will be thrown from `getSigner` / `getAccount`.\n     * @param signer The signer to use, either a `TransactionSigner` or a `TransactionSignerAccount`\n     * @example\n     * ```typescript\n     * const signer = accountManager.random() // Can be anything that returns a `algosdk.TransactionSigner` or `TransactionSignerAccount`\n     * accountManager.setDefaultSigner(signer)\n     *\n     * // When signing a transaction, if there is no signer registered for the sender then the default signer will be used\n     * const signer = accountManager.getSigner(\"{SENDERADDRESS}\")\n     * ```\n     * @returns The `AccountManager` so method calls can be chained\n     */\n    setDefaultSigner(signer) {\n        this._defaultSigner = 'signer' in signer ? signer.signer : signer;\n        return this;\n    }\n    /**\n     * Records the given account (that can sign) against the address of the provided account for later\n     * retrieval and returns a `TransactionSignerAccount` along with the original account in an `account` property.\n     */\n    signerAccount(account) {\n        const acc = {\n            addr: 'addr' in account ? account.addr : account.address(),\n            signer: getAccountTransactionSigner(account),\n        };\n        this._accounts[acc.addr] = acc;\n        return { ...acc, account };\n    }\n    /**\n     * Tracks the given account for later signing.\n     *\n     * Note: If you are generating accounts via the various methods on `AccountManager`\n     * (like `random`, `fromMnemonic`, `logicsig`, etc.) then they automatically get tracked.\n     * @param account The account to register, which can be a `TransactionSignerAccount` or\n     *  a `algosdk.Account`, `algosdk.LogicSigAccount`, `SigningAccount` or `MultisigAccount`\n     * @example\n     * ```typescript\n     * const accountManager = new AccountManager(clientManager)\n     *  .setSignerFromAccount(algosdk.generateAccount())\n     *  .setSignerFromAccount(new algosdk.LogicSigAccount(program, args))\n     *  .setSignerFromAccount(new SigningAccount(mnemonic, sender))\n     *  .setSignerFromAccount(new MultisigAccount({version: 1, threshold: 1, addrs: [\"ADDRESS1...\", \"ADDRESS2...\"]}, [account1, account2]))\n     *  .setSignerFromAccount({addr: \"SENDERADDRESS\", signer: transactionSigner})\n     * ```\n     * @returns The `AccountManager` instance for method chaining\n     */\n    setSignerFromAccount(account) {\n        this.signerAccount(account);\n        return this;\n    }\n    /**\n     * Tracks the given `algosdk.TransactionSigner` against the given sender address for later signing.\n     * @param sender The sender address to use this signer for\n     * @param signer The `algosdk.TransactionSigner` to sign transactions with for the given sender\n     * @example\n     * ```typescript\n     * const accountManager = new AccountManager(clientManager)\n     *  .setSigner(\"SENDERADDRESS\", transactionSigner)\n     * ```\n     * @returns The `AccountManager` instance for method chaining\n     */\n    setSigner(sender, signer) {\n        this._accounts[sender] = { addr: sender, signer };\n        return this;\n    }\n    /**\n     * Returns the `TransactionSigner` for the given sender address, ready to sign a transaction for that sender.\n     *\n     * If no signer has been registered for that address then the default signer is used if registered and\n     * if not then an error is thrown.\n     *\n     * @param sender The sender address\n     * @example\n     * ```typescript\n     * const signer = accountManager.getSigner(\"SENDERADDRESS\")\n     * ```\n     * @returns The `TransactionSigner` or throws an error if not found and no default signer is set\n     */\n    getSigner(sender) {\n        const signer = this._accounts[sender]?.signer ?? this._defaultSigner;\n        if (!signer)\n            throw new Error(`No signer found for address ${sender}`);\n        return signer;\n    }\n    /**\n     * Returns the `TransactionSignerAccount` for the given sender address.\n     *\n     * If no signer has been registered for that address then an error is thrown.\n     * @param sender The sender address\n     * @example\n     * ```typescript\n     * const sender = accountManager.random().addr\n     * // ...\n     * // Returns the `TransactionSignerAccount` for `sender` that has previously been registered\n     * const account = accountManager.getAccount(sender)\n     * ```\n     * @returns The `TransactionSignerAccount` or throws an error if not found\n     */\n    getAccount(sender) {\n        const account = this._accounts[sender];\n        if (!account)\n            throw new Error(`No signer found for address ${sender}`);\n        return account;\n    }\n    /**\n     * Returns the given sender account's current status, balance and spendable amounts.\n     *\n     * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress)\n     * @example\n     * ```typescript\n     * const address = \"XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA\";\n     * const accountInfo = await accountManager.getInformation(address);\n     * ```\n     *\n     * @param sender The account / address to look up\n     * @returns The account information\n     */\n    async getInformation(sender) {\n        const account = AccountInformationModel.from_obj_for_encoding(await this._clientManager.algod.accountInformation(typeof sender === 'string' ? sender : sender.addr).do());\n        return {\n            ...account,\n            // None of these can practically overflow 2^53\n            amount: Number(account.amount),\n            amountWithoutPendingRewards: Number(account.amountWithoutPendingRewards),\n            minBalance: Number(account.minBalance),\n            pendingRewards: Number(account.pendingRewards),\n            rewards: Number(account.rewards),\n            round: Number(account.round),\n            totalAppsOptedIn: Number(account.totalAppsOptedIn),\n            totalAssetsOptedIn: Number(account.totalAssetsOptedIn),\n            totalCreatedApps: Number(account.totalCreatedApps),\n            totalCreatedAssets: Number(account.totalCreatedAssets),\n            appsTotalExtraPages: account.appsTotalExtraPages ? Number(account.appsTotalExtraPages) : undefined,\n            rewardBase: account.rewardBase ? Number(account.rewardBase) : undefined,\n            totalBoxBytes: account.totalBoxBytes ? Number(account.totalBoxBytes) : undefined,\n            totalBoxes: account.totalBoxes ? Number(account.totalBoxes) : undefined,\n        };\n    }\n    /**\n     * Returns the given sender account's asset holding for a given asset.\n     *\n     * @example\n     * ```typescript\n     * const address = \"XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA\";\n     * const assetId = 123345;\n     * const accountInfo = await accountManager.getAssetInformation(address, assetId);\n     * ```\n     *\n     * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddressassetsasset-id)\n     * @param sender The address of the sender/account to look up\n     * @param assetId The ID of the asset to return a holding for\n     * @returns The account asset holding information\n     */\n    async getAssetInformation(sender, assetId) {\n        const info = await this._clientManager.algod\n            .accountAssetInformation(typeof sender === 'string' ? sender : sender.addr, Number(assetId))\n            .do();\n        return {\n            assetId: BigInt(assetId),\n            balance: BigInt(info['asset-holding']['amount']),\n            frozen: info['asset-holding']['is-frozen'] === true,\n            round: BigInt(info['round']),\n        };\n    }\n    /**\n     * Tracks and returns an Algorand account with secret key loaded (i.e. that can sign transactions) by taking the mnemonic secret.\n     *\n     * @example\n     * ```typescript\n     * const account = accountManager.fromMnemonic(\"mnemonic secret ...\")\n     * const rekeyedAccount = accountManager.fromMnemonic(\"mnemonic secret ...\", \"SENDERADDRESS...\")\n     * ```\n     * @param mnemonicSecret The mnemonic secret representing the private key of an account; **Note: Be careful how the mnemonic is handled**,\n     *  never commit it into source control and ideally load it from the environment (ideally via a secret storage service) rather than the file system.\n     * @param sender The optional sender address to use this signer for (aka a rekeyed account)\n     * @returns The account\n     */\n    fromMnemonic(mnemonicSecret, sender) {\n        const account = algosdk.mnemonicToSecretKey(mnemonicSecret);\n        return this.signerAccount(new SigningAccount(account, sender));\n    }\n    /**\n     * Tracks and returns an Algorand account that is a rekeyed version of the given account to a new sender.\n     *\n     * @example\n     * ```typescript\n     * const account = account.fromMnemonic(\"mnemonic secret ...\")\n     * const rekeyedAccount = accountManager.rekeyed(account, \"SENDERADDRESS...\")\n     * ```\n     * @param account The account to use as the signer for this new rekeyed account\n     * @param sender The sender address to use as the new sender\n     * @returns The account\n     */\n    rekeyed(account, sender) {\n        return this.signerAccount({ addr: sender, signer: account.signer });\n    }\n    /**\n     * Tracks and returns an Algorand account with private key loaded by convention from environment variables based on the given name identifier.\n     *\n     * Note: This function expects to run in a Node.js environment.\n     *\n     * ## Convention:\n     * * **Non-LocalNet:** will load process.env['\\{NAME\\}_MNEMONIC'] as a mnemonic secret; **Note: Be careful how the mnemonic is handled**,\n     *  never commit it into source control and ideally load it via a secret storage service rather than the file system.\n     *   If process.env['\\{NAME\\}_SENDER'] is defined then it will use that for the sender address (i.e. to support rekeyed accounts)\n     * * **LocalNet:** will load the account from a KMD wallet called \\{NAME\\} and if that wallet doesn't exist it will create it and fund the account for you\n     *\n     * This allows you to write code that will work seamlessly in production and local development (LocalNet) without manual config locally (including when you reset the LocalNet).\n     *\n     * @example Default\n     *\n     * If you have a mnemonic secret loaded into `process.env.MY_ACCOUNT_MNEMONIC` then you can call the following to get that private key loaded into an account object:\n     * ```typescript\n     * const account = await accountManager.fromEnvironment('MY_ACCOUNT')\n     * ```\n     *\n     * If that code runs against LocalNet then a wallet called `MY_ACCOUNT` will automatically be created with an account that is automatically funded with 1000 (default) ALGOs from the default LocalNet dispenser.\n     * If not running against LocalNet then it will use proces.env.MY_ACCOUNT_MNEMONIC as the private key and (if present) process.env.MY_ACCOUNT_SENDER as the sender address.\n     *\n     * @param name The name identifier of the account\n     * @param fundWith The optional amount to fund the account with when it gets created (when targeting LocalNet), if not specified then 1000 Algos will be funded from the dispenser account\n     * @returns The account\n     */\n    async fromEnvironment(name, fundWith) {\n        if (!process || !process.env) {\n            throw new Error('Attempt to get account with private key from a non Node.js context; this is not supported!');\n        }\n        const accountMnemonic = process.env[`${name.toUpperCase()}_MNEMONIC`];\n        const sender = process.env[`${name.toUpperCase()}_SENDER`];\n        if (accountMnemonic) {\n            const signer = algosdk.mnemonicToSecretKey(accountMnemonic);\n            return this.signerAccount(new SigningAccount(signer, sender));\n        }\n        if (await this._clientManager.isLocalNet()) {\n            const account = await this._kmdAccountManager.getOrCreateWalletAccount(name, fundWith);\n            return this.signerAccount(account.account);\n        }\n        throw new Error(`Missing environment variable ${name.toUpperCase()}_MNEMONIC when looking for account ${name}`);\n    }\n    /**\n     * Tracks and returns an Algorand account with private key loaded from the given KMD wallet (identified by name).\n     *\n     * @param name The name of the wallet to retrieve an account from\n     * @param predicate An optional filter to use to find the account (otherwise it will return a random account from the wallet)\n     * @param sender The optional sender address to use this signer for (aka a rekeyed account)\n     * @example Get default funded account in a LocalNet\n     *\n     * ```typescript\n     * const defaultDispenserAccount = await account.fromKmd('unencrypted-default-wallet',\n     *   a => a.status !== 'Offline' && a.amount > 1_000_000_000\n     * )\n     * ```\n     * @returns The account\n     */\n    async fromKmd(name, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    predicate, sender) {\n        const account = await this._kmdAccountManager.getWalletAccount(name, predicate, sender);\n        if (!account)\n            throw new Error(`Unable to find KMD account ${name}${predicate ? ' with predicate' : ''}`);\n        return this.signerAccount(account.account);\n    }\n    /**\n     * Tracks and returns an account that supports partial or full multisig signing.\n     *\n     * @example\n     * ```typescript\n     * const account = accountManager.multisig({version: 1, threshold: 1, addrs: [\"ADDRESS1...\", \"ADDRESS2...\"]},\n     *  [(await accountManager.fromEnvironment('ACCOUNT1')).account])\n     * ```\n     * @param multisigParams The parameters that define the multisig account\n     * @param signingAccounts The signers that are currently present\n     * @returns A multisig account wrapper\n     */\n    multisig(multisigParams, signingAccounts) {\n        return this.signerAccount(new MultisigAccount(multisigParams, signingAccounts));\n    }\n    /**\n     * Tracks and returns an account that represents a logic signature.\n     *\n     * @example\n     * ```typescript\n     * const account = account.logicsig(program, [new Uint8Array(3, ...)])\n     * ```\n     * @param program The bytes that make up the compiled logic signature\n     * @param args The (binary) arguments to pass into the logic signature\n     * @returns A logic signature account wrapper\n     */\n    logicsig(program, args) {\n        return this.signerAccount(new LogicSigAccount(program, args));\n    }\n    /**\n     * Tracks and returns a new, random Algorand account with secret key loaded.\n     *\n     * @example\n     * ```typescript\n     * const account = account.random()\n     * ```\n     * @returns The account\n     */\n    random() {\n        return this.signerAccount(algosdk.generateAccount());\n    }\n    /**\n     * Returns an account (with private key loaded) that can act as a dispenser from\n     * environment variables, or against default LocalNet if no environment variables present.\n     *\n     * Note: requires a Node.js environment to execute.\n     *\n     * If present, it will load the account mnemonic stored in process.env.DISPENSER_MNEMONIC and optionally\n     * process.env.DISPENSER_SENDER if it's a rekeyed account.\n     *\n     * @example\n     * ```typescript\n     * const account = await account.dispenserFromEnvironment()\n     * ```\n     *\n     * @returns The account\n     */\n    async dispenserFromEnvironment() {\n        if (!process || !process.env) {\n            throw new Error('Attempt to get dispenser from environment from a non Node.js context; this is not supported!');\n        }\n        return process.env[`${DISPENSER_ACCOUNT.toUpperCase()}_MNEMONIC`]\n            ? await this.fromEnvironment(DISPENSER_ACCOUNT)\n            : await this.localNetDispenser();\n    }\n    /**\n     * Returns an Algorand account with private key loaded for the default LocalNet dispenser account (that can be used to fund other accounts).\n     *\n     * @example\n     * ```typescript\n     * const account = await account.localNetDispenser()\n     * ```\n     * @returns The account\n     */\n    async localNetDispenser() {\n        const dispenser = await this._kmdAccountManager.getLocalNetDispenserAccount();\n        return this.signerAccount(dispenser.account);\n    }\n}\n\nexport { AccountManager, getAccountTransactionSigner };\n//# sourceMappingURL=account-manager.mjs.map\n"],"names":["CAsset","constructor","_defineProperty","__defProp","Object","defineProperty","__defProps","defineProperties","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","prototype","hasOwnProperty","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","key","value","enumerable","configurable","writable","__spreadValues","a","b","prop","call","__spreadProps","__async","__this","__arguments","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","throw","x","done","then","apply","getBoxReferenceApp","appPoolId","taskAppId","appIndex","name","Uint8Array","Buffer","concat","from","getBoxReferenceApp_default","getBoxReferenceUser","userAddress","publicKey","getBoxReferenceUser_default","getPoolManagerApp","env","getPoolManagerApp_default","parseBoxData","input","length","Error","toString","ret","funds","Number","subarray","app","fee","parseBoxData_default","APP_SPEC","BiatecTaskManagerCallFactory","create","createApplication","args","params","method","methodArgs","Array","isArray","update","updateApplication","version","bootstrap","txBaseDeposit","feeAssetId","registerTask","registrationFeeDeposit","task","unregisterTask","indexToDelete","executeTask","taskAppCall","fundTask","deposit","changeTaskFee","unfundTask","amount","payment","sender","receiver","note","assetTransfer","xferAsset","assetAmount","assetReceiver","sendOnlineKeyRegistration","votePk","selectionPk","stateProofPk","voteFirst","voteLast","voteKeyDilution","sendOfflineKeyRegistration","BiatecTaskManagerClient","_BiatecTaskManagerClient","appDetails","algod","this","appClient","mapReturnValue","result","returnValueFormatter","_a","_b","_c","return","decodeError","returnValue","typedCallParams","deploy","createArgs","createCall","updateArgs","updateCall","createOnCompleteAction","onCompleteAction","$this","_0","arguments","clearState","getBinaryState","state","asString","asByteArray","valueRaw","getIntegerState","asBigInt","BigInt","asNumber","getGlobalState","fa","d","scver","compose","client","atc","promiseChain","resultMappers","sendParams","skipSending","push","addTransaction","txn","defaultSender","simulate","options","_a2","txnGroups","returns","methodResults","map","val","i","execute","APP_SPEC2","BiatecCronJobShortHashCallFactory","id","deleteApplication","unregisterApplication","appPoolManager","setPeriod","period","start","noop","exec","BiatecCronJobShortHashClient","_BiatecCronJobShortHashClient","deleteArgs","deleteCall","delete","l","p","s","pool","base642base64url","replaceAll","toNumber","MAX_SAFE_INTEGER","UnsafeConversionError","MIN_SAFE_INTEGER","isNode","process","versions","node","consoleLogger","error","console","warn","info","verbose","debug","nullLogger","trace","message","optionalParams","UpdatableConfig","populateAppCallResources","config","logger","projectRoot","traceAll","traceBufferSizeMb","maxSearchDepth","getLogger","returnNullLogger","withDebug","lambda","original","configureProjectRoot","fs","path","_dirname","async","dirname","url","fileURLToPath","currentPath","existsSync","configure","newConfig","modelsv2","performAtomicTransactionComposerSimulate","unsignedTransactionsSigners","buildGroup","decodedSignedTransactions","ts","simulateRequest","SimulateRequest","allowEmptySignatures","allowMoreLogging","execTraceConfig","SimulateTraceConfig","enable","scratchChange","stackChange","stateChange","SimulateRequestTransactionGroup","txns","simulateResult","simulateTransactions","do","TRACES_FILE_EXT","DEBUG_TRACES_DIR","simulateAndPersistResponse","bufferSizeMb","atcToSimulate","clone","txnTypesCount","reduce","acc","txnGroup","txnType","txnResults","txnResult","type","txnTypesStr","entries","count","join","timestamp","Date","toISOString","replace","outputRootDir","outputFileName","lastRound","outputFilePath","promises","access","err","code","mkdir","recursive","totalSize","all","readdir","file","stat","size","sortedFiles","stats","mtime","resolvedFiles","sort","getTime","oldestFilePromise","shift","oldestFile","unlink","writeFile","JSON","stringify","get_obj_for_encoding","String","stack","AtomicTransactionComposer","MAX_APP_CALL_FOREIGN_REFERENCES","MAX_APP_CALL_ACCOUNT_REFERENCES","arc2Payload","dAppName","format","data","encoder","TextEncoder","encode","n","lease","lease32","set","addr","address","getTransactionWithSigner","transaction","undefined","signer","getSenderTransactionSigner","memoize","fn","cache","Map","cached","has","get","signTransaction","signTxn","sk","blob","sign","send","skipWaiting","maxFee","suppressLog","maxRoundsToWaitForConfirmation","controlFees","txnToSend","populateResources","appl","newAtc","packed","signedTransaction","confirmation","sendRawTransaction","txID","waitForConfirmation","getUnnamedAppCallResourcesAccessed","simReq","allowUnnamedResources","signerWithFixedSgnr","indexes","stxns","stxn","decodedStxn","authAddr","accountInformation","stxnObj","sgnr","emptySignerAtc","forEach","t","groupResponse","simulateResponse","failureMessage","failedAt","group","unnamedResourcesAccessed","r","boxes","extraBoxRefs","appLocals","assetHoldings","accounts","appAccounts","apps","appForeignApps","assets","appForeignAssets","populateGroupResource","reference","isApplBelowLimit","account","txnIndex","findIndex","includes","values","f","asset","g","filter","ref","atcSend","givenAtc","transactionsWithSigner","transactionsToSend","groupId","confirmations","PendingTransactionResponse","from_obj_for_encoding","pendingTransactionInformation","txIds","transactions","rawReturnValue","response","headers","traces","execTrace","appBudget","appBudgetConsumed","logicSigBudget","logicSigBudgetConsumed","logs","transactionId","maxRoundsToWait","status","NodeStatusResponse","startRound","currentRound","pendingInfo","confirmedRound","poolError","statusAfterBlock","capTransactionFee","maxAcceptableFee","flatFee","microAlgos","feeControl","getTransactionParams","getAtomicTransactionComposerTransactions","UPDATABLE_TEMPLATE_NAME","DELETABLE_TEMPLATE_NAME","APP_DEPLOY_NOTE_DAPP","APP_PAGE_MAX_SIZE","OnUpdate","OnSchemaBreak","ABIMethod","OnApplicationComplete","SourceMap","createApp","approvalProgram","approval","clearStateProgram","clear","schema","transactionParams","compiledApproval","compileTeal","compiledBase64ToBytes","compiledClear","clearProgram","attachATC","before","addMethodCall","appID","numLocalInts","localInts","numLocalByteSlices","localByteSlices","numGlobalInts","globalInts","numGlobalByteSlices","globalByteSlices","extraPages","Math","floor","onComplete","getAppOnCompleteAction","suggestedParams","getAppArgsForABICall","after","slice","appId","appAddress","applicationIndex","getABIReturn","getAppArgsForTransaction","rekeyTo","updateApp","UpdateApplicationOC","onCompletionAction","NoOpOC","OptInOC","CloseOutOC","ClearStateOC","DeleteApplicationOC","callApp","callType","appCallParams","resultDummy","parseMethodResponse","getAppGlobalState","appInfo","getAppById","globalState","decodeAppState","getAppLocalState","accountAddress","AccountApplicationResponse","accountApplicationInformation","appLocalState","keyValue","getAppBoxNames","boxResult","getApplicationBoxes","nameRaw","nameBase64","getAppBoxValue","boxName","getApplicationBoxByName","getAppBoxValueFromABIType","request","decode","stateValues","stateVal","keyBase64","keyRaw","tealValue","dataTypeFlag","action","valueBase64","bytes","uint","_getAccountAddress","appArgs","getBoxReference","foreignApps","foreignAssets","index","box","Application","getApplicationByID","tealCode","compiled","compile","sourcemap","teal","compiledHash","hash","sourceMap","getABIMethodSignature","getSignature","DEFAULT_INDEXER_MAX_API_RESOURCES_PER_ACCOUNT","lookupAccountCreatedApplicationByAddress","indexer","getAll","paginationLimit","executePaginatedRequest","applications","nextToken","lookupAccountCreatedApplications","includeAll","limit","searchTransactions","searchCriteria","searchForTransactions","extractItems","buildRequest","results","items","getApplicationAddress","TransactionType","deployApp","deployment","metadata","deployTimeParams","deployTimeParameters","onSchemaBreak","onUpdate","existingDeployments","appParams","creator","performTemplateSubstitutionAndCompile","getCreatorAppsByName","getAppDeploymentTransactionNote","createdMetadata","createdRound","updatedRound","deleted","operationPerformed","existingApp","existingAppRecord","existingApproval","existingClear","existingGlobalSchema","globalStateSchema","existingLocalSchema","localStateSchema","newGlobalSchema","ApplicationStateSchema","numByteSlice","numUint","newLocalSchema","newApproval","newClear","isUpdate","isSchemaBreak","isSchemaIsBroken","createTransaction","createTransactions","deleteTransaction","createConfirmation","deleteConfirmation","newAppIndex","deleteReturn","deleteResult","global","local","to","Fail","AppendApp","deletable","UpdateApp","updatable","ReplaceApp","creatorAccount","appLookup","creatorAddress","createdApps","createdAtRound","createdApp","appTransactions","minRound","txType","applicationID","addressRole","notePrefix","appCreationTransaction","latestAppUpdateTransaction","parseNote","decoder","TextDecoder","noteAsBase64","noteAsString","startsWith","parse","substring","creationNote","updateNote","replaceDeployTimeControlParams","RegExp","performTemplateSubstitution","templateParams","token","padStart","ArrayBuffer","isView","deploymentMetadata","stripTealComments","regex","split","tealCodeLine","trim","AVMDebuggerSourceMapEntry","location","programHash","equals","other","AVMDebuggerSourceMap","txnGroupSources","fromDict","item","toDict","PersistSourceMapInput","appName","fileName","rawTeal","compiledTeal","_rawTeal","_fileName","stripTealExtension","fromRawTeal","fromCompiledTeal","endsWith","ALGOKIT_DIR","SOURCES_DIR","SOURCES_FILE","TEAL_FILE_EXT","TEAL_SOURCEMAP_EXT","loadOrCreateSources","sourcesPath","readFile","upsertDebugSourcemaps","sourceMaps","sources","sourceFilePath","splice","writeToFile","filePath","content","buildAVMSourcemap","outputPath","withSources","digest","outputDirPath","sourceMapOutputPath","tealOutputPath","persistSourceMaps","source","transfer","closeRemainderTo","encodedLease","addLease","LOGIC_ERROR","LogicError","parseLogicError","errorMessage","res","txId","msg","desc","pc","parseInt","errorDetails","program","super","lines","teal_line","led","line","getLineForPc","stop","stack_lines","ValidationType","Indexer","getDeployTimeControl","appSpec","templateVariableName","callConfigKey","bareCallConfig","bare_call_config","hints","some","h","abiCallConfig","call_config","appIdentifier","_appName","contract","resolveBy","_appId","_creator","findExistingUsing","_appAddress","compilation","approvalTemplate","approvalCompiled","_approvalSourceMap","clearTemplate","clearCompiled","_clearSourceMap","exportSourceMaps","approvalSourceMap","clearSourceMap","importSourceMaps","deploySender","allowUpdate","allowDelete","deployArgs","getAppReference","num_byte_slices","num_uints","getCallArgs","appMetadata","exposeLogicError","createSender","updateSender","getABIMethod","read_only","callOfType","find","at","optIn","closeOut","callSender","fundAppAccount","fund","appRef","getLocalState","getBoxNames","getBoxValue","getBoxValueFromABIType","getBoxValues","names","_","getBoxValuesFromABIType","abiMethod","getABIMethodParams","methodSignature","arg","argName","defaultValueStrategy","default_arguments","methods","m","methodParams","isClear","getAppClient","DispenserAssetName","Algo","URLTokenBaseHTTPError","URLTokenBaseHTTPClient","tokenHeader","baseServer","port","defaultHeaders","fixedBaseServer","baseServerURL","URL","protocol","baseURL","getURL","relativePath","query","fixedRelativePath","searchParams","formatFetchResponseHeaders","headersObj","checkHttpError","ok","body","bodyErrorMessage","arrayBuffer","decoded","statusText","formatFetchResponse","requestHeaders","fetch","mode","post","callWithRetry","func","numTries","MAX_TRIES","RETRY_ERROR_CODES","RETRY_STATUS_CODES","delayTimeMs","min","pow","MAX_BACKOFF_MS","setTimeout","amountInMicroAlgos","algos","toLocaleString","valueOf","Algos","MicroAlgos"],"sourceRoot":""}